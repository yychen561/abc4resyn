# 1 "/app/abc/src/base/main/print_Frame.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/app/abc/src/base/main/print_Frame.c"
# 1 "/app/abc/src/base/main/mainInt.h" 1
# 29 "/app/abc/src/base/main/mainInt.h"
# 1 "/app/abc/src/base/main/main.h" 1
# 30 "/app/abc/src/base/main/main.h"
# 1 "/app/abc/src/base/abc/abc.h" 1
# 28 "/app/abc/src/base/abc/abc.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4

# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 38 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 22 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4




typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 389 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 57 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 71 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef _G_fpos_t fpos_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 173 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 265 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 278 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 365 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 443 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 868 "/usr/include/stdio.h" 3 4

# 29 "/app/abc/src/base/abc/abc.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 157 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


extern unsigned int gnu_dev_major (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 254 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 148 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 165 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 563 "/usr/include/stdlib.h" 3 4
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 644 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 817 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 837 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 1006 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4

# 30 "/app/abc/src/base/abc/abc.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 153 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 384 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 409 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 427 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 498 "/usr/include/string.h" 3 4

# 31 "/app/abc/src/base/abc/abc.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 32 "/app/abc/src/base/abc/abc.h" 2

# 1 "/app/abc/src/misc/vec/vec.h" 1
# 29 "/app/abc/src/misc/vec/vec.h"
# 1 "/app/abc/src/misc/util/abc_global.h" 1
# 76 "/app/abc/src/misc/util/abc_global.h"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));
# 104 "/usr/include/time.h" 3 4
extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 119 "/usr/include/time.h" 3 4
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 307 "/usr/include/time.h" 3 4

# 77 "/app/abc/src/misc/util/abc_global.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 78 "/app/abc/src/misc/util/abc_global.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 80 "/app/abc/src/misc/util/abc_global.h" 2
# 91 "/app/abc/src/misc/util/abc_global.h"
# 1 "/app/abc/src/misc/util/abc_namespaces.h" 1
# 92 "/app/abc/src/misc/util/abc_global.h" 2
# 144 "/app/abc/src/misc/util/abc_global.h"

# 156 "/app/abc/src/misc/util/abc_global.h"

# 156 "/app/abc/src/misc/util/abc_global.h"
typedef long ABC_PTRDIFF_T;
# 175 "/app/abc/src/misc/util/abc_global.h"
typedef unsigned long ABC_PTRUINT_T;
# 194 "/app/abc/src/misc/util/abc_global.h"
typedef long ABC_PTRINT_T;
# 211 "/app/abc/src/misc/util/abc_global.h"
typedef long ABC_INT64_T;
# 228 "/app/abc/src/misc/util/abc_global.h"
typedef unsigned long ABC_UINT64_T;
# 243 "/app/abc/src/misc/util/abc_global.h"
typedef ABC_UINT64_T word;
typedef ABC_INT64_T iword;
# 271 "/app/abc/src/misc/util/abc_global.h"
static inline int Abc_AbsInt( int a ) { return a < 0 ? -a : a; }
static inline int Abc_MaxInt( int a, int b ) { return a > b ? a : b; }
static inline int Abc_MinInt( int a, int b ) { return a < b ? a : b; }
static inline word Abc_MaxWord( word a, word b ) { return a > b ? a : b; }
static inline word Abc_MinWord( word a, word b ) { return a < b ? a : b; }
static inline float Abc_AbsFloat( float a ) { return a < 0 ? -a : a; }
static inline float Abc_MaxFloat( float a, float b ) { return a > b ? a : b; }
static inline float Abc_MinFloat( float a, float b ) { return a < b ? a : b; }
static inline double Abc_AbsDouble( double a ) { return a < 0 ? -a : a; }
static inline double Abc_MaxDouble( double a, double b ) { return a > b ? a : b; }
static inline double Abc_MinDouble( double a, double b ) { return a < b ? a : b; }

static inline int Abc_Float2Int( float Val ) { union { int x; float y; } v; v.y = Val; return v.x; }
static inline float Abc_Int2Float( int Num ) { union { int x; float y; } v; v.x = Num; return v.y; }
static inline word Abc_Dbl2Word( double Dbl ) { union { word x; double y; } v; v.y = Dbl; return v.x; }
static inline double Abc_Word2Dbl( word Num ) { union { word x; double y; } v; v.x = Num; return v.y; }
static inline int Abc_Base2Log( unsigned n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n >>= 1, r++ ) {}; return r; }
static inline int Abc_Base10Log( unsigned n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n /= 10, r++ ) {}; return r; }
static inline int Abc_Base16Log( unsigned n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n /= 16, r++ ) {}; return r; }
static inline int Abc_Base2LogW( word n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n >>= 1, r++ ) {}; return r; }
static inline int Abc_Base10LogW( word n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n /= 10, r++ ) {}; return r; }
static inline int Abc_Base16LogW( word n ) { int r; if ( n < 2 ) return (int)n; for ( r = 0, n--; n; n /= 16, r++ ) {}; return r; }
static inline char * Abc_UtilStrsav( char * s ) { return s ? strcpy(((char *) malloc(sizeof(char) * (size_t)(strlen(s)+1))), s) : 
# 293 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                                                                                    ((void *)0)
# 293 "/app/abc/src/misc/util/abc_global.h"
                                                                                                                        ; }
static inline char * Abc_UtilStrsavTwo( char * s, char * a ){ char * r; if (!a) return Abc_UtilStrsav(s); r = ((char *) malloc(sizeof(char) * (size_t)(strlen(s)+strlen(a)+1))); sprintf(r, "%s%s", s, a ); return r; }
static inline char * Abc_UtilStrsavNum( char * s, int n ) { char * r; if (!s) return 
# 295 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                                                        ((void *)0)
# 295 "/app/abc/src/misc/util/abc_global.h"
                                                                                            ; r = ((char *) malloc(sizeof(char) * (size_t)(strlen(s)+12+1))); sprintf(r, "%s%d", s, n ); return r; }
static inline int Abc_BitByteNum( int nBits ) { return (nBits>>3) + ((nBits&7) > 0); }
static inline int Abc_BitWordNum( int nBits ) { return (nBits>>5) + ((nBits&31) > 0); }
static inline int Abc_Bit6WordNum( int nBits ) { return (nBits>>6) + ((nBits&63) > 0); }
static inline int Abc_TruthByteNum( int nVars ) { return nVars <= 3 ? 1 : (1 << (nVars - 3)); }
static inline int Abc_TruthWordNum( int nVars ) { return nVars <= 5 ? 1 : (1 << (nVars - 5)); }
static inline int Abc_Truth6WordNum( int nVars ) { return nVars <= 6 ? 1 : (1 << (nVars - 6)); }
static inline int Abc_InfoHasBit( unsigned * p, int i ) { return (p[(i)>>5] & (unsigned)(1<<((i) & 31))) > 0; }
static inline void Abc_InfoSetBit( unsigned * p, int i ) { p[(i)>>5] |= (unsigned)(1<<((i) & 31)); }
static inline void Abc_InfoXorBit( unsigned * p, int i ) { p[(i)>>5] ^= (unsigned)(1<<((i) & 31)); }
static inline unsigned Abc_InfoMask( int nVar ) { return (~(unsigned)0) >> (32-nVar); }

static inline int Abc_Var2Lit( int Var, int c ) { 
# 307 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 307 "/app/abc/src/misc/util/abc_global.h"
                                                               Var >= 0 && !(c >> 1)
# 307 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 307 "/app/abc/src/misc/util/abc_global.h"
                                                               Var >= 0 && !(c >> 1)
# 307 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 307 "/app/abc/src/misc/util/abc_global.h"
                                                               "Var >= 0 && !(c >> 1)"
# 307 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 307, __extension__ __PRETTY_FUNCTION__); }))
# 307 "/app/abc/src/misc/util/abc_global.h"
                                                                                            ; return Var + Var + c; }
static inline int Abc_Lit2Var( int Lit ) { 
# 308 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 308 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 308 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 308 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 308 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 308 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 308 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 308, __extension__ __PRETTY_FUNCTION__); }))
# 308 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit >> 1; }
static inline int Abc_LitIsCompl( int Lit ) { 
# 309 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 309 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 309 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 309 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 309 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 309 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 309 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 309, __extension__ __PRETTY_FUNCTION__); }))
# 309 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit & 1; }
static inline int Abc_LitNot( int Lit ) { 
# 310 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 310 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 310 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 310 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 310 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 310 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 310 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 310, __extension__ __PRETTY_FUNCTION__); }))
# 310 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit ^ 1; }
static inline int Abc_LitNotCond( int Lit, int c ) { 
# 311 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 311 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 311 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 311 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 311 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 311 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 311 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 311, __extension__ __PRETTY_FUNCTION__); }))
# 311 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit ^ (int)(c > 0); }
static inline int Abc_LitRegular( int Lit ) { 
# 312 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 312 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 312 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 312 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 312 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 312 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 312 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 312, __extension__ __PRETTY_FUNCTION__); }))
# 312 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit & ~01; }
static inline int Abc_Lit2LitV( int * pMap, int Lit ) { 
# 313 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 313 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 313 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 313 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 313 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 313 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 313 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 313, __extension__ __PRETTY_FUNCTION__); }))
# 313 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Abc_Var2Lit( pMap[Abc_Lit2Var(Lit)], Abc_LitIsCompl(Lit) ); }
static inline int Abc_Lit2LitL( int * pMap, int Lit ) { 
# 314 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 314 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 314 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 314 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 314 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 314 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 314 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 314, __extension__ __PRETTY_FUNCTION__); }))
# 314 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Abc_LitNotCond( pMap[Abc_Lit2Var(Lit)], Abc_LitIsCompl(Lit) ); }

static inline int Abc_Ptr2Int( void * p ) { return (int)(ABC_PTRINT_T)p; }
static inline void * Abc_Int2Ptr( int i ) { return (void *)(ABC_PTRINT_T)i; }
static inline word Abc_Ptr2Wrd( void * p ) { return (word)(ABC_PTRUINT_T)p; }
static inline void * Abc_Wrd2Ptr( word i ) { return (void *)(ABC_PTRUINT_T)i; }

static inline int Abc_Var2Lit2( int Var, int Att ) { 
# 321 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 321 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 2)
# 321 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 321 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 2)
# 321 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 321 "/app/abc/src/misc/util/abc_global.h"
                                                               "!(Att >> 2)"
# 321 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 321, __extension__ __PRETTY_FUNCTION__); }))
# 321 "/app/abc/src/misc/util/abc_global.h"
                                                                                  ; return (Var << 2) + Att; }
static inline int Abc_Lit2Var2( int Lit ) { 
# 322 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 322 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 322 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 322 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 322 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 322 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 322 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 322, __extension__ __PRETTY_FUNCTION__); }))
# 322 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit >> 2; }
static inline int Abc_Lit2Att2( int Lit ) { 
# 323 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 323 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 323 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 323 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 323 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 323 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 323 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 323, __extension__ __PRETTY_FUNCTION__); }))
# 323 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit & 3; }
static inline int Abc_Var2Lit3( int Var, int Att ) { 
# 324 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 324 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 3)
# 324 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 324 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 3)
# 324 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 324 "/app/abc/src/misc/util/abc_global.h"
                                                               "!(Att >> 3)"
# 324 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 324, __extension__ __PRETTY_FUNCTION__); }))
# 324 "/app/abc/src/misc/util/abc_global.h"
                                                                                  ; return (Var << 3) + Att; }
static inline int Abc_Lit2Var3( int Lit ) { 
# 325 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 325 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 325 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 325 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 325 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 325 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 325 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 325, __extension__ __PRETTY_FUNCTION__); }))
# 325 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit >> 3; }
static inline int Abc_Lit2Att3( int Lit ) { 
# 326 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 326 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 326 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 326 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 326 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 326 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 326 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 326, __extension__ __PRETTY_FUNCTION__); }))
# 326 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit & 7; }
static inline int Abc_Var2Lit4( int Var, int Att ) { 
# 327 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 327 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 4)
# 327 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 327 "/app/abc/src/misc/util/abc_global.h"
                                                               !(Att >> 4)
# 327 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 327 "/app/abc/src/misc/util/abc_global.h"
                                                               "!(Att >> 4)"
# 327 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 327, __extension__ __PRETTY_FUNCTION__); }))
# 327 "/app/abc/src/misc/util/abc_global.h"
                                                                                  ; return (Var << 4) + Att; }
static inline int Abc_Lit2Var4( int Lit ) { 
# 328 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 328 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 328 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 328 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 328 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 328 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 328 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 328, __extension__ __PRETTY_FUNCTION__); }))
# 328 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit >> 4; }
static inline int Abc_Lit2Att4( int Lit ) { 
# 329 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ((void) sizeof ((
# 329 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 329 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ? 1 : 0), __extension__ ({ if (
# 329 "/app/abc/src/misc/util/abc_global.h"
                                                               Lit >= 0
# 329 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               ) ; else __assert_fail (
# 329 "/app/abc/src/misc/util/abc_global.h"
                                                               "Lit >= 0"
# 329 "/app/abc/src/misc/util/abc_global.h" 3 4
                                                               , "/app/abc/src/misc/util/abc_global.h", 329, __extension__ __PRETTY_FUNCTION__); }))
# 329 "/app/abc/src/misc/util/abc_global.h"
                                                                               ; return Lit & 15; }

typedef ABC_INT64_T abctime;

static inline abctime Abc_Clock()
{






    struct timespec ts;
    if ( clock_gettime(
# 342 "/app/abc/src/misc/util/abc_global.h" 3 4
                      1
# 342 "/app/abc/src/misc/util/abc_global.h"
                                     , &ts) < 0 )
        return (abctime)-1;
    abctime res = ((abctime) ts.tv_sec) * 
# 344 "/app/abc/src/misc/util/abc_global.h" 3 4
                                         ((__clock_t) 1000000)
# 344 "/app/abc/src/misc/util/abc_global.h"
                                                       ;
    res += (((abctime) ts.tv_nsec) * 
# 345 "/app/abc/src/misc/util/abc_global.h" 3 4
                                    ((__clock_t) 1000000)
# 345 "/app/abc/src/misc/util/abc_global.h"
                                                  ) / 1000000000;
    return res;



}

static inline abctime Abc_ThreadClock()
{






    struct timespec ts;
    if ( clock_gettime(
# 361 "/app/abc/src/misc/util/abc_global.h" 3 4
                      3
# 361 "/app/abc/src/misc/util/abc_global.h"
                                             , &ts) < 0 )
        return (abctime)-1;
    abctime res = ((abctime) ts.tv_sec) * 
# 363 "/app/abc/src/misc/util/abc_global.h" 3 4
                                         ((__clock_t) 1000000)
# 363 "/app/abc/src/misc/util/abc_global.h"
                                                       ;
    res += (((abctime) ts.tv_nsec) * 
# 364 "/app/abc/src/misc/util/abc_global.h" 3 4
                                    ((__clock_t) 1000000)
# 364 "/app/abc/src/misc/util/abc_global.h"
                                                  ) / 1000000000;
    return res;



}


enum Abc_VerbLevel
{
    ABC_PROMPT = -2,
    ABC_ERROR = -1,
    ABC_WARNING = 0,
    ABC_STANDARD = 1,
    ABC_VERBOSE = 2
};







extern int Gia_ManToBridgeText( FILE * pFile, int Size, unsigned char * pBuffer );
extern int Gia_ManToBridgeAbsNetlist( FILE * pFile, void * p, int pkg_type );


extern char * vnsprintf(const char* format, va_list args);
extern char * nsprintf(const char* format, ...);

static inline void Abc_Print( int level, const char * format, ... )
{
    extern int Abc_FrameIsBridgeMode();
    va_list args;
    extern unsigned enable_dbg_outs;
    if ( !enable_dbg_outs )
        return;

    if ( ! Abc_FrameIsBridgeMode() ){
        if ( level == ABC_ERROR )
            printf( "Error: " );
        else if ( level == ABC_WARNING )
            printf( "Warning: " );
    }else{
        if ( level == ABC_ERROR )
            Gia_ManToBridgeText( 
# 409 "/app/abc/src/misc/util/abc_global.h" 3 4
                                stdout
# 409 "/app/abc/src/misc/util/abc_global.h"
                                      , (int)strlen("Error: "), (unsigned char*)"Error: " );
        else if ( level == ABC_WARNING )
            Gia_ManToBridgeText( 
# 411 "/app/abc/src/misc/util/abc_global.h" 3 4
                                stdout
# 411 "/app/abc/src/misc/util/abc_global.h"
                                      , (int)strlen("Warning: "), (unsigned char*)"Warning: " );
    }

    
# 414 "/app/abc/src/misc/util/abc_global.h" 3 4
   __builtin_va_start(
# 414 "/app/abc/src/misc/util/abc_global.h"
   args
# 414 "/app/abc/src/misc/util/abc_global.h" 3 4
   ,
# 414 "/app/abc/src/misc/util/abc_global.h"
   format
# 414 "/app/abc/src/misc/util/abc_global.h" 3 4
   )
# 414 "/app/abc/src/misc/util/abc_global.h"
                           ;
    if ( Abc_FrameIsBridgeMode() )
    {
        char * tmp = vnsprintf( format, args );
        Gia_ManToBridgeText( 
# 418 "/app/abc/src/misc/util/abc_global.h" 3 4
                            stdout
# 418 "/app/abc/src/misc/util/abc_global.h"
                                  , (int)strlen(tmp), (unsigned char*)tmp );
        free( tmp );
    }
    else
        vprintf( format, args );
    
# 423 "/app/abc/src/misc/util/abc_global.h" 3 4
   __builtin_va_end(
# 423 "/app/abc/src/misc/util/abc_global.h"
   args
# 423 "/app/abc/src/misc/util/abc_global.h" 3 4
   )
# 423 "/app/abc/src/misc/util/abc_global.h"
                 ;
}
# 443 "/app/abc/src/misc/util/abc_global.h"
static inline void Abc_PrintInt( int i )
{
    double v3 = (double)i/1000;
    double v6 = (double)i/1000000;

    Abc_Print( 1, "  " );

    if ( i > -1000 && i < 1000 )
        Abc_Print( 1, " %4d", i );

    else if ( v3 > -9.995 && v3 < 9.995 )
        Abc_Print( 1, "%4.2fk", v3 );
    else if ( v3 > -99.95 && v3 < 99.95 )
        Abc_Print( 1, "%4.1fk", v3 );
    else if ( v3 > -999.5 && v3 < 999.5 )
        Abc_Print( 1, "%4.0fk", v3 );

    else if ( v6 > -9.995 && v6 < 9.995 )
        Abc_Print( 1, "%4.2fm", v6 );
    else if ( v6 > -99.95 && v6 < 99.95 )
        Abc_Print( 1, "%4.1fm", v6 );
    else if ( v6 > -999.5 && v6 < 999.5 )
        Abc_Print( 1, "%4.0fm", v6 );
}


static inline void Abc_PrintTime( int level, const char * pStr, abctime time )
{
    (Abc_Print(1, "%s =", (pStr)), Abc_Print(1, "%9.2f sec\n", 1.0*((double)(time))/((double)
# 471 "/app/abc/src/misc/util/abc_global.h" 3 4
   ((__clock_t) 1000000)
# 471 "/app/abc/src/misc/util/abc_global.h"
   )));
}

static inline void Abc_PrintTimeP( int level, const char * pStr, abctime time, abctime Time )
{
    (Abc_Print(1, "%s =", (pStr)), Abc_Print(1, "%9.2f sec (%6.2f %%)\n", 1.0*((double)(time))/((double)
# 476 "/app/abc/src/misc/util/abc_global.h" 3 4
   ((__clock_t) 1000000)
# 476 "/app/abc/src/misc/util/abc_global.h"
   ), ((double)(Time))? 100.0*((double)(time))/((double)(Time)) : 0.0));
}

static inline void Abc_PrintMemoryP( int level, const char * pStr, int mem, int Mem )
{
    (Abc_Print(1, "%s =", (pStr)), Abc_Print(1, "%10.3f MB (%6.2f %%)\n", (1.0*((double)(mem))/(1<<20)), (((double)(Mem))? 100.0*((double)(mem))/((double)(Mem)) : 0.0) ) );
}


static inline int Abc_PrimeCudd( unsigned int p )
{
    int i,pn;
    p--;
    do {
        p++;
        if (p&1)
        {
            pn = 1;
            i = 3;
            while ((unsigned) (i * i) <= p)
            {
                if (p % (unsigned)i == 0) {
                    pn = 0;
                    break;
                }
                i += 2;
            }
        }
        else
            pn = 0;
    } while (!pn);
    return (int)(p);

}


static inline void * Abc_FileReadContents( char * pFileName, int * pnFileSize )
{
    int RetValue, nFileSize;
    char * pBuffer;
    FILE * pFile = fopen( pFileName, "rb" );
    if ( pFile == 
# 517 "/app/abc/src/misc/util/abc_global.h" 3 4
                 ((void *)0) 
# 517 "/app/abc/src/misc/util/abc_global.h"
                      )
        return 
# 518 "/app/abc/src/misc/util/abc_global.h" 3 4
              ((void *)0)
# 518 "/app/abc/src/misc/util/abc_global.h"
                  ;

    fseek( pFile, 0, 
# 520 "/app/abc/src/misc/util/abc_global.h" 3 4
                    2 
# 520 "/app/abc/src/misc/util/abc_global.h"
                             );
    nFileSize = ftell( pFile );
    if ( pnFileSize )
        *pnFileSize = nFileSize;
    rewind( pFile );

    pBuffer = ((char *) malloc(sizeof(char) * (size_t)(nFileSize + 32)));
    RetValue = fread( pBuffer, 1, nFileSize, pFile );
    memset( pBuffer + nFileSize, 0, 32 );
    
# 529 "/app/abc/src/misc/util/abc_global.h" 3 4
   ((void) sizeof ((
# 529 "/app/abc/src/misc/util/abc_global.h"
   RetValue == nFileSize
# 529 "/app/abc/src/misc/util/abc_global.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 529 "/app/abc/src/misc/util/abc_global.h"
   RetValue == nFileSize
# 529 "/app/abc/src/misc/util/abc_global.h" 3 4
   ) ; else __assert_fail (
# 529 "/app/abc/src/misc/util/abc_global.h"
   "RetValue == nFileSize"
# 529 "/app/abc/src/misc/util/abc_global.h" 3 4
   , "/app/abc/src/misc/util/abc_global.h", 529, __extension__ __PRETTY_FUNCTION__); }))
# 529 "/app/abc/src/misc/util/abc_global.h"
                                  ;
    fclose( pFile );
    return (void *)pBuffer;
}
static inline void Abc_ReverseOrder( int * pA, int nA )
{
    int i;
    for ( i = 0; i < nA/2; i++ )
        { int t = pA[i]; pA[i] = pA[nA-1-i]; pA[nA-1-i] = t; };
}



extern void Abc_MergeSort( int * pInput, int nSize );
extern int * Abc_MergeSortCost( int * pCosts, int nSize );
extern void Abc_MergeSortCost2( int * pInput, int nSize, int * pCost );
extern void Abc_MergeSortCost2Reverse( int * pInput, int nSize, int * pCost );
extern void Abc_QuickSort1( word * pData, int nSize, int fDecrease );
extern void Abc_QuickSort2( word * pData, int nSize, int fDecrease );
extern void Abc_QuickSort3( word * pData, int nSize, int fDecrease );
extern void Abc_QuickSortCostData( int * pCosts, int nSize, int fDecrease, word * pData, int * pResult );
extern int * Abc_QuickSortCost( int * pCosts, int nSize, int fDecrease );

extern unsigned Abc_Random( int fReset );
extern word Abc_RandomW( int fReset );


extern void Util_ProcessThreads( int (*pUserFunc)(void *), void * vData, int nProcs, int TimeOut, int fVerbose );


# 30 "/app/abc/src/misc/vec/vec.h" 2

# 1 "/app/abc/src/misc/vec/vecInt.h" 1
# 31 "/app/abc/src/misc/vec/vecInt.h"

# 42 "/app/abc/src/misc/vec/vecInt.h"
typedef struct Vec_Int_t_ Vec_Int_t;
struct Vec_Int_t_
{
    int nCap;
    int nSize;
    int * pArray;
};
# 98 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntAlloc( int nCap )
{
    Vec_Int_t * p;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 16 )
        nCap = 16;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((int *) malloc(sizeof(int) * (size_t)(p->nCap))) : 
# 106 "/app/abc/src/misc/vec/vecInt.h" 3 4
                                                    ((void *)0)
# 106 "/app/abc/src/misc/vec/vecInt.h"
                                                        ;
    return p;
}
static inline Vec_Int_t * Vec_IntAllocExact( int nCap )
{
    Vec_Int_t * p;
    
# 112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 112 "/app/abc/src/misc/vec/vecInt.h"
   nCap >= 0
# 112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 112 "/app/abc/src/misc/vec/vecInt.h"
   nCap >= 0
# 112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 112 "/app/abc/src/misc/vec/vecInt.h"
   "nCap >= 0"
# 112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 112, __extension__ __PRETTY_FUNCTION__); }))
# 112 "/app/abc/src/misc/vec/vecInt.h"
                      ;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((int *) malloc(sizeof(int) * (size_t)(p->nCap))) : 
# 116 "/app/abc/src/misc/vec/vecInt.h" 3 4
                                                    ((void *)0)
# 116 "/app/abc/src/misc/vec/vecInt.h"
                                                        ;
    return p;
}
# 131 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntStart( int nSize )
{
    Vec_Int_t * p;
    p = Vec_IntAlloc( nSize );
    p->nSize = nSize;
    if ( p->pArray ) memset( p->pArray, 0, sizeof(int) * (size_t)nSize );
    return p;
}
static inline Vec_Int_t * Vec_IntStartFull( int nSize )
{
    Vec_Int_t * p;
    p = Vec_IntAlloc( nSize );
    p->nSize = nSize;
    if ( p->pArray ) memset( p->pArray, 0xff, sizeof(int) * (size_t)nSize );
    return p;
}
static inline Vec_Int_t * Vec_IntStartRange( int First, int Range )
{
    Vec_Int_t * p;
    int i;
    p = Vec_IntAlloc( Range );
    p->nSize = Range;
    for ( i = 0; i < Range; i++ )
        p->pArray[i] = First + i;
    return p;
}
static inline Vec_Int_t * Vec_IntStartRandomLimit( int nSize, int Upper, int Lower )
{
    Vec_Int_t * p = Vec_IntAlloc( nSize );
    int i, Gap = Upper - Lower + 1;
    for ( i = 0; i < p->nSize; i++ )
        p->pArray[i] = Lower + Abc_Random(0) % Gap;
    return p;
}
static inline void Vec_IntRandomizeOrder( Vec_Int_t * p )
{
    int v;
    for ( v = 0; v < p->nSize; v++ )
    {
        int vRand = Abc_Random(0) % p->nSize;
        { int t = p->pArray[vRand]; p->pArray[vRand] = p->pArray[v]; p->pArray[v] = t; };
    }
}
# 186 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntStartNatural( int nSize )
{
    Vec_Int_t * p;
    int i;
    p = Vec_IntAlloc( nSize );
    p->nSize = nSize;
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = i;
    return p;
}
# 208 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntAllocArray( int * pArray, int nSize )
{
    Vec_Int_t * p;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = pArray;
    return p;
}
# 229 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntAllocArrayCopy( int * pArray, int nSize )
{
    Vec_Int_t * p;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = ((int *) malloc(sizeof(int) * (size_t)(nSize)));
    memcpy( p->pArray, pArray, sizeof(int) * (size_t)nSize );
    return p;
}
# 251 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntDup( Vec_Int_t * pVec )
{
    Vec_Int_t * p;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nSize;
    p->pArray = p->nCap? ((int *) malloc(sizeof(int) * (size_t)(p->nCap))) : 
# 257 "/app/abc/src/misc/vec/vecInt.h" 3 4
                                                    ((void *)0)
# 257 "/app/abc/src/misc/vec/vecInt.h"
                                                        ;
    memcpy( p->pArray, pVec->pArray, sizeof(int) * (size_t)pVec->nSize );
    return p;
}
# 273 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntDupArray( Vec_Int_t * pVec )
{
    Vec_Int_t * p;
    p = ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = pVec->pArray;
    pVec->nSize = 0;
    pVec->nCap = 0;
    pVec->pArray = 
# 282 "/app/abc/src/misc/vec/vecInt.h" 3 4
                  ((void *)0)
# 282 "/app/abc/src/misc/vec/vecInt.h"
                      ;
    return p;
}
# 297 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntZero( Vec_Int_t * p )
{
    p->pArray = 
# 299 "/app/abc/src/misc/vec/vecInt.h" 3 4
               ((void *)0)
# 299 "/app/abc/src/misc/vec/vecInt.h"
                   ;
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_IntErase( Vec_Int_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_IntFree( Vec_Int_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 326 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntFreeP( Vec_Int_t ** p )
{
    if ( *p == 
# 328 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0) 
# 328 "/app/abc/src/misc/vec/vecInt.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 345 "/app/abc/src/misc/vec/vecInt.h"
static inline int * Vec_IntReleaseArray( Vec_Int_t * p )
{
    int * pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 350 "/app/abc/src/misc/vec/vecInt.h" 3 4
               ((void *)0)
# 350 "/app/abc/src/misc/vec/vecInt.h"
                   ;
    return pArray;
}
static inline int * Vec_IntReleaseNewArray( Vec_Int_t * p )
{
    int * pArray = ((int *) malloc(sizeof(int) * (size_t)(p->nSize+1)));
    pArray[0] = p->nSize+1;
    memcpy( pArray+1, p->pArray, sizeof(int)*(size_t)p->nSize );
    return pArray;
}
# 372 "/app/abc/src/misc/vec/vecInt.h"
static inline int * Vec_IntArray( Vec_Int_t * p )
{
    return p->pArray;
}
static inline int ** Vec_IntArrayP( Vec_Int_t * p )
{
    return &p->pArray;
}
static inline int * Vec_IntLimit( Vec_Int_t * p )
{
    return p->pArray + p->nSize;
}
# 396 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntSize( Vec_Int_t * p )
{
    return p->nSize;
}
# 412 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntCap( Vec_Int_t * p )
{
    return p->nCap;
}
# 428 "/app/abc/src/misc/vec/vecInt.h"
static inline double Vec_IntMemory( Vec_Int_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(int) * (size_t)p->nCap + sizeof(Vec_Int_t) ;
}
# 444 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntEntry( Vec_Int_t * p, int i )
{
    
# 446 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 446 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 446 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 446 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 446 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 446 "/app/abc/src/misc/vec/vecInt.h"
   "i >= 0 && i < p->nSize"
# 446 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 446, __extension__ __PRETTY_FUNCTION__); }))
# 446 "/app/abc/src/misc/vec/vecInt.h"
                                   ;
    return p->pArray[i];
}
# 461 "/app/abc/src/misc/vec/vecInt.h"
static inline int * Vec_IntEntryP( Vec_Int_t * p, int i )
{
    
# 463 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 463 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 463 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 463 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 463 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 463 "/app/abc/src/misc/vec/vecInt.h"
   "i >= 0 && i < p->nSize"
# 463 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 463, __extension__ __PRETTY_FUNCTION__); }))
# 463 "/app/abc/src/misc/vec/vecInt.h"
                                   ;
    return p->pArray + i;
}
# 478 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntWriteEntry( Vec_Int_t * p, int i, int Entry )
{
    
# 480 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 480 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 480 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 480 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 480 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 480 "/app/abc/src/misc/vec/vecInt.h"
   "i >= 0 && i < p->nSize"
# 480 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 480, __extension__ __PRETTY_FUNCTION__); }))
# 480 "/app/abc/src/misc/vec/vecInt.h"
                                   ;
    p->pArray[i] = Entry;
}
# 495 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntAddToEntry( Vec_Int_t * p, int i, int Addition )
{
    
# 497 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 497 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 497 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 497 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < p->nSize
# 497 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 497 "/app/abc/src/misc/vec/vecInt.h"
   "i >= 0 && i < p->nSize"
# 497 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 497, __extension__ __PRETTY_FUNCTION__); }))
# 497 "/app/abc/src/misc/vec/vecInt.h"
                                   ;
    return p->pArray[i] += Addition;
}
# 512 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntUpdateEntry( Vec_Int_t * p, int i, int Value )
{
    if ( Vec_IntEntry( p, i ) < Value )
        Vec_IntWriteEntry( p, i, Value );
}
static inline void Vec_IntDowndateEntry( Vec_Int_t * p, int i, int Value )
{
    if ( Vec_IntEntry( p, i ) > Value )
        Vec_IntWriteEntry( p, i, Value );
}
# 534 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntEntryLast( Vec_Int_t * p )
{
    
# 536 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 536 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize > 0
# 536 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 536 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize > 0
# 536 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 536 "/app/abc/src/misc/vec/vecInt.h"
   "p->nSize > 0"
# 536 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 536, __extension__ __PRETTY_FUNCTION__); }))
# 536 "/app/abc/src/misc/vec/vecInt.h"
                         ;
    return p->pArray[p->nSize-1];
}
# 551 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntGrow( Vec_Int_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((int *) realloc((char *)(p->pArray), sizeof(int) * (size_t)(nCapMin))) : ((int *) malloc(sizeof(int) * (size_t)(nCapMin))));
    
# 556 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 556 "/app/abc/src/misc/vec/vecInt.h"
   p->pArray
# 556 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 556 "/app/abc/src/misc/vec/vecInt.h"
   p->pArray
# 556 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 556 "/app/abc/src/misc/vec/vecInt.h"
   "p->pArray"
# 556 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 556, __extension__ __PRETTY_FUNCTION__); }))
# 556 "/app/abc/src/misc/vec/vecInt.h"
                      ;
    p->nCap = nCapMin;
}
# 571 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntGrowResize( Vec_Int_t * p, int nCapMin )
{
    p->nSize = nCapMin;
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((int *) realloc((char *)(p->pArray), sizeof(int) * (size_t)(nCapMin))) : ((int *) malloc(sizeof(int) * (size_t)(nCapMin))));
    
# 577 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 577 "/app/abc/src/misc/vec/vecInt.h"
   p->pArray
# 577 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 577 "/app/abc/src/misc/vec/vecInt.h"
   p->pArray
# 577 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 577 "/app/abc/src/misc/vec/vecInt.h"
   "p->pArray"
# 577 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 577, __extension__ __PRETTY_FUNCTION__); }))
# 577 "/app/abc/src/misc/vec/vecInt.h"
                      ;
    p->nCap = nCapMin;
}
# 592 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntFill( Vec_Int_t * p, int nSize, int Fill )
{
    int i;
    Vec_IntGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
static inline void Vec_IntFillTwo( Vec_Int_t * p, int nSize, int FillEven, int FillOdd )
{
    int i;
    Vec_IntGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = (i & 1) ? FillOdd : FillEven;
    p->nSize = nSize;
}
static inline void Vec_IntFillNatural( Vec_Int_t * p, int nSize )
{
    int i;
    Vec_IntGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = i;
    p->nSize = nSize;
}
# 628 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntFillExtra( Vec_Int_t * p, int nSize, int Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_IntGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_IntGrow( p, 2 * p->nCap );
    for ( i = p->nSize; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 653 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntGetEntry( Vec_Int_t * p, int i )
{
    Vec_IntFillExtra( p, i + 1, 0 );
    return Vec_IntEntry( p, i );
}
static inline int Vec_IntGetEntryFull( Vec_Int_t * p, int i )
{
    Vec_IntFillExtra( p, i + 1, -1 );
    return Vec_IntEntry( p, i );
}
# 675 "/app/abc/src/misc/vec/vecInt.h"
static inline int * Vec_IntGetEntryP( Vec_Int_t * p, int i )
{
    Vec_IntFillExtra( p, i + 1, 0 );
    return Vec_IntEntryP( p, i );
}
# 692 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntSetEntry( Vec_Int_t * p, int i, int Entry )
{
    Vec_IntFillExtra( p, i + 1, 0 );
    Vec_IntWriteEntry( p, i, Entry );
}
static inline void Vec_IntSetEntryFull( Vec_Int_t * p, int i, int Entry )
{
    Vec_IntFillExtra( p, i + 1, -1 );
    Vec_IntWriteEntry( p, i, Entry );
}
# 714 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntShrink( Vec_Int_t * p, int nSizeNew )
{
    
# 716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 716 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize >= nSizeNew
# 716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 716 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize >= nSizeNew
# 716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 716 "/app/abc/src/misc/vec/vecInt.h"
   "p->nSize >= nSizeNew"
# 716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 716, __extension__ __PRETTY_FUNCTION__); }))
# 716 "/app/abc/src/misc/vec/vecInt.h"
                                 ;
    p->nSize = nSizeNew;
}
# 731 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntClear( Vec_Int_t * p )
{
    p->nSize = 0;
}
# 747 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntPush( Vec_Int_t * p, int Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_IntGrow( p, 16 );
        else
            Vec_IntGrow( p, 2 * p->nCap );
    }
    p->pArray[p->nSize++] = Entry;
}
static inline int Vec_IntPushReturn( Vec_Int_t * p, int Entry )
{
    Vec_IntPush( p, Entry );
    return Entry;
}
static inline void Vec_IntPushTwo( Vec_Int_t * p, int Entry1, int Entry2 )
{
    Vec_IntPush( p, Entry1 );
    Vec_IntPush( p, Entry2 );
}
static inline void Vec_IntPushThree( Vec_Int_t * p, int Entry1, int Entry2, int Entry3 )
{
    Vec_IntPush( p, Entry1 );
    Vec_IntPush( p, Entry2 );
    Vec_IntPush( p, Entry3 );
}
static inline void Vec_IntPushFour( Vec_Int_t * p, int Entry1, int Entry2, int Entry3, int Entry4 )
{
    Vec_IntPush( p, Entry1 );
    Vec_IntPush( p, Entry2 );
    Vec_IntPush( p, Entry3 );
    Vec_IntPush( p, Entry4 );
}
static inline void Vec_IntPushArray( Vec_Int_t * p, int * pEntries, int nEntries )
{
    int i;
    for ( i = 0; i < nEntries; i++ )
        Vec_IntPush( p, pEntries[i] );
}
static inline void Vec_IntShift( Vec_Int_t * p, int Shift )
{
    p->nSize -= Shift;
    p->nCap -= Shift;
    p->pArray += Shift;
}
# 805 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntPushFirst( Vec_Int_t * p, int Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_IntGrow( p, 16 );
        else
            Vec_IntGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize - 1; i >= 1; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[0] = Entry;
}
# 832 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntPushOrder( Vec_Int_t * p, int Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_IntGrow( p, 16 );
        else
            Vec_IntGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize-2; i >= 0; i-- )
        if ( p->pArray[i] > Entry )
            p->pArray[i+1] = p->pArray[i];
        else
            break;
    p->pArray[i+1] = Entry;
}
static inline void Vec_IntPushOrderCost( Vec_Int_t * p, int Entry, Vec_Int_t * vCost )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_IntGrow( p, 16 );
        else
            Vec_IntGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize-2; i >= 0; i-- )
        if ( Vec_IntEntry(vCost, p->pArray[i]) > Vec_IntEntry(vCost, Entry) )
            p->pArray[i+1] = p->pArray[i];
        else
            break;
    p->pArray[i+1] = Entry;
}
# 880 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntIsOrdered( Vec_Int_t * p, int fReverse )
{
    int i;
    if ( fReverse )
    {
        for ( i = 1; i < p->nSize; i++ )
            if ( p->pArray[i-1] < p->pArray[i] )
                return 0;
    }
    else
    {
        for ( i = 1; i < p->nSize; i++ )
            if ( p->pArray[i-1] > p->pArray[i] )
                return 0;
    }
    return 1;
}
static inline int Vec_IntIsOrderedCost( Vec_Int_t * p, Vec_Int_t * vCost, int fReverse )
{
    int i;
    if ( fReverse )
    {
        for ( i = 1; i < p->nSize; i++ )
            if ( Vec_IntEntry(vCost, p->pArray[i-1]) < Vec_IntEntry(vCost, p->pArray[i]) )
                return 0;
    }
    else
    {
        for ( i = 1; i < p->nSize; i++ )
            if ( Vec_IntEntry(vCost, p->pArray[i-1]) > Vec_IntEntry(vCost, p->pArray[i]) )
                return 0;
    }
    return 1;
}
# 926 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntPushOrderReverse( Vec_Int_t * p, int Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_IntGrow( p, 16 );
        else
            Vec_IntGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize-2; i >= 0; i-- )
        if ( p->pArray[i] < Entry )
            p->pArray[i+1] = p->pArray[i];
        else
            break;
    p->pArray[i+1] = Entry;
}
# 956 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntPushUniqueOrder( Vec_Int_t * p, int Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_IntPushOrder( p, Entry );
    return 0;
}
static inline int Vec_IntPushUniqueOrderCost( Vec_Int_t * p, int Entry, Vec_Int_t * vCost )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_IntPushOrderCost( p, Entry, vCost );
    return 0;
}
# 986 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntPushUnique( Vec_Int_t * p, int Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_IntPush( p, Entry );
    return 0;
}
# 1007 "/app/abc/src/misc/vec/vecInt.h"
static inline unsigned * Vec_IntFetch( Vec_Int_t * p, int nWords )
{
    if ( nWords == 0 )
        return 
# 1010 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0)
# 1010 "/app/abc/src/misc/vec/vecInt.h"
                  ;
    
# 1011 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1011 "/app/abc/src/misc/vec/vecInt.h"
   nWords > 0
# 1011 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1011 "/app/abc/src/misc/vec/vecInt.h"
   nWords > 0
# 1011 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1011 "/app/abc/src/misc/vec/vecInt.h"
   "nWords > 0"
# 1011 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1011, __extension__ __PRETTY_FUNCTION__); }))
# 1011 "/app/abc/src/misc/vec/vecInt.h"
                       ;
    p->nSize += nWords;
    if ( p->nSize > p->nCap )
    {

        return 
# 1016 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0)
# 1016 "/app/abc/src/misc/vec/vecInt.h"
                  ;
    }
    return ((unsigned *)p->pArray) + p->nSize - nWords;
}
# 1032 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntPop( Vec_Int_t * p )
{
    
# 1034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1034 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize > 0
# 1034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1034 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize > 0
# 1034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1034 "/app/abc/src/misc/vec/vecInt.h"
   "p->nSize > 0"
# 1034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1034, __extension__ __PRETTY_FUNCTION__); }))
# 1034 "/app/abc/src/misc/vec/vecInt.h"
                         ;
    return p->pArray[--p->nSize];
}
# 1049 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntFind( Vec_Int_t * p, int Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return i;
    return -1;
}
# 1069 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntRemove( Vec_Int_t * p, int Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            break;
    if ( i == p->nSize )
        return 0;
    
# 1077 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1077 "/app/abc/src/misc/vec/vecInt.h"
   i < p->nSize
# 1077 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1077 "/app/abc/src/misc/vec/vecInt.h"
   i < p->nSize
# 1077 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1077 "/app/abc/src/misc/vec/vecInt.h"
   "i < p->nSize"
# 1077 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1077, __extension__ __PRETTY_FUNCTION__); }))
# 1077 "/app/abc/src/misc/vec/vecInt.h"
                         ;
    for ( i++; i < p->nSize; i++ )
        p->pArray[i-1] = p->pArray[i];
    p->nSize--;
    return 1;
}
static inline int Vec_IntRemove1( Vec_Int_t * p, int Entry )
{
    int i;
    for ( i = 1; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            break;
    if ( i >= p->nSize )
        return 0;
    
# 1091 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1091 "/app/abc/src/misc/vec/vecInt.h"
   i < p->nSize
# 1091 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1091 "/app/abc/src/misc/vec/vecInt.h"
   i < p->nSize
# 1091 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1091 "/app/abc/src/misc/vec/vecInt.h"
   "i < p->nSize"
# 1091 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1091, __extension__ __PRETTY_FUNCTION__); }))
# 1091 "/app/abc/src/misc/vec/vecInt.h"
                         ;
    for ( i++; i < p->nSize; i++ )
        p->pArray[i-1] = p->pArray[i];
    p->nSize--;
    return 1;
}
# 1109 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntDrop( Vec_Int_t * p, int i )
{
    int k;
    
# 1112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1112 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < Vec_IntSize(p)
# 1112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1112 "/app/abc/src/misc/vec/vecInt.h"
   i >= 0 && i < Vec_IntSize(p)
# 1112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1112 "/app/abc/src/misc/vec/vecInt.h"
   "i >= 0 && i < Vec_IntSize(p)"
# 1112 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1112, __extension__ __PRETTY_FUNCTION__); }))
# 1112 "/app/abc/src/misc/vec/vecInt.h"
                                         ;
    p->nSize--;
    for ( k = i; k < p->nSize; k++ )
        p->pArray[k] = p->pArray[k+1];
}
# 1129 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntInsert( Vec_Int_t * p, int iHere, int Entry )
{
    int i;
    
# 1132 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1132 "/app/abc/src/misc/vec/vecInt.h"
   iHere >= 0 && iHere <= p->nSize
# 1132 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1132 "/app/abc/src/misc/vec/vecInt.h"
   iHere >= 0 && iHere <= p->nSize
# 1132 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1132 "/app/abc/src/misc/vec/vecInt.h"
   "iHere >= 0 && iHere <= p->nSize"
# 1132 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1132, __extension__ __PRETTY_FUNCTION__); }))
# 1132 "/app/abc/src/misc/vec/vecInt.h"
                                            ;
    Vec_IntPush( p, 0 );
    for ( i = p->nSize - 1; i > iHere; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[i] = Entry;
}
# 1150 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntFindMax( Vec_Int_t * p )
{
    int i, Best;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best < p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
static inline int Vec_IntArgMax( Vec_Int_t * p )
{
    int i, Best, Arg = 0;
    if ( p->nSize == 0 )
        return -1;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best < p->pArray[i] )
            Best = p->pArray[i], Arg = i;
    return Arg;
}
# 1184 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntFindMin( Vec_Int_t * p )
{
    int i, Best;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best > p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
static inline int Vec_IntArgMin( Vec_Int_t * p )
{
    int i, Best, Arg = 0;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best > p->pArray[i] )
            Best = p->pArray[i], Arg = i;
    return Arg;
}
# 1218 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntReverseOrder( Vec_Int_t * p )
{
    int i, Temp;
    for ( i = 0; i < p->nSize/2; i++ )
    {
        Temp = p->pArray[i];
        p->pArray[i] = p->pArray[p->nSize-1-i];
        p->pArray[p->nSize-1-i] = Temp;
    }
}
# 1240 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntRemoveOdd( Vec_Int_t * p )
{
    int i;
    
# 1243 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1243 "/app/abc/src/misc/vec/vecInt.h"
   (p->nSize & 1) == 0
# 1243 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1243 "/app/abc/src/misc/vec/vecInt.h"
   (p->nSize & 1) == 0
# 1243 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1243 "/app/abc/src/misc/vec/vecInt.h"
   "(p->nSize & 1) == 0"
# 1243 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1243, __extension__ __PRETTY_FUNCTION__); }))
# 1243 "/app/abc/src/misc/vec/vecInt.h"
                                ;
    p->nSize >>= 1;
    for ( i = 0; i < p->nSize; i++ )
        p->pArray[i] = p->pArray[2*i];
}
static inline void Vec_IntRemoveEven( Vec_Int_t * p )
{
    int i;
    
# 1251 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1251 "/app/abc/src/misc/vec/vecInt.h"
   (p->nSize & 1) == 0
# 1251 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1251 "/app/abc/src/misc/vec/vecInt.h"
   (p->nSize & 1) == 0
# 1251 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1251 "/app/abc/src/misc/vec/vecInt.h"
   "(p->nSize & 1) == 0"
# 1251 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1251, __extension__ __PRETTY_FUNCTION__); }))
# 1251 "/app/abc/src/misc/vec/vecInt.h"
                                ;
    p->nSize >>= 1;
    for ( i = 0; i < p->nSize; i++ )
        p->pArray[i] = p->pArray[2*i+1];
}
# 1268 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntInvert( Vec_Int_t * p, int Fill )
{
    int Entry, i;
    Vec_Int_t * vRes = Vec_IntAlloc( 0 );
    if ( Vec_IntSize(p) == 0 )
        return vRes;
    Vec_IntFill( vRes, Vec_IntFindMax(p) + 1, Fill );
    for ( i = 0; (i < Vec_IntSize(p)) && (((Entry) = Vec_IntEntry(p, i)), 1); i++ )
        if ( Entry != Fill )
            Vec_IntWriteEntry( vRes, Entry, i );
    return vRes;
}
# 1292 "/app/abc/src/misc/vec/vecInt.h"
static inline Vec_Int_t * Vec_IntCondense( Vec_Int_t * p, int Fill )
{
    int Entry, i;
    Vec_Int_t * vRes = Vec_IntAlloc( Vec_IntSize(p) );
    for ( i = 0; (i < Vec_IntSize(p)) && (((Entry) = Vec_IntEntry(p, i)), 1); i++ )
        if ( Entry != Fill )
            Vec_IntPush( vRes, Entry );
    return vRes;
}
# 1313 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntSum( Vec_Int_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += p->pArray[i];
    return Counter;
}
# 1332 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntCountEntry( Vec_Int_t * p, int Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] == Entry);
    return Counter;
}
static inline int Vec_IntCountLarger( Vec_Int_t * p, int Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] > Entry);
    return Counter;
}
static inline int Vec_IntCountSmaller( Vec_Int_t * p, int Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] < Entry);
    return Counter;
}
# 1365 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntCountPositive( Vec_Int_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] > 0);
    return Counter;
}
static inline int Vec_IntCountZero( Vec_Int_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] == 0);
    return Counter;
}
# 1391 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntAddPositive( Vec_Int_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] > 0 )
            Counter += p->pArray[i];
    return Counter;
}
# 1411 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntEqual( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    int i;
    if ( p1->nSize != p2->nSize )
        return 0;
    for ( i = 0; i < p1->nSize; i++ )
        if ( p1->pArray[i] != p2->pArray[i] )
            return 0;
    return 1;
}
static inline int Vec_IntContained( Vec_Int_t * pSmall, Vec_Int_t * pLarge )
{
    int i, k;
    for ( i = 0; i < pSmall->nSize; i++ )
    {
        for ( k = 0; k < pLarge->nSize; k++ )
            if ( pSmall->pArray[i] == pLarge->pArray[k] )
                break;
        if ( k == pLarge->nSize )
            return 0;
    }
    return 1;
}
# 1447 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntCountCommon( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    Vec_Int_t * vTemp;
    int Entry, i, Counter = 0;
    if ( Vec_IntSize(p1) < Vec_IntSize(p2) )
        vTemp = p1, p1 = p2, p2 = vTemp;
    
# 1453 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1453 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(p1) >= Vec_IntSize(p2)
# 1453 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1453 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(p1) >= Vec_IntSize(p2)
# 1453 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1453 "/app/abc/src/misc/vec/vecInt.h"
   "Vec_IntSize(p1) >= Vec_IntSize(p2)"
# 1453 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1453, __extension__ __PRETTY_FUNCTION__); }))
# 1453 "/app/abc/src/misc/vec/vecInt.h"
                                               ;
    vTemp = Vec_IntInvert( p2, -1 );
    Vec_IntFillExtra( vTemp, Vec_IntFindMax(p1) + 1, -1 );
    for ( i = 0; (i < Vec_IntSize(p1)) && (((Entry) = Vec_IntEntry(p1, i)), 1); i++ )
        if ( Vec_IntEntry(vTemp, Entry) >= 0 )
            Counter++;
    Vec_IntFree( vTemp );
    return Counter;
}
# 1474 "/app/abc/src/misc/vec/vecInt.h"
static int Vec_IntSortCompare1( int * pp1, int * pp2 )
{

    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 1495 "/app/abc/src/misc/vec/vecInt.h"
static int Vec_IntSortCompare2( int * pp1, int * pp2 )
{

    if ( *pp1 > *pp2 )
        return -1;
    if ( *pp1 < *pp2 )
        return 1;
    return 0;
}
# 1516 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntSort( Vec_Int_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(int),
                (int (*)(const void *, const void *)) Vec_IntSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(int),
                (int (*)(const void *, const void *)) Vec_IntSortCompare1 );
}
static inline void Vec_IntSortMulti( Vec_Int_t * p, int nMulti, int fReverse )
{
    
# 1527 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1527 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(p) % nMulti == 0
# 1527 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1527 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(p) % nMulti == 0
# 1527 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1527 "/app/abc/src/misc/vec/vecInt.h"
   "Vec_IntSize(p) % nMulti == 0"
# 1527 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1527, __extension__ __PRETTY_FUNCTION__); }))
# 1527 "/app/abc/src/misc/vec/vecInt.h"
                                         ;
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)(p->nSize/nMulti), nMulti*sizeof(int),
                (int (*)(const void *, const void *)) Vec_IntSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)(p->nSize/nMulti), nMulti*sizeof(int),
                (int (*)(const void *, const void *)) Vec_IntSortCompare1 );
}
static inline int Vec_IntIsSorted( Vec_Int_t * p, int fReverse )
{
    int i;
    for ( i = 1; i < p->nSize; i++ )
        if ( fReverse ? (p->pArray[i-1] < p->pArray[i]) : (p->pArray[i-1] > p->pArray[i]) )
            return 0;
    return 1;
}
# 1555 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntUniqify( Vec_Int_t * p )
{
    int i, k, RetValue;
    if ( p->nSize < 2 )
        return 0;
    Vec_IntSort( p, 0 );
    for ( i = k = 1; i < p->nSize; i++ )
        if ( p->pArray[i] != p->pArray[i-1] )
            p->pArray[k++] = p->pArray[i];
    RetValue = p->nSize - k;
    p->nSize = k;
    return RetValue;
}
static inline int Vec_IntCountDuplicates( Vec_Int_t * p )
{
    int RetValue;
    Vec_Int_t * pDup = Vec_IntDup( p );
    Vec_IntUniqify( pDup );
    RetValue = Vec_IntSize(p) - Vec_IntSize(pDup);
    Vec_IntFree( pDup );
    return RetValue;
}
static inline int Vec_IntCheckUniqueSmall( Vec_Int_t * p )
{
    int i, k;
    for ( i = 0; i < p->nSize; i++ )
        for ( k = i+1; k < p->nSize; k++ )
            if ( p->pArray[i] == p->pArray[k] )
                return 0;
    return 1;
}
static inline int Vec_IntCountUnique( Vec_Int_t * p )
{
    int i, Count = 0, Max = Vec_IntFindMax(p);
    unsigned char * pPres = ((unsigned char *) calloc((size_t)(Max+1), sizeof(unsigned char)));
    for ( i = 0; i < p->nSize; i++ )
        if ( pPres[p->pArray[i]] == 0 )
            pPres[p->pArray[i]] = 1, Count++;
    ((pPres) ? (free((char *) (pPres)), (pPres) = 0) : 0);
    return Count;
}
# 1608 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntUniqifyPairs( Vec_Int_t * p )
{
    int i, k, RetValue;
    
# 1611 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1611 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize % 2 == 0
# 1611 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1611 "/app/abc/src/misc/vec/vecInt.h"
   p->nSize % 2 == 0
# 1611 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1611 "/app/abc/src/misc/vec/vecInt.h"
   "p->nSize % 2 == 0"
# 1611 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1611, __extension__ __PRETTY_FUNCTION__); }))
# 1611 "/app/abc/src/misc/vec/vecInt.h"
                              ;
    if ( p->nSize < 4 )
        return 0;
    Vec_IntSortMulti( p, 2, 0 );
    for ( i = k = 1; i < p->nSize/2; i++ )
        if ( p->pArray[2*i] != p->pArray[2*(i-1)] || p->pArray[2*i+1] != p->pArray[2*(i-1)+1] )
        {
            p->pArray[2*k] = p->pArray[2*i];
            p->pArray[2*k+1] = p->pArray[2*i+1];
            k++;
        }
    RetValue = p->nSize/2 - k;
    p->nSize = 2*k;
    return RetValue;
}
# 1638 "/app/abc/src/misc/vec/vecInt.h"
static inline unsigned Vec_IntUniqueHashKeyDebug( unsigned char * pStr, int nChars, int TableMask )
{
    static unsigned s_BigPrimes[4] = {12582917, 25165843, 50331653, 100663319};
    unsigned Key = 0; int c;
    for ( c = 0; c < nChars; c++ )
    {
        Key += (unsigned)pStr[c] * s_BigPrimes[c & 3];
        printf( "%d : ", c );
        printf( "%3d  ", pStr[c] );
        printf( "%12u ", Key );
        printf( "%12u ", Key&TableMask );
        printf( "\n" );
    }
    return Key;
}
static inline void Vec_IntUniqueProfile( Vec_Int_t * vData, int * pTable, int * pNexts, int TableMask, int nIntSize )
{
    int i, Key, Counter;
    for ( i = 0; i <= TableMask; i++ )
    {
        Counter = 0;
        for ( Key = pTable[i]; Key != -1; Key = pNexts[Key] )
            Counter++;
        if ( Counter < 7 )
            continue;
        printf( "%d\n", Counter );
        for ( Key = pTable[i]; Key != -1; Key = pNexts[Key] )
        {


        }
    }
    printf( "\n" );
}

static inline unsigned Vec_IntUniqueHashKey2( unsigned char * pStr, int nChars )
{
    static unsigned s_BigPrimes[4] = {12582917, 25165843, 50331653, 100663319};
    unsigned Key = 0; int c;
    for ( c = 0; c < nChars; c++ )
        Key += (unsigned)pStr[c] * s_BigPrimes[c & 3];
    return Key;
}

static inline unsigned Vec_IntUniqueHashKey( unsigned char * pStr, int nChars )
{
    static unsigned s_BigPrimes[16] =
    {
        0x984b6ad9,0x18a6eed3,0x950353e2,0x6222f6eb,0xdfbedd47,0xef0f9023,0xac932a26,0x590eaf55,
        0x97d0a034,0xdc36cd2e,0x22736b37,0xdc9066b0,0x2eb2f98b,0x5d9c7baf,0x85747c9e,0x8aca1055
    };
    static unsigned s_BigPrimes2[16] =
    {
        0x8d8a5ebe,0x1e6a15dc,0x197d49db,0x5bab9c89,0x4b55dea7,0x55dede49,0x9a6a8080,0xe5e51035,
        0xe148d658,0x8a17eb3b,0xe22e4b38,0xe5be2a9a,0xbe938cbb,0x3b981069,0x7f9c0c8e,0xf756df10
    };
    unsigned Key = 0; int c;
    for ( c = 0; c < nChars; c++ )
        Key += s_BigPrimes2[(2*c)&15] * s_BigPrimes[(unsigned)pStr[c] & 15] +
               s_BigPrimes2[(2*c+1)&15] * s_BigPrimes[(unsigned)pStr[c] >> 4];
    return Key;
}
static inline int * Vec_IntUniqueLookup( Vec_Int_t * vData, int i, int nIntSize, int * pNexts, int * pStart )
{
    int * pData = Vec_IntEntryP( vData, i*nIntSize );
    for ( ; *pStart != -1; pStart = pNexts + *pStart )
        if ( !memcmp( pData, Vec_IntEntryP(vData, *pStart*nIntSize), sizeof(int) * (size_t)nIntSize ) )
            return pStart;
    return pStart;
}
static inline int Vec_IntUniqueCount( Vec_Int_t * vData, int nIntSize, Vec_Int_t ** pvMap )
{
    int nEntries = Vec_IntSize(vData) / nIntSize;
    int TableMask = (1 << Abc_Base2Log(nEntries)) - 1;
    int * pTable = ((int *) memset(malloc(sizeof(int) * (size_t)(TableMask+1)), 0xff, sizeof(int) * (size_t)(TableMask+1)));
    int * pNexts = ((int *) memset(malloc(sizeof(int) * (size_t)(TableMask+1)), 0xff, sizeof(int) * (size_t)(TableMask+1)));
    int * pClass = ((int *) malloc(sizeof(int) * (size_t)(nEntries)));
    int i, Key, * pEnt, nUnique = 0;
    
# 1716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1716 "/app/abc/src/misc/vec/vecInt.h"
   nEntries * nIntSize == Vec_IntSize(vData)
# 1716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1716 "/app/abc/src/misc/vec/vecInt.h"
   nEntries * nIntSize == Vec_IntSize(vData)
# 1716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1716 "/app/abc/src/misc/vec/vecInt.h"
   "nEntries * nIntSize == Vec_IntSize(vData)"
# 1716 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1716, __extension__ __PRETTY_FUNCTION__); }))
# 1716 "/app/abc/src/misc/vec/vecInt.h"
                                                      ;
    for ( i = 0; i < nEntries; i++ )
    {
        pEnt = Vec_IntEntryP( vData, i*nIntSize );
        Key = TableMask & Vec_IntUniqueHashKey( (unsigned char *)pEnt, 4*nIntSize );
        pEnt = Vec_IntUniqueLookup( vData, i, nIntSize, pNexts, pTable+Key );
        if ( *pEnt == -1 )
            *pEnt = i, nUnique++;
        pClass[i] = *pEnt;
    }

    ((pTable) ? (free((char *) (pTable)), (pTable) = 0) : 0);
    ((pNexts) ? (free((char *) (pNexts)), (pNexts) = 0) : 0);
    if ( pvMap )
        *pvMap = Vec_IntAllocArray( pClass, nEntries );
    else
        ((pClass) ? (free((char *) (pClass)), (pClass) = 0) : 0);
    return nUnique;
}
static inline Vec_Int_t * Vec_IntUniqifyHash( Vec_Int_t * vData, int nIntSize )
{
    Vec_Int_t * vMap, * vUnique;
    int i, Ent, nUnique = Vec_IntUniqueCount( vData, nIntSize, &vMap );
    vUnique = Vec_IntAlloc( nUnique * nIntSize );
    for ( i = 0; (i < Vec_IntSize(vMap)) && (((Ent) = Vec_IntEntry(vMap, i)), 1); i++ )
    {
        if ( Ent < i ) continue;
        
# 1743 "/app/abc/src/misc/vec/vecInt.h" 3 4
       ((void) sizeof ((
# 1743 "/app/abc/src/misc/vec/vecInt.h"
       Ent == i
# 1743 "/app/abc/src/misc/vec/vecInt.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1743 "/app/abc/src/misc/vec/vecInt.h"
       Ent == i
# 1743 "/app/abc/src/misc/vec/vecInt.h" 3 4
       ) ; else __assert_fail (
# 1743 "/app/abc/src/misc/vec/vecInt.h"
       "Ent == i"
# 1743 "/app/abc/src/misc/vec/vecInt.h" 3 4
       , "/app/abc/src/misc/vec/vecInt.h", 1743, __extension__ __PRETTY_FUNCTION__); }))
# 1743 "/app/abc/src/misc/vec/vecInt.h"
                         ;
        Vec_IntPushArray( vUnique, Vec_IntEntryP(vData, i*nIntSize), nIntSize );
    }
    
# 1746 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1746 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(vUnique) == nUnique * nIntSize
# 1746 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1746 "/app/abc/src/misc/vec/vecInt.h"
   Vec_IntSize(vUnique) == nUnique * nIntSize
# 1746 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1746 "/app/abc/src/misc/vec/vecInt.h"
   "Vec_IntSize(vUnique) == nUnique * nIntSize"
# 1746 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1746, __extension__ __PRETTY_FUNCTION__); }))
# 1746 "/app/abc/src/misc/vec/vecInt.h"
                                                       ;
    Vec_IntFree( vMap );
    return vUnique;
}
# 1762 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntSortCompareUnsigned( unsigned * pp1, unsigned * pp2 )
{
    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 1782 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntSortUnsigned( Vec_Int_t * p )
{
    qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(int),
            (int (*)(const void *, const void *)) Vec_IntSortCompareUnsigned );
}
# 1799 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntTwoCountCommon( Vec_Int_t * vArr1, Vec_Int_t * vArr2 )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    int Counter = 0;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            pBeg1++, pBeg2++, Counter++;
        else if ( *pBeg1 < *pBeg2 )
            pBeg1++;
        else
            pBeg2++;
    }
    return Counter;
}
# 1829 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntTwoFindCommon( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    Vec_IntClear( vArr );
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            Vec_IntPush( vArr, *pBeg1 ), pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            pBeg1++;
        else
            pBeg2++;
    }
    return Vec_IntSize(vArr);
}
static inline int Vec_IntTwoFindCommonReverse( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    Vec_IntClear( vArr );
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            Vec_IntPush( vArr, *pBeg1 ), pBeg1++, pBeg2++;
        else if ( *pBeg1 > *pBeg2 )
            pBeg1++;
        else
            pBeg2++;
    }
    return Vec_IntSize(vArr);
}
# 1877 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntTwoRemoveCommon( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    int * pBeg1New = vArr1->pArray;
    int * pBeg2New = vArr2->pArray;
    Vec_IntClear( vArr );
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            Vec_IntPush( vArr, *pBeg1 ), pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            *pBeg1New++ = *pBeg1++;
        else
            *pBeg2New++ = *pBeg2++;
    }
    while ( pBeg1 < pEnd1 )
        *pBeg1New++ = *pBeg1++;
    while ( pBeg2 < pEnd2 )
        *pBeg2New++ = *pBeg2++;
    Vec_IntShrink( vArr1, pBeg1New - vArr1->pArray );
    Vec_IntShrink( vArr2, pBeg2New - vArr2->pArray );
    return Vec_IntSize(vArr);
}
# 1915 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntTwoRemove( Vec_Int_t * vArr1, Vec_Int_t * vArr2 )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    int * pBeg1New = vArr1->pArray;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            *pBeg1New++ = *pBeg1++;
        else
            pBeg2++;
    }
    while ( pBeg1 < pEnd1 )
        *pBeg1New++ = *pBeg1++;
    Vec_IntShrink( vArr1, pBeg1New - vArr1->pArray );
    return Vec_IntSize(vArr1);
}
# 1948 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntTwoMerge1( Vec_Int_t * vArr1, Vec_Int_t * vArr2 )
{
    int * pBeg = vArr1->pArray;
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            *pBeg++ = *pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            pBeg1++;
        else
            pBeg2++;
    }
    
# 1964 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1964 "/app/abc/src/misc/vec/vecInt.h"
   vArr1->nSize >= pBeg - vArr1->pArray
# 1964 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1964 "/app/abc/src/misc/vec/vecInt.h"
   vArr1->nSize >= pBeg - vArr1->pArray
# 1964 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1964 "/app/abc/src/misc/vec/vecInt.h"
   "vArr1->nSize >= pBeg - vArr1->pArray"
# 1964 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1964, __extension__ __PRETTY_FUNCTION__); }))
# 1964 "/app/abc/src/misc/vec/vecInt.h"
                                                 ;
    vArr1->nSize = pBeg - vArr1->pArray;
}
# 1979 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntTwoRemove1( Vec_Int_t * vArr1, Vec_Int_t * vArr2 )
{
    int * pBeg = vArr1->pArray;
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            *pBeg++ = *pBeg1++;
        else
            pBeg2++;
    }
    while ( pBeg1 < pEnd1 )
        *pBeg++ = *pBeg1++;
    
# 1997 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 1997 "/app/abc/src/misc/vec/vecInt.h"
   vArr1->nSize >= pBeg - vArr1->pArray
# 1997 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1997 "/app/abc/src/misc/vec/vecInt.h"
   vArr1->nSize >= pBeg - vArr1->pArray
# 1997 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 1997 "/app/abc/src/misc/vec/vecInt.h"
   "vArr1->nSize >= pBeg - vArr1->pArray"
# 1997 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 1997, __extension__ __PRETTY_FUNCTION__); }))
# 1997 "/app/abc/src/misc/vec/vecInt.h"
                                                 ;
    vArr1->nSize = pBeg - vArr1->pArray;
}
# 2012 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntTwoMerge2Int( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr )
{
    int * pBeg = vArr->pArray;
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            *pBeg++ = *pBeg1++, pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            *pBeg++ = *pBeg1++;
        else
            *pBeg++ = *pBeg2++;
    }
    while ( pBeg1 < pEnd1 )
        *pBeg++ = *pBeg1++;
    while ( pBeg2 < pEnd2 )
        *pBeg++ = *pBeg2++;
    vArr->nSize = pBeg - vArr->pArray;
    
# 2033 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 2033 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize <= vArr->nCap
# 2033 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2033 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize <= vArr->nCap
# 2033 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 2033 "/app/abc/src/misc/vec/vecInt.h"
   "vArr->nSize <= vArr->nCap"
# 2033 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 2033, __extension__ __PRETTY_FUNCTION__); }))
# 2033 "/app/abc/src/misc/vec/vecInt.h"
                                      ;
    
# 2034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 2034 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize >= vArr1->nSize
# 2034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2034 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize >= vArr1->nSize
# 2034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 2034 "/app/abc/src/misc/vec/vecInt.h"
   "vArr->nSize >= vArr1->nSize"
# 2034 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 2034, __extension__ __PRETTY_FUNCTION__); }))
# 2034 "/app/abc/src/misc/vec/vecInt.h"
                                        ;
    
# 2035 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ((void) sizeof ((
# 2035 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize >= vArr2->nSize
# 2035 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2035 "/app/abc/src/misc/vec/vecInt.h"
   vArr->nSize >= vArr2->nSize
# 2035 "/app/abc/src/misc/vec/vecInt.h" 3 4
   ) ; else __assert_fail (
# 2035 "/app/abc/src/misc/vec/vecInt.h"
   "vArr->nSize >= vArr2->nSize"
# 2035 "/app/abc/src/misc/vec/vecInt.h" 3 4
   , "/app/abc/src/misc/vec/vecInt.h", 2035, __extension__ __PRETTY_FUNCTION__); }))
# 2035 "/app/abc/src/misc/vec/vecInt.h"
                                        ;
}
static inline Vec_Int_t * Vec_IntTwoMerge( Vec_Int_t * vArr1, Vec_Int_t * vArr2 )
{
    Vec_Int_t * vArr = Vec_IntAlloc( vArr1->nSize + vArr2->nSize );
    Vec_IntTwoMerge2Int( vArr1, vArr2, vArr );
    return vArr;
}
static inline void Vec_IntTwoMerge2( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr )
{
    Vec_IntGrow( vArr, Vec_IntSize(vArr1) + Vec_IntSize(vArr2) );
    Vec_IntTwoMerge2Int( vArr1, vArr2, vArr );
}
# 2060 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntTwoSplit( Vec_Int_t * vArr1, Vec_Int_t * vArr2, Vec_Int_t * vArr, Vec_Int_t * vArr1n, Vec_Int_t * vArr2n )
{
    int * pBeg1 = vArr1->pArray;
    int * pBeg2 = vArr2->pArray;
    int * pEnd1 = vArr1->pArray + vArr1->nSize;
    int * pEnd2 = vArr2->pArray + vArr2->nSize;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            Vec_IntPush( vArr, *pBeg1++ ), pBeg2++;
        else if ( *pBeg1 < *pBeg2 )
            Vec_IntPush( vArr1n, *pBeg1++ );
        else
            Vec_IntPush( vArr2n, *pBeg2++ );
    }
    while ( pBeg1 < pEnd1 )
        Vec_IntPush( vArr1n, *pBeg1++ );
    while ( pBeg2 < pEnd2 )
        Vec_IntPush( vArr2n, *pBeg2++ );
}
# 2093 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntSelectSort( int * pArray, int nSize )
{
    int temp, i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( pArray[j] < pArray[best_i] )
                best_i = j;
        temp = pArray[i];
        pArray[i] = pArray[best_i];
        pArray[best_i] = temp;
    }
}
static inline void Vec_IntSelectSortReverse( int * pArray, int nSize )
{
    int temp, i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( pArray[j] > pArray[best_i] )
                best_i = j;
        temp = pArray[i];
        pArray[i] = pArray[best_i];
        pArray[best_i] = temp;
    }
}
# 2133 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntSelectSortCost( int * pArray, int nSize, Vec_Int_t * vCosts )
{
    int i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( Vec_IntEntry(vCosts, pArray[j]) < Vec_IntEntry(vCosts, pArray[best_i]) )
                best_i = j;
        { int t = pArray[i]; pArray[i] = pArray[best_i]; pArray[best_i] = t; };
    }
}
static inline void Vec_IntSelectSortCostReverse( int * pArray, int nSize, Vec_Int_t * vCosts )
{
    int i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( Vec_IntEntry(vCosts, pArray[j]) > Vec_IntEntry(vCosts, pArray[best_i]) )
                best_i = j;
        { int t = pArray[i]; pArray[i] = pArray[best_i]; pArray[best_i] = t; };
    }
}

static inline void Vec_IntSelectSortCost2( int * pArray, int nSize, int * pCosts )
{
    int i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( pCosts[j] < pCosts[best_i] )
                best_i = j;
        { int t = pArray[i]; pArray[i] = pArray[best_i]; pArray[best_i] = t; };
        { int t = pCosts[i]; pCosts[i] = pCosts[best_i]; pCosts[best_i] = t; };
    }
}
static inline void Vec_IntSelectSortCost2Reverse( int * pArray, int nSize, int * pCosts )
{
    int i, j, best_i;
    for ( i = 0; i < nSize-1; i++ )
    {
        best_i = i;
        for ( j = i+1; j < nSize; j++ )
            if ( pCosts[j] > pCosts[best_i] )
                best_i = j;
        { int t = pArray[i]; pArray[i] = pArray[best_i]; pArray[best_i] = t; };
        { int t = pCosts[i]; pCosts[i] = pCosts[best_i]; pCosts[best_i] = t; };
    }
}
# 2196 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntPrint( Vec_Int_t * vVec )
{
    int i, Entry;
    printf( "Vector has %d entries: {", Vec_IntSize(vVec) );
    for ( i = 0; (i < Vec_IntSize(vVec)) && (((Entry) = Vec_IntEntry(vVec, i)), 1); i++ )
        printf( " %d", Entry );
    printf( " }\n" );
}
static inline void Vec_IntPrintBinary( Vec_Int_t * vVec )
{
    int i, Entry;
    for ( i = 0; (i < Vec_IntSize(vVec)) && (((Entry) = Vec_IntEntry(vVec, i)), 1); i++ )
        printf( "%d", (int)(Entry != 0) );
}
# 2222 "/app/abc/src/misc/vec/vecInt.h"
static inline int Vec_IntCompareVec( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( p1 == 
# 2224 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0) 
# 2224 "/app/abc/src/misc/vec/vecInt.h"
                   || p2 == 
# 2224 "/app/abc/src/misc/vec/vecInt.h" 3 4
                            ((void *)0) 
# 2224 "/app/abc/src/misc/vec/vecInt.h"
                                 )
        return (p1 != 
# 2225 "/app/abc/src/misc/vec/vecInt.h" 3 4
                     ((void *)0)
# 2225 "/app/abc/src/misc/vec/vecInt.h"
                         ) - (p2 != 
# 2225 "/app/abc/src/misc/vec/vecInt.h" 3 4
                                    ((void *)0)
# 2225 "/app/abc/src/misc/vec/vecInt.h"
                                        );
    if ( Vec_IntSize(p1) != Vec_IntSize(p2) )
        return Vec_IntSize(p1) - Vec_IntSize(p2);
    return memcmp( Vec_IntArray(p1), Vec_IntArray(p2), sizeof(int)*(size_t)Vec_IntSize(p1) );
}
# 2242 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntClearAppend( Vec_Int_t * vVec1, Vec_Int_t * vVec2 )
{
    int Entry, i;
    Vec_IntClear( vVec1 );
    for ( i = 0; (i < Vec_IntSize(vVec2)) && (((Entry) = Vec_IntEntry(vVec2, i)), 1); i++ )
        Vec_IntPush( vVec1, Entry );
}
static inline void Vec_IntAppend( Vec_Int_t * vVec1, Vec_Int_t * vVec2 )
{
    int Entry, i;
    for ( i = 0; (i < Vec_IntSize(vVec2)) && (((Entry) = Vec_IntEntry(vVec2, i)), 1); i++ )
        Vec_IntPush( vVec1, Entry );
}
static inline void Vec_IntAppendSkip( Vec_Int_t * vVec1, Vec_Int_t * vVec2, int iVar )
{
    int Entry, i;
    for ( i = 0; (i < Vec_IntSize(vVec2)) && (((Entry) = Vec_IntEntry(vVec2, i)), 1); i++ )
        if ( i != iVar )
            Vec_IntPush( vVec1, Entry );
}
static inline void Vec_IntAppendMinus( Vec_Int_t * vVec1, Vec_Int_t * vVec2, int fMinus )
{
    int Entry, i;
    Vec_IntClear( vVec1 );
    for ( i = 0; (i < Vec_IntSize(vVec2)) && (((Entry) = Vec_IntEntry(vVec2, i)), 1); i++ )
        Vec_IntPush( vVec1, fMinus ? -Entry : Entry );
}
# 2281 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntRemapArray( Vec_Int_t * vOld2New, Vec_Int_t * vOld, Vec_Int_t * vNew, int nNew )
{
    int iOld, iNew;
    if ( Vec_IntSize(vOld) == 0 )
        return;
    Vec_IntFill( vNew, nNew, 0 );
    for ( iOld = 0; (iOld < Vec_IntSize(vOld2New)) && (((iNew) = Vec_IntEntry(vOld2New, iOld)), 1); iOld++ )
        if ( iNew > 0 && iNew < nNew && iOld < Vec_IntSize(vOld) && Vec_IntEntry(vOld, iOld) != 0 )
            Vec_IntWriteEntry( vNew, iNew, Vec_IntEntry(vOld, iOld) );
}
# 2303 "/app/abc/src/misc/vec/vecInt.h"
static inline void Vec_IntDumpBin( char * pFileName, Vec_Int_t * p, int fVerbose )
{
    int RetValue;
    FILE * pFile = fopen( pFileName, "wb" );
    if ( pFile == 
# 2307 "/app/abc/src/misc/vec/vecInt.h" 3 4
                 ((void *)0) 
# 2307 "/app/abc/src/misc/vec/vecInt.h"
                      )
    {
        printf( "Cannot open file \"%s\" for writing.\n", pFileName );
        return;
    }
    RetValue = fwrite( Vec_IntArray(p), 1, sizeof(int)*Vec_IntSize(p), pFile );
    fclose( pFile );
    if ( RetValue != (int)sizeof(int)*Vec_IntSize(p) )
        printf( "Error reading data from file.\n" );
    if ( fVerbose )
        printf( "Written %d integers into file \"%s\".\n", Vec_IntSize(p), pFileName );
}
static inline Vec_Int_t * Vec_IntReadBin( char * pFileName, int fVerbose )
{
    Vec_Int_t * p = 
# 2321 "/app/abc/src/misc/vec/vecInt.h" 3 4
                   ((void *)0)
# 2321 "/app/abc/src/misc/vec/vecInt.h"
                       ; int nSize, RetValue;
    FILE * pFile = fopen( pFileName, "rb" );
    if ( pFile == 
# 2323 "/app/abc/src/misc/vec/vecInt.h" 3 4
                 ((void *)0) 
# 2323 "/app/abc/src/misc/vec/vecInt.h"
                      )
    {
        printf( "Cannot open file \"%s\" for reading.\n", pFileName );
        return 
# 2326 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0)
# 2326 "/app/abc/src/misc/vec/vecInt.h"
                  ;
    }
    fseek( pFile, 0, 
# 2328 "/app/abc/src/misc/vec/vecInt.h" 3 4
                    2 
# 2328 "/app/abc/src/misc/vec/vecInt.h"
                             );
    nSize = ftell( pFile );
    if ( nSize == 0 )
    {
        printf( "The input file is empty.\n" );
        fclose( pFile );
        return 
# 2334 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0)
# 2334 "/app/abc/src/misc/vec/vecInt.h"
                  ;
    }
    if ( nSize % sizeof(int) > 0 )
    {
        printf( "Cannot read file with integers because it is not aligned at 4 bytes (remainder = %d).\n", (int)(nSize % sizeof(int)) );
        fclose( pFile );
        return 
# 2340 "/app/abc/src/misc/vec/vecInt.h" 3 4
              ((void *)0)
# 2340 "/app/abc/src/misc/vec/vecInt.h"
                  ;
    }
    rewind( pFile );
    p = Vec_IntStart( (int)(nSize/sizeof(int)) );
    RetValue = fread( Vec_IntArray(p), 1, nSize, pFile );
    fclose( pFile );
    if ( RetValue != nSize )
        printf( "Error reading data from file.\n" );
    if ( fVerbose )
        printf( "Read %d integers from file \"%s\".\n", (int)(nSize/sizeof(int)), pFileName );
    return p;
}


# 32 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecFlt.h" 1
# 31 "/app/abc/src/misc/vec/vecFlt.h"

# 42 "/app/abc/src/misc/vec/vecFlt.h"
typedef struct Vec_Flt_t_ Vec_Flt_t;
struct Vec_Flt_t_
{
    int nCap;
    int nSize;
    float * pArray;
};
# 78 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltAlloc( int nCap )
{
    Vec_Flt_t * p;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 16 )
        nCap = 16;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((float *) malloc(sizeof(float) * (size_t)(p->nCap))) : 
# 86 "/app/abc/src/misc/vec/vecFlt.h" 3 4
                                                      ((void *)0)
# 86 "/app/abc/src/misc/vec/vecFlt.h"
                                                          ;
    return p;
}
static inline Vec_Flt_t * Vec_FltAllocExact( int nCap )
{
    Vec_Flt_t * p;
    
# 92 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 92 "/app/abc/src/misc/vec/vecFlt.h"
   nCap >= 0
# 92 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 92 "/app/abc/src/misc/vec/vecFlt.h"
   nCap >= 0
# 92 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 92 "/app/abc/src/misc/vec/vecFlt.h"
   "nCap >= 0"
# 92 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 92, __extension__ __PRETTY_FUNCTION__); }))
# 92 "/app/abc/src/misc/vec/vecFlt.h"
                      ;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((float *) malloc(sizeof(float) * (size_t)(p->nCap))) : 
# 96 "/app/abc/src/misc/vec/vecFlt.h" 3 4
                                                      ((void *)0)
# 96 "/app/abc/src/misc/vec/vecFlt.h"
                                                          ;
    return p;
}
# 111 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltStart( int nSize )
{
    Vec_Flt_t * p;
    p = Vec_FltAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0, sizeof(float) * (size_t)nSize );
    return p;
}
static inline Vec_Flt_t * Vec_FltStartFull( int nSize )
{
    Vec_Flt_t * p;
    p = Vec_FltAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0xFF, sizeof(float) * (size_t)nSize );
    return p;
}
# 139 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltAllocArray( float * pArray, int nSize )
{
    Vec_Flt_t * p;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = pArray;
    return p;
}
# 160 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltAllocArrayCopy( float * pArray, int nSize )
{
    Vec_Flt_t * p;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = ((float *) malloc(sizeof(float) * (size_t)(nSize)));
    memcpy( p->pArray, pArray, sizeof(float) * (size_t)nSize );
    return p;
}
# 182 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltDup( Vec_Flt_t * pVec )
{
    Vec_Flt_t * p;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = p->nCap? ((float *) malloc(sizeof(float) * (size_t)(p->nCap))) : 
# 188 "/app/abc/src/misc/vec/vecFlt.h" 3 4
                                                      ((void *)0)
# 188 "/app/abc/src/misc/vec/vecFlt.h"
                                                          ;
    memcpy( p->pArray, pVec->pArray, sizeof(float) * (size_t)pVec->nSize );
    return p;
}
# 204 "/app/abc/src/misc/vec/vecFlt.h"
static inline Vec_Flt_t * Vec_FltDupArray( Vec_Flt_t * pVec )
{
    Vec_Flt_t * p;
    p = ((Vec_Flt_t *) malloc(sizeof(Vec_Flt_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = pVec->pArray;
    pVec->nSize = 0;
    pVec->nCap = 0;
    pVec->pArray = 
# 213 "/app/abc/src/misc/vec/vecFlt.h" 3 4
                  ((void *)0)
# 213 "/app/abc/src/misc/vec/vecFlt.h"
                      ;
    return p;
}
# 228 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltZero( Vec_Flt_t * p )
{
    p->pArray = 
# 230 "/app/abc/src/misc/vec/vecFlt.h" 3 4
               ((void *)0)
# 230 "/app/abc/src/misc/vec/vecFlt.h"
                   ;
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_FltErase( Vec_Flt_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_FltFree( Vec_Flt_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 257 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltFreeP( Vec_Flt_t ** p )
{
    if ( *p == 
# 259 "/app/abc/src/misc/vec/vecFlt.h" 3 4
              ((void *)0) 
# 259 "/app/abc/src/misc/vec/vecFlt.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 276 "/app/abc/src/misc/vec/vecFlt.h"
static inline float * Vec_FltReleaseArray( Vec_Flt_t * p )
{
    float * pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 281 "/app/abc/src/misc/vec/vecFlt.h" 3 4
               ((void *)0)
# 281 "/app/abc/src/misc/vec/vecFlt.h"
                   ;
    return pArray;
}
# 296 "/app/abc/src/misc/vec/vecFlt.h"
static inline float * Vec_FltArray( Vec_Flt_t * p )
{
    return p->pArray;
}
static inline float ** Vec_FltArrayP( Vec_Flt_t * p )
{
    return &p->pArray;
}
# 316 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltSize( Vec_Flt_t * p )
{
    return p->nSize;
}
# 332 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltCap( Vec_Flt_t * p )
{
    return p->nCap;
}
# 348 "/app/abc/src/misc/vec/vecFlt.h"
static inline double Vec_FltMemory( Vec_Flt_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(float) * (size_t)p->nCap + sizeof(Vec_Flt_t);
}
# 364 "/app/abc/src/misc/vec/vecFlt.h"
static inline float Vec_FltEntry( Vec_Flt_t * p, int i )
{
    
# 366 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 366 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 366 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 366 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 366 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 366 "/app/abc/src/misc/vec/vecFlt.h"
   "i >= 0 && i < p->nSize"
# 366 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 366, __extension__ __PRETTY_FUNCTION__); }))
# 366 "/app/abc/src/misc/vec/vecFlt.h"
                                   ;
    return p->pArray[i];
}
static inline float * Vec_FltEntryP( Vec_Flt_t * p, int i )
{
    
# 371 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 371 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 371 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 371 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 371 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 371 "/app/abc/src/misc/vec/vecFlt.h"
   "i >= 0 && i < p->nSize"
# 371 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 371, __extension__ __PRETTY_FUNCTION__); }))
# 371 "/app/abc/src/misc/vec/vecFlt.h"
                                   ;
    return p->pArray + i;
}
# 386 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltWriteEntry( Vec_Flt_t * p, int i, float Entry )
{
    
# 388 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 388 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 388 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 388 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 388 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 388 "/app/abc/src/misc/vec/vecFlt.h"
   "i >= 0 && i < p->nSize"
# 388 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 388, __extension__ __PRETTY_FUNCTION__); }))
# 388 "/app/abc/src/misc/vec/vecFlt.h"
                                   ;
    p->pArray[i] = Entry;
}
# 403 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltAddToEntry( Vec_Flt_t * p, int i, float Addition )
{
    
# 405 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 405 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 405 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 405 "/app/abc/src/misc/vec/vecFlt.h"
   i >= 0 && i < p->nSize
# 405 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 405 "/app/abc/src/misc/vec/vecFlt.h"
   "i >= 0 && i < p->nSize"
# 405 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 405, __extension__ __PRETTY_FUNCTION__); }))
# 405 "/app/abc/src/misc/vec/vecFlt.h"
                                   ;
    p->pArray[i] += Addition;
}
# 420 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltUpdateEntry( Vec_Flt_t * p, int i, float Value )
{
    if ( Vec_FltEntry( p, i ) < Value )
        Vec_FltWriteEntry( p, i, Value );
}
# 437 "/app/abc/src/misc/vec/vecFlt.h"
static inline float Vec_FltEntryLast( Vec_Flt_t * p )
{
    return p->pArray[p->nSize-1];
}
# 453 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltGrow( Vec_Flt_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((float *) realloc((char *)(p->pArray), sizeof(float) * (size_t)(nCapMin))) : ((float *) malloc(sizeof(float) * (size_t)(nCapMin))));
    p->nCap = nCapMin;
}
# 472 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltFill( Vec_Flt_t * p, int nSize, float Entry )
{
    int i;
    Vec_FltGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = Entry;
    p->nSize = nSize;
}
# 492 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltFillExtra( Vec_Flt_t * p, int nSize, float Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_FltGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_FltGrow( p, 2 * p->nCap );
    for ( i = p->nSize; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 517 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltShrink( Vec_Flt_t * p, int nSizeNew )
{
    
# 519 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 519 "/app/abc/src/misc/vec/vecFlt.h"
   p->nSize >= nSizeNew
# 519 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 519 "/app/abc/src/misc/vec/vecFlt.h"
   p->nSize >= nSizeNew
# 519 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 519 "/app/abc/src/misc/vec/vecFlt.h"
   "p->nSize >= nSizeNew"
# 519 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 519, __extension__ __PRETTY_FUNCTION__); }))
# 519 "/app/abc/src/misc/vec/vecFlt.h"
                                 ;
    p->nSize = nSizeNew;
}
# 534 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltClear( Vec_Flt_t * p )
{
    p->nSize = 0;
}
# 550 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltPush( Vec_Flt_t * p, float Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_FltGrow( p, 16 );
        else
            Vec_FltGrow( p, 2 * p->nCap );
    }
    p->pArray[p->nSize++] = Entry;
}
# 573 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltPushOrder( Vec_Flt_t * p, float Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_FltGrow( p, 16 );
        else
            Vec_FltGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize-2; i >= 0; i-- )
        if ( p->pArray[i] > Entry )
            p->pArray[i+1] = p->pArray[i];
        else
            break;
    p->pArray[i+1] = Entry;
}
# 603 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltPushUnique( Vec_Flt_t * p, float Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_FltPush( p, Entry );
    return 0;
}
# 624 "/app/abc/src/misc/vec/vecFlt.h"
static inline float Vec_FltPop( Vec_Flt_t * p )
{
    
# 626 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 626 "/app/abc/src/misc/vec/vecFlt.h"
   p->nSize > 0
# 626 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 626 "/app/abc/src/misc/vec/vecFlt.h"
   p->nSize > 0
# 626 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 626 "/app/abc/src/misc/vec/vecFlt.h"
   "p->nSize > 0"
# 626 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 626, __extension__ __PRETTY_FUNCTION__); }))
# 626 "/app/abc/src/misc/vec/vecFlt.h"
                         ;
    return p->pArray[--p->nSize];
}
# 641 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltFind( Vec_Flt_t * p, float Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return i;
    return -1;
}
# 661 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltRemove( Vec_Flt_t * p, float Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            break;
    if ( i == p->nSize )
        return 0;
    
# 669 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ((void) sizeof ((
# 669 "/app/abc/src/misc/vec/vecFlt.h"
   i < p->nSize
# 669 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 669 "/app/abc/src/misc/vec/vecFlt.h"
   i < p->nSize
# 669 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   ) ; else __assert_fail (
# 669 "/app/abc/src/misc/vec/vecFlt.h"
   "i < p->nSize"
# 669 "/app/abc/src/misc/vec/vecFlt.h" 3 4
   , "/app/abc/src/misc/vec/vecFlt.h", 669, __extension__ __PRETTY_FUNCTION__); }))
# 669 "/app/abc/src/misc/vec/vecFlt.h"
                         ;
    for ( i++; i < p->nSize; i++ )
        p->pArray[i-1] = p->pArray[i];
    p->nSize--;
    return 1;
}
# 687 "/app/abc/src/misc/vec/vecFlt.h"
static inline float Vec_FltFindMax( Vec_Flt_t * p )
{
    int i;
    float Best;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best < p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
static inline float Vec_FltFindMin( Vec_Flt_t * p )
{
    int i;
    float Best;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best > p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
# 723 "/app/abc/src/misc/vec/vecFlt.h"
static inline int Vec_FltEqual( Vec_Flt_t * p1, Vec_Flt_t * p2 )
{
    int i;
    if ( p1->nSize != p2->nSize )
        return 0;
    for ( i = 0; i < p1->nSize; i++ )
        if ( p1->pArray[i] != p2->pArray[i] )
            return 0;
    return 1;
}
# 745 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltPrint( Vec_Flt_t * vVec )
{
    int i; float Entry;
    printf( "Vector has %d entries: {", Vec_FltSize(vVec) );
    for ( i = 0; (i < Vec_FltSize(vVec)) && (((Entry) = Vec_FltEntry(vVec, i)), 1); i++ )
        printf( " %f", Entry );
    printf( " }\n" );
}
# 765 "/app/abc/src/misc/vec/vecFlt.h"
static int Vec_FltSortCompare1( float * pp1, float * pp2 )
{

    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 786 "/app/abc/src/misc/vec/vecFlt.h"
static int Vec_FltSortCompare2( float * pp1, float * pp2 )
{

    if ( *pp1 > *pp2 )
        return -1;
    if ( *pp1 < *pp2 )
        return 1;
    return 0;
}
# 807 "/app/abc/src/misc/vec/vecFlt.h"
static inline void Vec_FltSort( Vec_Flt_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(float),
                (int (*)(const void *, const void *)) Vec_FltSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(float),
                (int (*)(const void *, const void *)) Vec_FltSortCompare1 );
}








# 33 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecStr.h" 1
# 31 "/app/abc/src/misc/vec/vecStr.h"

# 42 "/app/abc/src/misc/vec/vecStr.h"
typedef struct Vec_Str_t_ Vec_Str_t;
struct Vec_Str_t_
{
    int nCap;
    int nSize;
    char * pArray;
};
# 72 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrAlloc( int nCap )
{
    Vec_Str_t * p;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 16 )
        nCap = 16;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((char *) malloc(sizeof(char) * (size_t)(p->nCap))) : 
# 80 "/app/abc/src/misc/vec/vecStr.h" 3 4
                                                     ((void *)0)
# 80 "/app/abc/src/misc/vec/vecStr.h"
                                                         ;
    return p;
}
static inline Vec_Str_t * Vec_StrAllocExact( int nCap )
{
    Vec_Str_t * p;
    
# 86 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 86 "/app/abc/src/misc/vec/vecStr.h"
   nCap >= 0
# 86 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 86 "/app/abc/src/misc/vec/vecStr.h"
   nCap >= 0
# 86 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 86 "/app/abc/src/misc/vec/vecStr.h"
   "nCap >= 0"
# 86 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 86, __extension__ __PRETTY_FUNCTION__); }))
# 86 "/app/abc/src/misc/vec/vecStr.h"
                      ;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((char *) malloc(sizeof(char) * (size_t)(p->nCap))) : 
# 90 "/app/abc/src/misc/vec/vecStr.h" 3 4
                                                     ((void *)0)
# 90 "/app/abc/src/misc/vec/vecStr.h"
                                                         ;
    return p;
}
# 105 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrStart( int nSize )
{
    Vec_Str_t * p;
    p = Vec_StrAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0, sizeof(char) * (size_t)nSize );
    return p;
}
# 125 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrAllocArray( char * pArray, int nSize )
{
    Vec_Str_t * p;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = pArray;
    return p;
}
# 146 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrAllocArrayCopy( char * pArray, int nSize )
{
    Vec_Str_t * p;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = ((char *) malloc(sizeof(char) * (size_t)(nSize)));
    memcpy( p->pArray, pArray, sizeof(char) * (size_t)nSize );
    return p;
}
# 168 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrDup( Vec_Str_t * pVec )
{
    Vec_Str_t * p;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = p->nCap? ((char *) malloc(sizeof(char) * (size_t)(p->nCap))) : 
# 174 "/app/abc/src/misc/vec/vecStr.h" 3 4
                                                     ((void *)0)
# 174 "/app/abc/src/misc/vec/vecStr.h"
                                                         ;
    memcpy( p->pArray, pVec->pArray, sizeof(char) * (size_t)pVec->nSize );
    return p;
}
# 190 "/app/abc/src/misc/vec/vecStr.h"
static inline Vec_Str_t * Vec_StrDupArray( Vec_Str_t * pVec )
{
    Vec_Str_t * p;
    p = ((Vec_Str_t *) malloc(sizeof(Vec_Str_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = pVec->pArray;
    pVec->nSize = 0;
    pVec->nCap = 0;
    pVec->pArray = 
# 199 "/app/abc/src/misc/vec/vecStr.h" 3 4
                  ((void *)0)
# 199 "/app/abc/src/misc/vec/vecStr.h"
                      ;
    return p;
}
# 214 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrZero( Vec_Str_t * p )
{
    p->pArray = 
# 216 "/app/abc/src/misc/vec/vecStr.h" 3 4
               ((void *)0)
# 216 "/app/abc/src/misc/vec/vecStr.h"
                   ;
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_StrErase( Vec_Str_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_StrFree( Vec_Str_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 243 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrFreeP( Vec_Str_t ** p )
{
    if ( *p == 
# 245 "/app/abc/src/misc/vec/vecStr.h" 3 4
              ((void *)0) 
# 245 "/app/abc/src/misc/vec/vecStr.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 262 "/app/abc/src/misc/vec/vecStr.h"
static inline char * Vec_StrReleaseArray( Vec_Str_t * p )
{
    char * pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 267 "/app/abc/src/misc/vec/vecStr.h" 3 4
               ((void *)0)
# 267 "/app/abc/src/misc/vec/vecStr.h"
                   ;
    return pArray;
}
# 282 "/app/abc/src/misc/vec/vecStr.h"
static inline char * Vec_StrArray( Vec_Str_t * p )
{
    return p->pArray;
}
static inline char * Vec_StrLimit( Vec_Str_t * p )
{
    return p->pArray + p->nSize;
}
# 302 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrSize( Vec_Str_t * p )
{
    return p->nSize;
}
static inline void Vec_StrSetSize( Vec_Str_t * p, int nSize )
{
    p->nSize = nSize;
}
# 322 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrCap( Vec_Str_t * p )
{
    return p->nCap;
}
# 338 "/app/abc/src/misc/vec/vecStr.h"
static inline double Vec_StrMemory( Vec_Str_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(char) * (size_t)p->nCap + sizeof(Vec_Str_t);
}
# 354 "/app/abc/src/misc/vec/vecStr.h"
static inline char Vec_StrEntry( Vec_Str_t * p, int i )
{
    
# 356 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 356 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 356 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 356 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 356 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 356 "/app/abc/src/misc/vec/vecStr.h"
   "i >= 0 && i < p->nSize"
# 356 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 356, __extension__ __PRETTY_FUNCTION__); }))
# 356 "/app/abc/src/misc/vec/vecStr.h"
                                   ;
    return p->pArray[i];
}
# 371 "/app/abc/src/misc/vec/vecStr.h"
static inline char * Vec_StrEntryP( Vec_Str_t * p, int i )
{
    
# 373 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 373 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 373 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 373 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 373 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 373 "/app/abc/src/misc/vec/vecStr.h"
   "i >= 0 && i < p->nSize"
# 373 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 373, __extension__ __PRETTY_FUNCTION__); }))
# 373 "/app/abc/src/misc/vec/vecStr.h"
                                   ;
    return p->pArray + i;
}
# 388 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrWriteEntry( Vec_Str_t * p, int i, char Entry )
{
    
# 390 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 390 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 390 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 390 "/app/abc/src/misc/vec/vecStr.h"
   i >= 0 && i < p->nSize
# 390 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 390 "/app/abc/src/misc/vec/vecStr.h"
   "i >= 0 && i < p->nSize"
# 390 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 390, __extension__ __PRETTY_FUNCTION__); }))
# 390 "/app/abc/src/misc/vec/vecStr.h"
                                   ;
    p->pArray[i] = Entry;
}
# 405 "/app/abc/src/misc/vec/vecStr.h"
static inline char Vec_StrEntryLast( Vec_Str_t * p )
{
    
# 407 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 407 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize > 0
# 407 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 407 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize > 0
# 407 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 407 "/app/abc/src/misc/vec/vecStr.h"
   "p->nSize > 0"
# 407 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 407, __extension__ __PRETTY_FUNCTION__); }))
# 407 "/app/abc/src/misc/vec/vecStr.h"
                         ;
    return p->pArray[p->nSize-1];
}
# 422 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrGrow( Vec_Str_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((char *) realloc((char *)(p->pArray), sizeof(char) * (size_t)(nCapMin))) : ((char *) malloc(sizeof(char) * (size_t)(nCapMin))));
    p->nCap = nCapMin;
}
# 441 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrFill( Vec_Str_t * p, int nSize, char Fill )
{
    int i;
    Vec_StrGrow( p, nSize );
    p->nSize = nSize;
    for ( i = 0; i < p->nSize; i++ )
        p->pArray[i] = Fill;
}
# 461 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrFillExtra( Vec_Str_t * p, int nSize, char Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_StrGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_StrGrow( p, 2 * p->nCap );
    for ( i = p->nSize; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 486 "/app/abc/src/misc/vec/vecStr.h"
static inline char Vec_StrGetEntry( Vec_Str_t * p, int i )
{
    Vec_StrFillExtra( p, i + 1, 0 );
    return Vec_StrEntry( p, i );
}
# 503 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrSetEntry( Vec_Str_t * p, int i, char Entry )
{
    Vec_StrFillExtra( p, i + 1, 0 );
    Vec_StrWriteEntry( p, i, Entry );
}
# 520 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrShrink( Vec_Str_t * p, int nSizeNew )
{
    
# 522 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 522 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize >= nSizeNew
# 522 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 522 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize >= nSizeNew
# 522 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 522 "/app/abc/src/misc/vec/vecStr.h"
   "p->nSize >= nSizeNew"
# 522 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 522, __extension__ __PRETTY_FUNCTION__); }))
# 522 "/app/abc/src/misc/vec/vecStr.h"
                                 ;
    p->nSize = nSizeNew;
}
# 537 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrClear( Vec_Str_t * p )
{
    p->nSize = 0;
}
# 553 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrPush( Vec_Str_t * p, char Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_StrGrow( p, 16 );
        else
            Vec_StrGrow( p, 2 * p->nCap );
    }
    p->pArray[p->nSize++] = Entry;
}
static inline void Vec_StrPushTwo( Vec_Str_t * p, char Entry1, char Entry2 )
{
    Vec_StrPush( p, Entry1 );
    Vec_StrPush( p, Entry2 );
}
static inline void Vec_StrPushBuffer( Vec_Str_t * p, char * pBuffer, int nSize )
{
    if ( p->nSize + nSize > p->nCap )
        Vec_StrGrow( p, 2 * (p->nSize + nSize) );
    memcpy( p->pArray + p->nSize, pBuffer, (size_t)nSize );
    p->nSize += nSize;
}
# 588 "/app/abc/src/misc/vec/vecStr.h"
static inline char Vec_StrPop( Vec_Str_t * p )
{
    
# 590 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ((void) sizeof ((
# 590 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize > 0
# 590 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 590 "/app/abc/src/misc/vec/vecStr.h"
   p->nSize > 0
# 590 "/app/abc/src/misc/vec/vecStr.h" 3 4
   ) ; else __assert_fail (
# 590 "/app/abc/src/misc/vec/vecStr.h"
   "p->nSize > 0"
# 590 "/app/abc/src/misc/vec/vecStr.h" 3 4
   , "/app/abc/src/misc/vec/vecStr.h", 590, __extension__ __PRETTY_FUNCTION__); }))
# 590 "/app/abc/src/misc/vec/vecStr.h"
                         ;
    return p->pArray[--p->nSize];
}
# 605 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrIntPrint( Vec_Str_t * p )
{
    int i;
    printf( "Vector has %d entries: {", Vec_StrSize(p) );
    for ( i = 0; i < Vec_StrSize(p); i++ )
        printf( " %d", (int)Vec_StrEntry(p, i) );
    printf( " }\n" );
}
# 625 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrPrintNum( Vec_Str_t * p, int Num )
{
    int i;
    char Digits[16];
    if ( Num == 0 )
    {
        Vec_StrPush( p, '0' );
        return;
    }
    if ( Num < 0 )
    {
        Vec_StrPush( p, '-' );
        Num = -Num;
    }
    for ( i = 0; Num; Num /= 10, i++ )
        Digits[i] = Num % 10;
    for ( i--; i >= 0; i-- )
        Vec_StrPush( p, (char)('0' + Digits[i]) );
}
static inline void Vec_StrPrintNumStar( Vec_Str_t * p, int Num, int nDigits )
{
    int i;
    char Digits[16] = {0};
    if ( Num == 0 )
    {
        for ( i = 0; i < nDigits; i++ )
            Vec_StrPush( p, '0' );
        return;
    }
    if ( Num < 0 )
    {
        Vec_StrPush( p, '-' );
        Num = -Num;
        nDigits--;
    }
    for ( i = 0; Num; Num /= 10, i++ )
        Digits[i] = Num % 10;
    for ( i = Abc_MaxInt(i, nDigits)-1; i >= 0; i-- )
        Vec_StrPush( p, (char)('0' + Digits[i]) );
}
# 677 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrPrintStr( Vec_Str_t * p, const char * pStr )
{
    int i, Length = (int)strlen(pStr);
    for ( i = 0; i < Length; i++ )
        Vec_StrPush( p, pStr[i] );
}
# 700 "/app/abc/src/misc/vec/vecStr.h"
static inline char * Vec_StrPrintF( Vec_Str_t * p, const char * format, ... )
{
    int nAdded, nSize = 1000;
    va_list args; 
# 703 "/app/abc/src/misc/vec/vecStr.h" 3 4
                  __builtin_va_start(
# 703 "/app/abc/src/misc/vec/vecStr.h"
                  args
# 703 "/app/abc/src/misc/vec/vecStr.h" 3 4
                  ,
# 703 "/app/abc/src/misc/vec/vecStr.h"
                  format
# 703 "/app/abc/src/misc/vec/vecStr.h" 3 4
                  )
# 703 "/app/abc/src/misc/vec/vecStr.h"
                                          ;
    Vec_StrGrow( p, Vec_StrSize(p) + nSize );
    nAdded = vsnprintf( Vec_StrLimit(p), nSize, format, args );
    if ( nAdded > nSize )
    {
        Vec_StrGrow( p, Vec_StrSize(p) + nAdded + nSize );
        nSize = vsnprintf( Vec_StrLimit(p), nAdded, format, args );
        
# 710 "/app/abc/src/misc/vec/vecStr.h" 3 4
       ((void) sizeof ((
# 710 "/app/abc/src/misc/vec/vecStr.h"
       nSize == nAdded
# 710 "/app/abc/src/misc/vec/vecStr.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 710 "/app/abc/src/misc/vec/vecStr.h"
       nSize == nAdded
# 710 "/app/abc/src/misc/vec/vecStr.h" 3 4
       ) ; else __assert_fail (
# 710 "/app/abc/src/misc/vec/vecStr.h"
       "nSize == nAdded"
# 710 "/app/abc/src/misc/vec/vecStr.h" 3 4
       , "/app/abc/src/misc/vec/vecStr.h", 710, __extension__ __PRETTY_FUNCTION__); }))
# 710 "/app/abc/src/misc/vec/vecStr.h"
                                ;
    }
    p->nSize += nAdded;
    
# 713 "/app/abc/src/misc/vec/vecStr.h" 3 4
   __builtin_va_end(
# 713 "/app/abc/src/misc/vec/vecStr.h"
   args
# 713 "/app/abc/src/misc/vec/vecStr.h" 3 4
   )
# 713 "/app/abc/src/misc/vec/vecStr.h"
                 ;
    return Vec_StrLimit(p) - nAdded;
}
# 728 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrAppend( Vec_Str_t * p, const char * pString )
{
    Vec_StrPrintStr( p, pString );
}
static inline void Vec_StrCopy( Vec_Str_t * p, const char * pString )
{
    Vec_StrClear( p );
    Vec_StrAppend( p, pString );
    Vec_StrPush( p, '\0' );
}
# 750 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrReverseOrder( Vec_Str_t * p )
{
    int i, Temp;
    for ( i = 0; i < p->nSize/2; i++ )
    {
        Temp = p->pArray[i];
        p->pArray[i] = p->pArray[p->nSize-1-i];
        p->pArray[p->nSize-1-i] = Temp;
    }
}
# 772 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrSum( Vec_Str_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (int)p->pArray[i];
    return Counter;
}
# 791 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrCountEntry( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] == Entry);
    return Counter;
}
static inline int Vec_StrCountLarger( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] > Entry);
    return Counter;
}
static inline int Vec_StrCountSmaller( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] < Entry);
    return Counter;
}
# 824 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrCountEntryLit( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (Abc_Lit2Var((int)p->pArray[i]) == Entry);
    return Counter;
}
static inline int Vec_StrCountLargerLit( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (Abc_Lit2Var((int)p->pArray[i]) > Entry);
    return Counter;
}
static inline int Vec_StrCountSmallerLit( Vec_Str_t * p, char Entry )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (Abc_Lit2Var((int)p->pArray[i]) < Entry);
    return Counter;
}
# 857 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrEqual( Vec_Str_t * p1, Vec_Str_t * p2 )
{
    int i;
    if ( p1->nSize != p2->nSize )
        return 0;
    for ( i = 0; i < p1->nSize; i++ )
        if ( p1->pArray[i] != p2->pArray[i] )
            return 0;
    return 1;
}
# 879 "/app/abc/src/misc/vec/vecStr.h"
static int Vec_StrSortCompare1( char * pp1, char * pp2 )
{

    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 900 "/app/abc/src/misc/vec/vecStr.h"
static int Vec_StrSortCompare2( char * pp1, char * pp2 )
{

    if ( *pp1 > *pp2 )
        return -1;
    if ( *pp1 < *pp2 )
        return 1;
    return 0;
}
# 921 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrSort( Vec_Str_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(char),
                (int (*)(const void *, const void *)) Vec_StrSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(char),
                (int (*)(const void *, const void *)) Vec_StrSortCompare1 );
}
# 942 "/app/abc/src/misc/vec/vecStr.h"
static inline int Vec_StrCompareVec( Vec_Str_t * p1, Vec_Str_t * p2 )
{
    if ( p1 == 
# 944 "/app/abc/src/misc/vec/vecStr.h" 3 4
              ((void *)0) 
# 944 "/app/abc/src/misc/vec/vecStr.h"
                   || p2 == 
# 944 "/app/abc/src/misc/vec/vecStr.h" 3 4
                            ((void *)0) 
# 944 "/app/abc/src/misc/vec/vecStr.h"
                                 )
        return (p1 != 
# 945 "/app/abc/src/misc/vec/vecStr.h" 3 4
                     ((void *)0)
# 945 "/app/abc/src/misc/vec/vecStr.h"
                         ) - (p2 != 
# 945 "/app/abc/src/misc/vec/vecStr.h" 3 4
                                    ((void *)0)
# 945 "/app/abc/src/misc/vec/vecStr.h"
                                        );
    if ( Vec_StrSize(p1) != Vec_StrSize(p2) )
        return Vec_StrSize(p1) - Vec_StrSize(p2);
    return memcmp( Vec_StrArray(p1), Vec_StrArray(p2), (size_t)Vec_StrSize(p1) );
}
# 963 "/app/abc/src/misc/vec/vecStr.h"
static inline void Vec_StrPutI_ne( Vec_Str_t * vOut, int Val )
{
    int i;

    for ( i = 3; i >= 0; i-- )
        Vec_StrPush( vOut, (char)(Val >> (8*i)) );
}
static inline int Vec_StrGetI_ne( Vec_Str_t * vOut, int * pPos )
{
    int i;
    int Val = 0;

    for ( i = 3; i >= 0; i-- )
        Val |= ((int)(unsigned char)Vec_StrEntry(vOut, (*pPos)++) << (8*i));
    return Val;
}

static inline void Vec_StrPutI( Vec_Str_t * vOut, int Val )
{
    for ( ; Val >= 0x80; Val >>= 7 )
        Vec_StrPush( vOut, (unsigned char)(Val | 0x80) );
    Vec_StrPush( vOut, (unsigned char)Val );
}
static inline int Vec_StrGetI( Vec_Str_t * vOut, int * pPos )
{
    unsigned char ch;
    int i = 0, Val = 0;
    while ( (ch = Vec_StrEntry(vOut, (*pPos)++)) & 0x80 )
        Val |= ((ch & 0x7f) << (7 * i++));
    return Val | (ch << (7 * i));
}

static inline void Vec_StrPutW( Vec_Str_t * vOut, word Val )
{
    int i;
    for ( i = 0; i < 8; i++ )
        Vec_StrPush( vOut, (char)(Val >> (8*i)) );
}
static inline word Vec_StrGetW( Vec_Str_t * vOut, int * pPos )
{
    int i;
    word Val = 0;
    for ( i = 0; i < 8; i++ )
        Val |= ((word)(unsigned char)Vec_StrEntry(vOut, (*pPos)++) << (8*i));
    return Val;
}

static inline void Vec_StrPutF( Vec_Str_t * vOut, float Val )
{
    union { float num; unsigned char data[4]; } tmp;
    tmp.num = Val;
    Vec_StrPush( vOut, tmp.data[0] );
    Vec_StrPush( vOut, tmp.data[1] );
    Vec_StrPush( vOut, tmp.data[2] );
    Vec_StrPush( vOut, tmp.data[3] );
}
static inline float Vec_StrGetF( Vec_Str_t * vOut, int * pPos )
{
    union { float num; unsigned char data[4]; } tmp;
    tmp.data[0] = Vec_StrEntry( vOut, (*pPos)++ );
    tmp.data[1] = Vec_StrEntry( vOut, (*pPos)++ );
    tmp.data[2] = Vec_StrEntry( vOut, (*pPos)++ );
    tmp.data[3] = Vec_StrEntry( vOut, (*pPos)++ );
    return tmp.num;
}

static inline void Vec_StrPutD( Vec_Str_t * vOut, double Val )
{
    union { double num; unsigned char data[8]; } tmp;
    int i, Lim = sizeof(double);
    tmp.num = Val;
    for ( i = 0; i < Lim; i++ )
        Vec_StrPush( vOut, tmp.data[i] );
}
static inline double Vec_StrGetD( Vec_Str_t * vOut, int * pPos )
{
    union { double num; unsigned char data[8]; } tmp;
    int i, Lim = sizeof(double);
    for ( i = 0; i < Lim; i++ )
        tmp.data[i] = Vec_StrEntry( vOut, (*pPos)++ );
    return tmp.num;
}

static inline void Vec_StrPutS( Vec_Str_t * vOut, char * pStr )
{
    while ( *pStr )
        Vec_StrPush( vOut, *pStr++ );
    Vec_StrPush( vOut, (char)0 );
}
static inline char * Vec_StrGetS( Vec_Str_t * vOut, int * pPos )
{
    char * pStr = Vec_StrEntryP( vOut, *pPos );
    while ( Vec_StrEntry(vOut, (*pPos)++) );
    return Abc_UtilStrsav(pStr);
}

static inline void Vec_StrPutC( Vec_Str_t * vOut, char c )
{
    Vec_StrPush( vOut, c );
}
static inline char Vec_StrGetC( Vec_Str_t * vOut, int * pPos )
{
    return Vec_StrEntry(vOut, (*pPos)++);
}




# 34 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecPtr.h" 1
# 31 "/app/abc/src/misc/vec/vecPtr.h"

# 42 "/app/abc/src/misc/vec/vecPtr.h"
typedef struct Vec_Ptr_t_ Vec_Ptr_t;
struct Vec_Ptr_t_
{
    int nCap;
    int nSize;
    void ** pArray;
};
# 85 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrAlloc( int nCap )
{
    Vec_Ptr_t * p;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 8 )
        nCap = 8;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((void * *) malloc(sizeof(void *) * (size_t)(p->nCap))) : 
# 93 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                                                       ((void *)0)
# 93 "/app/abc/src/misc/vec/vecPtr.h"
                                                           ;
    return p;
}
static inline Vec_Ptr_t * Vec_PtrAllocExact( int nCap )
{
    Vec_Ptr_t * p;
    
# 99 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 99 "/app/abc/src/misc/vec/vecPtr.h"
   nCap >= 0
# 99 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 99 "/app/abc/src/misc/vec/vecPtr.h"
   nCap >= 0
# 99 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 99 "/app/abc/src/misc/vec/vecPtr.h"
   "nCap >= 0"
# 99 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 99, __extension__ __PRETTY_FUNCTION__); }))
# 99 "/app/abc/src/misc/vec/vecPtr.h"
                      ;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((void * *) malloc(sizeof(void *) * (size_t)(p->nCap))) : 
# 103 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                                                       ((void *)0)
# 103 "/app/abc/src/misc/vec/vecPtr.h"
                                                           ;
    return p;
}
# 118 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrStart( int nSize )
{
    Vec_Ptr_t * p;
    p = Vec_PtrAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0, sizeof(void *) * (size_t)nSize );
    return p;
}
# 138 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrAllocArray( void ** pArray, int nSize )
{
    Vec_Ptr_t * p;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = pArray;
    return p;
}
# 159 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrAllocArrayCopy( void ** pArray, int nSize )
{
    Vec_Ptr_t * p;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = ((void * *) malloc(sizeof(void *) * (size_t)(nSize)));
    memcpy( p->pArray, pArray, sizeof(void *) * (size_t)nSize );
    return p;
}
# 181 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrDup( Vec_Ptr_t * pVec )
{
    Vec_Ptr_t * p;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = p->nCap? ((void * *) malloc(sizeof(void *) * (size_t)(p->nCap))) : 
# 187 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                                                       ((void *)0)
# 187 "/app/abc/src/misc/vec/vecPtr.h"
                                                           ;
    memcpy( p->pArray, pVec->pArray, sizeof(void *) * (size_t)pVec->nSize );
    return p;
}
static inline Vec_Ptr_t * Vec_PtrDupStr( Vec_Ptr_t * pVec )
{
    int i;
    Vec_Ptr_t * p = Vec_PtrDup( pVec );
    for ( i = 0; i < p->nSize; i++ )
        p->pArray[i] = Abc_UtilStrsav( (char *)p->pArray[i] );
    return p;
}
# 211 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrDupArray( Vec_Ptr_t * pVec )
{
    Vec_Ptr_t * p;
    p = ((Vec_Ptr_t *) malloc(sizeof(Vec_Ptr_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = pVec->pArray;
    pVec->nSize = 0;
    pVec->nCap = 0;
    pVec->pArray = 
# 220 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                  ((void *)0)
# 220 "/app/abc/src/misc/vec/vecPtr.h"
                      ;
    return p;
}
# 235 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrZero( Vec_Ptr_t * p )
{
    p->pArray = 
# 237 "/app/abc/src/misc/vec/vecPtr.h" 3 4
               ((void *)0)
# 237 "/app/abc/src/misc/vec/vecPtr.h"
                   ;
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_PtrErase( Vec_Ptr_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_PtrFree( Vec_Ptr_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 264 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrFreeP( Vec_Ptr_t ** p )
{
    if ( *p == 
# 266 "/app/abc/src/misc/vec/vecPtr.h" 3 4
              ((void *)0) 
# 266 "/app/abc/src/misc/vec/vecPtr.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 283 "/app/abc/src/misc/vec/vecPtr.h"
static inline void ** Vec_PtrReleaseArray( Vec_Ptr_t * p )
{
    void ** pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 288 "/app/abc/src/misc/vec/vecPtr.h" 3 4
               ((void *)0)
# 288 "/app/abc/src/misc/vec/vecPtr.h"
                   ;
    return pArray;
}
# 303 "/app/abc/src/misc/vec/vecPtr.h"
static inline void ** Vec_PtrArray( Vec_Ptr_t * p )
{
    return p->pArray;
}
# 319 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrSize( Vec_Ptr_t * p )
{
    return p->nSize;
}
# 335 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrCap( Vec_Ptr_t * p )
{
    return p->nCap;
}
# 351 "/app/abc/src/misc/vec/vecPtr.h"
static inline double Vec_PtrMemory( Vec_Ptr_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(void *) * (size_t)p->nCap + sizeof(Vec_Ptr_t);
}
# 367 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrCountZero( Vec_Ptr_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] == 
# 371 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                                   ((void *)0)
# 371 "/app/abc/src/misc/vec/vecPtr.h"
                                       );
    return Counter;
}
# 386 "/app/abc/src/misc/vec/vecPtr.h"
static inline void * Vec_PtrEntry( Vec_Ptr_t * p, int i )
{
    
# 388 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 388 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 388 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 388 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 388 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 388 "/app/abc/src/misc/vec/vecPtr.h"
   "i >= 0 && i < p->nSize"
# 388 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 388, __extension__ __PRETTY_FUNCTION__); }))
# 388 "/app/abc/src/misc/vec/vecPtr.h"
                                   ;
    return p->pArray[i];
}
# 403 "/app/abc/src/misc/vec/vecPtr.h"
static inline void ** Vec_PtrEntryP( Vec_Ptr_t * p, int i )
{
    
# 405 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 405 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 405 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 405 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 405 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 405 "/app/abc/src/misc/vec/vecPtr.h"
   "i >= 0 && i < p->nSize"
# 405 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 405, __extension__ __PRETTY_FUNCTION__); }))
# 405 "/app/abc/src/misc/vec/vecPtr.h"
                                   ;
    return p->pArray + i;
}
# 420 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrWriteEntry( Vec_Ptr_t * p, int i, void * Entry )
{
    
# 422 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 422 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 422 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 422 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < p->nSize
# 422 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 422 "/app/abc/src/misc/vec/vecPtr.h"
   "i >= 0 && i < p->nSize"
# 422 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 422, __extension__ __PRETTY_FUNCTION__); }))
# 422 "/app/abc/src/misc/vec/vecPtr.h"
                                   ;
    p->pArray[i] = Entry;
}
# 437 "/app/abc/src/misc/vec/vecPtr.h"
static inline void * Vec_PtrEntryLast( Vec_Ptr_t * p )
{
    
# 439 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 439 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize > 0
# 439 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 439 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize > 0
# 439 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 439 "/app/abc/src/misc/vec/vecPtr.h"
   "p->nSize > 0"
# 439 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 439, __extension__ __PRETTY_FUNCTION__); }))
# 439 "/app/abc/src/misc/vec/vecPtr.h"
                         ;
    return p->pArray[p->nSize-1];
}
# 454 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrGrow( Vec_Ptr_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((void * *) realloc((char *)(p->pArray), sizeof(void *) * (size_t)(nCapMin))) : ((void * *) malloc(sizeof(void *) * (size_t)(nCapMin))));
    p->nCap = nCapMin;
}
# 473 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrFill( Vec_Ptr_t * p, int nSize, void * Entry )
{
    int i;
    Vec_PtrGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = Entry;
    p->nSize = nSize;
}
static inline void Vec_PtrFillTwo( Vec_Ptr_t * p, int nSize, void * EntryEven, void * EntryOdd )
{
    int i;
    Vec_PtrGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = (i & 1) ? EntryOdd : EntryEven;
    p->nSize = nSize;
}
# 501 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrFillExtra( Vec_Ptr_t * p, int nSize, void * Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_PtrGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_PtrGrow( p, 2 * p->nCap );
    for ( i = p->nSize; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 526 "/app/abc/src/misc/vec/vecPtr.h"
static inline void * Vec_PtrGetEntry( Vec_Ptr_t * p, int i )
{
    Vec_PtrFillExtra( p, i + 1, 
# 528 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                               ((void *)0) 
# 528 "/app/abc/src/misc/vec/vecPtr.h"
                                    );
    return Vec_PtrEntry( p, i );
}
# 543 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrSetEntry( Vec_Ptr_t * p, int i, void * Entry )
{
    Vec_PtrFillExtra( p, i + 1, 
# 545 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                               ((void *)0) 
# 545 "/app/abc/src/misc/vec/vecPtr.h"
                                    );
    Vec_PtrWriteEntry( p, i, Entry );
}
# 560 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrShrink( Vec_Ptr_t * p, int nSizeNew )
{
    
# 562 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 562 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize >= nSizeNew
# 562 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 562 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize >= nSizeNew
# 562 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 562 "/app/abc/src/misc/vec/vecPtr.h"
   "p->nSize >= nSizeNew"
# 562 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 562, __extension__ __PRETTY_FUNCTION__); }))
# 562 "/app/abc/src/misc/vec/vecPtr.h"
                                 ;
    p->nSize = nSizeNew;
}
# 577 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrClear( Vec_Ptr_t * p )
{
    p->nSize = 0;
}
# 593 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrFreeData( Vec_Ptr_t * p )
{
    void * pTemp; int i;
    if ( p == 
# 596 "/app/abc/src/misc/vec/vecPtr.h" 3 4
             ((void *)0) 
# 596 "/app/abc/src/misc/vec/vecPtr.h"
                  ) return;
    for ( i = 0; (i < Vec_PtrSize(p)) && (((pTemp) = (void *)Vec_PtrEntry(p, i)), 1); i++ )
        if ( pTemp != (void *)(ABC_PTRINT_T)1 && pTemp != (void *)(ABC_PTRINT_T)2 )
            ((pTemp) ? (free((char *) (pTemp)), (pTemp) = 0) : 0);
}
static inline void Vec_PtrFreeFree( Vec_Ptr_t * p )
{
    if ( p == 
# 603 "/app/abc/src/misc/vec/vecPtr.h" 3 4
             ((void *)0) 
# 603 "/app/abc/src/misc/vec/vecPtr.h"
                  ) return;
    Vec_PtrFreeData( p );
    Vec_PtrFree( p );
}
# 619 "/app/abc/src/misc/vec/vecPtr.h"
static void Vec_PtrFreeFunc( Vec_Ptr_t * p, void (*pFuncItemFree)(void *) ) __attribute__ ((__unused__));
static void Vec_PtrFreeFunc( Vec_Ptr_t * p, void (*pFuncItemFree)(void *) )
{
    void * pItem; int i;
    for ( i = 0; (i < Vec_PtrSize(p)) && (((pItem) = (void *)Vec_PtrEntry(p, i)), 1); i++ )
        if ( pItem ) pFuncItemFree( pItem );
    Vec_PtrFree( p );
}
# 639 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrCopy( Vec_Ptr_t * pDest, Vec_Ptr_t * pSour )
{
    pDest->nSize = 0;
    Vec_PtrGrow( pDest, pSour->nSize );
    memcpy( pDest->pArray, pSour->pArray, sizeof(void *) * (size_t)pSour->nSize );
    pDest->nSize = pSour->nSize;
}
# 658 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrPrintNames( Vec_Ptr_t * p )
{
    char * pName; int i;
    printf( "Vector has %d entries: {", Vec_PtrSize(p) );
    for ( i = 0; (i < Vec_PtrSize(p)) && (((pName) = (char *)Vec_PtrEntry(p, i)), 1); i++ )
        printf( "%s ", pName );
    printf( " }\n" );
}
# 678 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrPush( Vec_Ptr_t * p, void * Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_PtrGrow( p, 16 );
        else
            Vec_PtrGrow( p, 2 * p->nCap );
    }
    p->pArray[p->nSize++] = Entry;
}
static inline void Vec_PtrPushTwo( Vec_Ptr_t * p, void * Entry1, void * Entry2 )
{
    Vec_PtrPush( p, Entry1 );
    Vec_PtrPush( p, Entry2 );
}
static inline void Vec_PtrAppend( Vec_Ptr_t * vVec1, Vec_Ptr_t * vVec2 )
{
    void * Entry; int i;
    for ( i = 0; (i < Vec_PtrSize(vVec2)) && (((Entry) = (void *)Vec_PtrEntry(vVec2, i)), 1); i++ )
        Vec_PtrPush( vVec1, Entry );
}
# 712 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrPushFirst( Vec_Ptr_t * p, void * Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_PtrGrow( p, 16 );
        else
            Vec_PtrGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize - 1; i >= 1; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[0] = Entry;
}
# 739 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrPushUnique( Vec_Ptr_t * p, void * Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_PtrPush( p, Entry );
    return 0;
}
# 760 "/app/abc/src/misc/vec/vecPtr.h"
static inline void * Vec_PtrPop( Vec_Ptr_t * p )
{
    
# 762 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 762 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize > 0
# 762 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 762 "/app/abc/src/misc/vec/vecPtr.h"
   p->nSize > 0
# 762 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 762 "/app/abc/src/misc/vec/vecPtr.h"
   "p->nSize > 0"
# 762 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 762, __extension__ __PRETTY_FUNCTION__); }))
# 762 "/app/abc/src/misc/vec/vecPtr.h"
                         ;
    return p->pArray[--p->nSize];
}
# 777 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrFind( Vec_Ptr_t * p, void * Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return i;
    return -1;
}
static inline int Vec_PtrFindStr( Vec_Ptr_t * p, char * Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] && !strcmp((char *)p->pArray[i], Entry) )
            return i;
    return -1;
}
# 805 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrRemove( Vec_Ptr_t * p, void * Entry )
{
    int i;

    for ( i = p->nSize - 1; i >= 0; i-- )
        if ( p->pArray[i] == Entry )
            break;
    
# 812 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 812 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0
# 812 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 812 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0
# 812 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 812 "/app/abc/src/misc/vec/vecPtr.h"
   "i >= 0"
# 812 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 812, __extension__ __PRETTY_FUNCTION__); }))
# 812 "/app/abc/src/misc/vec/vecPtr.h"
                   ;







    for ( i++; i < p->nSize; i++ )
        p->pArray[i-1] = p->pArray[i];
    p->nSize--;
}
# 836 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrDrop( Vec_Ptr_t * p, int i )
{
    int k;
    
# 839 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 839 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < Vec_PtrSize(p)
# 839 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 839 "/app/abc/src/misc/vec/vecPtr.h"
   i >= 0 && i < Vec_PtrSize(p)
# 839 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 839 "/app/abc/src/misc/vec/vecPtr.h"
   "i >= 0 && i < Vec_PtrSize(p)"
# 839 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 839, __extension__ __PRETTY_FUNCTION__); }))
# 839 "/app/abc/src/misc/vec/vecPtr.h"
                                         ;
    p->nSize--;
    for ( k = i; k < p->nSize; k++ )
        p->pArray[k] = p->pArray[k+1];
}
# 856 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrInsert( Vec_Ptr_t * p, int iHere, void * Entry )
{
    int i;
    
# 859 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 859 "/app/abc/src/misc/vec/vecPtr.h"
   iHere >= 0 && iHere < p->nSize
# 859 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 859 "/app/abc/src/misc/vec/vecPtr.h"
   iHere >= 0 && iHere < p->nSize
# 859 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 859 "/app/abc/src/misc/vec/vecPtr.h"
   "iHere >= 0 && iHere < p->nSize"
# 859 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 859, __extension__ __PRETTY_FUNCTION__); }))
# 859 "/app/abc/src/misc/vec/vecPtr.h"
                                           ;
    Vec_PtrPush( p, 0 );
    for ( i = p->nSize - 1; i > iHere; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[i] = Entry;
}
# 877 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrReorder( Vec_Ptr_t * p, int nItems )
{
    
# 879 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 879 "/app/abc/src/misc/vec/vecPtr.h"
   nItems < p->nSize
# 879 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 879 "/app/abc/src/misc/vec/vecPtr.h"
   nItems < p->nSize
# 879 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 879 "/app/abc/src/misc/vec/vecPtr.h"
   "nItems < p->nSize"
# 879 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 879, __extension__ __PRETTY_FUNCTION__); }))
# 879 "/app/abc/src/misc/vec/vecPtr.h"
                              ;
    Vec_PtrGrow( p, nItems + p->nSize );
    memmove( (char **)p->pArray + p->nSize, p->pArray, (size_t)nItems * sizeof(void*) );
    memmove( p->pArray, (char **)p->pArray + nItems, (size_t)p->nSize * sizeof(void*) );
}
# 896 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrReverseOrder( Vec_Ptr_t * p )
{
    void * Temp;
    int i;
    for ( i = 0; i < p->nSize/2; i++ )
    {
        Temp = p->pArray[i];
        p->pArray[i] = p->pArray[p->nSize-1-i];
        p->pArray[p->nSize-1-i] = Temp;
    }
}
# 919 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrEqual( Vec_Ptr_t * p1, Vec_Ptr_t * p2 )
{
    int i;
    if ( p1->nSize != p2->nSize )
        return 0;
    for ( i = 0; i < p1->nSize; i++ )
        if ( p1->pArray[i] != p2->pArray[i] )
            return 0;
    return 1;
}
# 941 "/app/abc/src/misc/vec/vecPtr.h"
static int Vec_PtrSortComparePtr( void ** pp1, void ** pp2 )
{
    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 961 "/app/abc/src/misc/vec/vecPtr.h"
static void Vec_PtrSort( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *) ) __attribute__ ((__unused__));
static void Vec_PtrSort( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *) )
{
    if ( p->nSize < 2 )
        return;
    if ( Vec_PtrSortCompare == 
# 966 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                              ((void *)0) 
# 966 "/app/abc/src/misc/vec/vecPtr.h"
                                   )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_PtrSortComparePtr );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_PtrSortCompare );
}
# 985 "/app/abc/src/misc/vec/vecPtr.h"
static void Vec_PtrUniqify( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *) ) __attribute__ ((__unused__));
static void Vec_PtrUniqify( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *) )
{
    int i, k;
    if ( p->nSize < 2 )
        return;
    Vec_PtrSort( p, Vec_PtrSortCompare );
    for ( i = k = 1; i < p->nSize; i++ )
        if ( p->pArray[i] != p->pArray[i-1] )
            p->pArray[k++] = p->pArray[i];
    p->nSize = k;
}
static void Vec_PtrUniqify2( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *), void (*Vec_PtrObjFree)(void*), Vec_Int_t * vCounts ) __attribute__ ((__unused__));
static void Vec_PtrUniqify2( Vec_Ptr_t * p, int (*Vec_PtrSortCompare)(const void *, const void *), void (*Vec_PtrObjFree)(void*), Vec_Int_t * vCounts )
{
    int i, k;
    if ( vCounts )
        Vec_IntFill( vCounts, 1, 1 );
    if ( p->nSize < 2 )
        return;
    Vec_PtrSort( p, Vec_PtrSortCompare );
    for ( i = k = 1; i < p->nSize; i++ )
        if ( Vec_PtrSortCompare(p->pArray+i, p->pArray+k-1) != 0 )
        {
            p->pArray[k++] = p->pArray[i];
            if ( vCounts )
                Vec_IntPush( vCounts, 1 );
        }
        else
        {
            if ( Vec_PtrObjFree )
                Vec_PtrObjFree( p->pArray[i] );
            if ( vCounts )
                Vec_IntAddToEntry( vCounts, Vec_IntSize(vCounts)-1, 1 );
        }
    p->nSize = k;
    
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
   vCounts == 
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void *)0) 
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
   || Vec_IntSize(vCounts) == Vec_PtrSize(p)
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
   vCounts == 
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void *)0) 
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
   || Vec_IntSize(vCounts) == Vec_PtrSize(p)
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
   "vCounts == NULL || Vec_IntSize(vCounts) == Vec_PtrSize(p)"
# 1021 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 1021, __extension__ __PRETTY_FUNCTION__); }))
# 1021 "/app/abc/src/misc/vec/vecPtr.h"
                                                                      ;
}
# 1040 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrAllocSimInfo( int nEntries, int nWords )
{
    void ** pMemory;
    unsigned * pInfo;
    int i;
    pMemory = (void **)((char *) malloc(sizeof(char) * (size_t)((sizeof(void *) + sizeof(unsigned) * (size_t)nWords) * nEntries)));
    pInfo = (unsigned *)(pMemory + nEntries);
    for ( i = 0; i < nEntries; i++ )
        pMemory[i] = pInfo + i * nWords;
    return Vec_PtrAllocArray( pMemory, nEntries );
}
# 1063 "/app/abc/src/misc/vec/vecPtr.h"
static inline int Vec_PtrReadWordsSimInfo( Vec_Ptr_t * p )
{
    return (unsigned *)Vec_PtrEntry(p,1) - (unsigned *)Vec_PtrEntry(p,0);
}
# 1079 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrCleanSimInfo( Vec_Ptr_t * vInfo, int iWord, int nWords )
{
    int i;
    for ( i = 0; i < vInfo->nSize; i++ )
        memset( (char*)Vec_PtrEntry(vInfo,i) + 4*iWord, 0, (size_t)(4*(nWords-iWord)) );
}
# 1097 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrFillSimInfo( Vec_Ptr_t * vInfo, int iWord, int nWords )
{
    int i;
    for ( i = 0; i < vInfo->nSize; i++ )
        memset( (char*)Vec_PtrEntry(vInfo,i) + 4*iWord, 0xFF, (size_t)(4*(nWords-iWord)) );
}
# 1115 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrDoubleSimInfo( Vec_Ptr_t * vInfo )
{
    Vec_Ptr_t * vInfoNew;
    int nWords;
    
# 1119 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 1119 "/app/abc/src/misc/vec/vecPtr.h"
   Vec_PtrSize(vInfo) > 1
# 1119 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1119 "/app/abc/src/misc/vec/vecPtr.h"
   Vec_PtrSize(vInfo) > 1
# 1119 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 1119 "/app/abc/src/misc/vec/vecPtr.h"
   "Vec_PtrSize(vInfo) > 1"
# 1119 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 1119, __extension__ __PRETTY_FUNCTION__); }))
# 1119 "/app/abc/src/misc/vec/vecPtr.h"
                                   ;

    nWords = (unsigned *)Vec_PtrEntry(vInfo,1) - (unsigned *)Vec_PtrEntry(vInfo,0);
    vInfoNew = Vec_PtrAllocSimInfo( 2*Vec_PtrSize(vInfo), nWords );

    memcpy( Vec_PtrEntry(vInfoNew,0), Vec_PtrEntry(vInfo,0), (size_t)(Vec_PtrSize(vInfo) * nWords * 4) );

    ((vInfo->pArray) ? (free((char *) (vInfo->pArray)), (vInfo->pArray) = 0) : 0);
    vInfo->pArray = vInfoNew->pArray;
    vInfo->nSize *= 2;
    vInfo->nCap *= 2;

    vInfoNew->pArray = 
# 1131 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                      ((void *)0)
# 1131 "/app/abc/src/misc/vec/vecPtr.h"
                          ;
    ((vInfoNew) ? (free((char *) (vInfoNew)), (vInfoNew) = 0) : 0);
}
# 1146 "/app/abc/src/misc/vec/vecPtr.h"
static inline void Vec_PtrReallocSimInfo( Vec_Ptr_t * vInfo )
{
    Vec_Ptr_t * vInfoNew;
    int nWords, i;
    
# 1150 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ((void) sizeof ((
# 1150 "/app/abc/src/misc/vec/vecPtr.h"
   Vec_PtrSize(vInfo) > 1
# 1150 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1150 "/app/abc/src/misc/vec/vecPtr.h"
   Vec_PtrSize(vInfo) > 1
# 1150 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   ) ; else __assert_fail (
# 1150 "/app/abc/src/misc/vec/vecPtr.h"
   "Vec_PtrSize(vInfo) > 1"
# 1150 "/app/abc/src/misc/vec/vecPtr.h" 3 4
   , "/app/abc/src/misc/vec/vecPtr.h", 1150, __extension__ __PRETTY_FUNCTION__); }))
# 1150 "/app/abc/src/misc/vec/vecPtr.h"
                                   ;

    nWords = (unsigned *)Vec_PtrEntry(vInfo,1) - (unsigned *)Vec_PtrEntry(vInfo,0);
    vInfoNew = Vec_PtrAllocSimInfo( Vec_PtrSize(vInfo), 2*nWords );

    for ( i = 0; i < vInfo->nSize; i++ )
        memcpy( Vec_PtrEntry(vInfoNew,i), Vec_PtrEntry(vInfo,i), (size_t)(nWords * 4) );

    ((vInfo->pArray) ? (free((char *) (vInfo->pArray)), (vInfo->pArray) = 0) : 0);
    vInfo->pArray = vInfoNew->pArray;

    vInfoNew->pArray = 
# 1161 "/app/abc/src/misc/vec/vecPtr.h" 3 4
                      ((void *)0)
# 1161 "/app/abc/src/misc/vec/vecPtr.h"
                          ;
    ((vInfoNew) ? (free((char *) (vInfoNew)), (vInfoNew) = 0) : 0);
}
# 1176 "/app/abc/src/misc/vec/vecPtr.h"
static inline Vec_Ptr_t * Vec_PtrAllocTruthTables( int nVars )
{
    Vec_Ptr_t * p;
    unsigned Masks[5] = { 0xAAAAAAAA, 0xCCCCCCCC, 0xF0F0F0F0, 0xFF00FF00, 0xFFFF0000 };
    unsigned * pTruth;
    int i, k, nWords;
    nWords = (nVars <= 5 ? 1 : (1 << (nVars - 5)));
    p = Vec_PtrAllocSimInfo( nVars, nWords );
    for ( i = 0; i < nVars; i++ )
    {
        pTruth = (unsigned *)p->pArray[i];
        if ( i < 5 )
        {
            for ( k = 0; k < nWords; k++ )
                pTruth[k] = Masks[i];
        }
        else
        {
            for ( k = 0; k < nWords; k++ )
                if ( k & (1 << (i-5)) )
                    pTruth[k] = ~(unsigned)0;
                else
                    pTruth[k] = 0;
        }
    }
    return p;
}




# 35 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecVec.h" 1
# 31 "/app/abc/src/misc/vec/vecVec.h"

# 42 "/app/abc/src/misc/vec/vecVec.h"
typedef struct Vec_Vec_t_ Vec_Vec_t;
struct Vec_Vec_t_
{
    int nCap;
    int nSize;
    void ** pArray;
};
# 145 "/app/abc/src/misc/vec/vecVec.h"
static inline Vec_Vec_t * Vec_VecAlloc( int nCap )
{
    Vec_Vec_t * p;
    p = ((Vec_Vec_t *) malloc(sizeof(Vec_Vec_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 8 )
        nCap = 8;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((void * *) malloc(sizeof(void *) * (size_t)(p->nCap))) : 
# 153 "/app/abc/src/misc/vec/vecVec.h" 3 4
                                                       ((void *)0)
# 153 "/app/abc/src/misc/vec/vecVec.h"
                                                           ;
    return p;
}
# 168 "/app/abc/src/misc/vec/vecVec.h"
static inline Vec_Vec_t * Vec_VecStart( int nSize )
{
    Vec_Vec_t * p;
    int i;
    p = Vec_VecAlloc( nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = Vec_PtrAlloc( 0 );
    p->nSize = nSize;
    return p;
}
# 190 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecExpand( Vec_Vec_t * p, int Level )
{
    int i;
    if ( p->nSize >= Level + 1 )
        return;
    Vec_PtrGrow( (Vec_Ptr_t *)p, Level + 1 );
    for ( i = p->nSize; i <= Level; i++ )
        p->pArray[i] = Vec_PtrAlloc( 0 );
    p->nSize = Level + 1;
}
static inline void Vec_VecExpandInt( Vec_Vec_t * p, int Level )
{
    int i;
    if ( p->nSize >= Level + 1 )
        return;
    Vec_IntGrow( (Vec_Int_t *)p, Level + 1 );
    for ( i = p->nSize; i <= Level; i++ )
        p->pArray[i] = Vec_PtrAlloc( 0 );
    p->nSize = Level + 1;
}
# 222 "/app/abc/src/misc/vec/vecVec.h"
static inline int Vec_VecSize( Vec_Vec_t * p )
{
    return p->nSize;
}
# 238 "/app/abc/src/misc/vec/vecVec.h"
static inline int Vec_VecCap( Vec_Vec_t * p )
{
    return p->nCap;
}
# 254 "/app/abc/src/misc/vec/vecVec.h"
static inline int Vec_VecLevelSize( Vec_Vec_t * p, int i )
{
    
# 256 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ((void) sizeof ((
# 256 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 256 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 256 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 256 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ; else __assert_fail (
# 256 "/app/abc/src/misc/vec/vecVec.h"
   "i >= 0 && i < p->nSize"
# 256 "/app/abc/src/misc/vec/vecVec.h" 3 4
   , "/app/abc/src/misc/vec/vecVec.h", 256, __extension__ __PRETTY_FUNCTION__); }))
# 256 "/app/abc/src/misc/vec/vecVec.h"
                                   ;
    return Vec_PtrSize( (Vec_Ptr_t *)p->pArray[i] );
}
# 271 "/app/abc/src/misc/vec/vecVec.h"
static inline Vec_Ptr_t * Vec_VecEntry( Vec_Vec_t * p, int i )
{
    
# 273 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ((void) sizeof ((
# 273 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 273 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 273 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 273 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ; else __assert_fail (
# 273 "/app/abc/src/misc/vec/vecVec.h"
   "i >= 0 && i < p->nSize"
# 273 "/app/abc/src/misc/vec/vecVec.h" 3 4
   , "/app/abc/src/misc/vec/vecVec.h", 273, __extension__ __PRETTY_FUNCTION__); }))
# 273 "/app/abc/src/misc/vec/vecVec.h"
                                   ;
    return (Vec_Ptr_t *)p->pArray[i];
}
static inline Vec_Int_t * Vec_VecEntryInt( Vec_Vec_t * p, int i )
{
    
# 278 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ((void) sizeof ((
# 278 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 278 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 278 "/app/abc/src/misc/vec/vecVec.h"
   i >= 0 && i < p->nSize
# 278 "/app/abc/src/misc/vec/vecVec.h" 3 4
   ) ; else __assert_fail (
# 278 "/app/abc/src/misc/vec/vecVec.h"
   "i >= 0 && i < p->nSize"
# 278 "/app/abc/src/misc/vec/vecVec.h" 3 4
   , "/app/abc/src/misc/vec/vecVec.h", 278, __extension__ __PRETTY_FUNCTION__); }))
# 278 "/app/abc/src/misc/vec/vecVec.h"
                                   ;
    return (Vec_Int_t *)p->pArray[i];
}
# 293 "/app/abc/src/misc/vec/vecVec.h"
static inline double Vec_VecMemory( Vec_Vec_t * p )
{
    int i;
    double Mem;
    if ( p == 
# 297 "/app/abc/src/misc/vec/vecVec.h" 3 4
             ((void *)0) 
# 297 "/app/abc/src/misc/vec/vecVec.h"
                  ) return 0.0;
    Mem = Vec_PtrMemory( (Vec_Ptr_t *)p );
    for ( i = 0; i < p->nSize; i++ )
        if ( Vec_VecEntry(p, i) )
            Mem += Vec_PtrMemory( Vec_VecEntry(p, i) );
    return Mem;
}
static inline double Vec_VecMemoryInt( Vec_Vec_t * p )
{
    int i;
    double Mem;
    if ( p == 
# 308 "/app/abc/src/misc/vec/vecVec.h" 3 4
             ((void *)0) 
# 308 "/app/abc/src/misc/vec/vecVec.h"
                  ) return 0.0;
    Mem = Vec_PtrMemory( (Vec_Ptr_t *)p );
    for ( i = 0; i < p->nSize; i++ )
        if ( Vec_VecEntry(p, i) )
            Mem += Vec_IntMemory( Vec_VecEntryInt(p, i) );
    return Mem;
}
# 327 "/app/abc/src/misc/vec/vecVec.h"
static inline void * Vec_VecEntryEntry( Vec_Vec_t * p, int i, int k )
{
    return Vec_PtrEntry( Vec_VecEntry(p, i), k );
}
static inline int Vec_VecEntryEntryInt( Vec_Vec_t * p, int i, int k )
{
    return Vec_IntEntry( Vec_VecEntryInt(p, i), k );
}
# 347 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecFree( Vec_Vec_t * p )
{
    Vec_Ptr_t * vVec;
    int i;
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntry(p, i)), 1); i++ )
        if ( vVec ) Vec_PtrFree( vVec );
    Vec_PtrFree( (Vec_Ptr_t *)p );
}
static inline void Vec_VecErase( Vec_Vec_t * p )
{
    Vec_Ptr_t * vVec;
    int i;
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntry(p, i)), 1); i++ )
        if ( vVec ) Vec_PtrFree( vVec );
    Vec_PtrErase( (Vec_Ptr_t *)p );
}
# 375 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecFreeP( Vec_Vec_t ** p )
{
    if ( *p == 
# 377 "/app/abc/src/misc/vec/vecVec.h" 3 4
              ((void *)0) 
# 377 "/app/abc/src/misc/vec/vecVec.h"
                   )
        return;
    Vec_VecFree( *p );
    *p = 
# 380 "/app/abc/src/misc/vec/vecVec.h" 3 4
        ((void *)0)
# 380 "/app/abc/src/misc/vec/vecVec.h"
            ;
}
# 394 "/app/abc/src/misc/vec/vecVec.h"
static inline Vec_Vec_t * Vec_VecDup( Vec_Vec_t * p )
{
    Vec_Ptr_t * vNew, * vVec;
    int i;
    vNew = Vec_PtrAlloc( Vec_VecSize(p) );
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntry(p, i)), 1); i++ )
        Vec_PtrPush( vNew, Vec_PtrDup(vVec) );
    return (Vec_Vec_t *)vNew;
}
static inline Vec_Vec_t * Vec_VecDupInt( Vec_Vec_t * p )
{
    Vec_Ptr_t * vNew;
    Vec_Int_t * vVec;
    int i;
    vNew = Vec_PtrAlloc( Vec_VecSize(p) );
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntryInt(p, i)), 1); i++ )
        Vec_PtrPush( vNew, Vec_IntDup(vVec) );
    return (Vec_Vec_t *)vNew;
}
# 425 "/app/abc/src/misc/vec/vecVec.h"
static inline int Vec_VecSizeSize( Vec_Vec_t * p )
{
    Vec_Ptr_t * vVec;
    int i, Counter = 0;
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntry(p, i)), 1); i++ )
        Counter += vVec->nSize;
    return Counter;
}
# 445 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecClear( Vec_Vec_t * p )
{
    Vec_Ptr_t * vVec;
    int i;
    for ( i = 0; (i < Vec_VecSize(p)) && (((vVec) = Vec_VecEntry(p, i)), 1); i++ )
        Vec_PtrClear( vVec );
}
# 464 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecPush( Vec_Vec_t * p, int Level, void * Entry )
{
    if ( p->nSize < Level + 1 )
    {
        int i;
        Vec_PtrGrow( (Vec_Ptr_t *)p, Level + 1 );
        for ( i = p->nSize; i < Level + 1; i++ )
            p->pArray[i] = Vec_PtrAlloc( 0 );
        p->nSize = Level + 1;
    }
    Vec_PtrPush( Vec_VecEntry(p, Level), Entry );
}
static inline void Vec_VecPushInt( Vec_Vec_t * p, int Level, int Entry )
{
    if ( p->nSize < Level + 1 )
    {
        int i;
        Vec_PtrGrow( (Vec_Ptr_t *)p, Level + 1 );
        for ( i = p->nSize; i < Level + 1; i++ )
            p->pArray[i] = Vec_IntAlloc( 0 );
        p->nSize = Level + 1;
    }
    Vec_IntPush( Vec_VecEntryInt(p, Level), Entry );
}
# 500 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecPushUnique( Vec_Vec_t * p, int Level, void * Entry )
{
    if ( p->nSize < Level + 1 )
        Vec_VecPush( p, Level, Entry );
    else
        Vec_PtrPushUnique( Vec_VecEntry(p, Level), Entry );
}
static inline void Vec_VecPushUniqueInt( Vec_Vec_t * p, int Level, int Entry )
{
    if ( p->nSize < Level + 1 )
        Vec_VecPushInt( p, Level, Entry );
    else
        Vec_IntPushUnique( Vec_VecEntryInt(p, Level), Entry );
}
# 526 "/app/abc/src/misc/vec/vecVec.h"
static int Vec_VecSortCompare1( Vec_Ptr_t ** pp1, Vec_Ptr_t ** pp2 )
{
    if ( Vec_PtrSize(*pp1) < Vec_PtrSize(*pp2) )
        return -1;
    if ( Vec_PtrSize(*pp1) > Vec_PtrSize(*pp2) )
        return 1;
    return 0;
}
static int Vec_VecSortCompare2( Vec_Ptr_t ** pp1, Vec_Ptr_t ** pp2 )
{
    if ( Vec_PtrSize(*pp1) > Vec_PtrSize(*pp2) )
        return -1;
    if ( Vec_PtrSize(*pp1) < Vec_PtrSize(*pp2) )
        return 1;
    return 0;
}
# 554 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecSort( Vec_Vec_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_VecSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_VecSortCompare1 );
}
# 575 "/app/abc/src/misc/vec/vecVec.h"
static int Vec_VecSortCompare3( Vec_Int_t ** pp1, Vec_Int_t ** pp2 )
{
    if ( Vec_IntEntry(*pp1,0) < Vec_IntEntry(*pp2,0) )
        return -1;
    if ( Vec_IntEntry(*pp1,0) > Vec_IntEntry(*pp2,0) )
        return 1;
    return 0;
}
static int Vec_VecSortCompare4( Vec_Int_t ** pp1, Vec_Int_t ** pp2 )
{
    if ( Vec_IntEntry(*pp1,0) > Vec_IntEntry(*pp2,0) )
        return -1;
    if ( Vec_IntEntry(*pp1,0) < Vec_IntEntry(*pp2,0) )
        return 1;
    return 0;
}
# 603 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecSortByFirstInt( Vec_Vec_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_VecSortCompare4 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(void *),
                (int (*)(const void *, const void *)) Vec_VecSortCompare3 );
}
# 624 "/app/abc/src/misc/vec/vecVec.h"
static inline void Vec_VecPrintInt( Vec_Vec_t * p, int fSkipSingles )
{
    int i, k, Entry;
    for ( i = 0; i < Vec_VecSize(p); i++ ) for ( k = 0; (k < Vec_IntSize(Vec_VecEntryInt(p, i))) && (((Entry) = Vec_IntEntry(Vec_VecEntryInt(p, i), k)), 1); k++ )
    {
        if ( fSkipSingles && Vec_VecLevelSize(p, i) == 1 )
            break;
        if ( k == 0 )
            printf( " %4d : {", i );
        printf( " %d", Entry );
        if ( k == Vec_VecLevelSize(p, i) - 1 )
            printf( " }\n" );
    }
}


# 36 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecAtt.h" 1
# 31 "/app/abc/src/misc/vec/vecAtt.h"








typedef enum {
    VEC_ATTR_NONE = 0,
    VEC_ATTR_COPY,
    VEC_ATTR_LOCAL_AIG,
    VEC_ATTR_LOCAL_SOP,
    VEC_ATTR_LOCAL_BDD,
    VEC_ATTR_GLOBAL_AIG,
    VEC_ATTR_GLOBAL_SOP,
    VEC_ATTR_GLOBAL_BDD,
    VEC_ATTR_LEVEL,
    VEC_ATTR_LEVEL_REV,
    VEC_ATTR_RETIME_LAG,
    VEC_ATTR_FRAIG,
    VEC_ATTR_MVVAR,
    VEC_ATTR_DATA1,
    VEC_ATTR_DATA2,
    VEC_ATTR_TOTAL_NUM
} Vec_AttrType_t;





typedef struct Vec_Att_t_ Vec_Att_t;
struct Vec_Att_t_
{

    int nCap;


    void ** pArrayPtr;

    void * pMan;
    void (*pFuncFreeMan) (void *);
    void*(*pFuncStartObj)(void *);
    void (*pFuncFreeObj) (void *, void *);
};
# 96 "/app/abc/src/misc/vec/vecAtt.h"
static inline Vec_Att_t * Vec_AttAlloc(
    int nSize, void * pMan,
    void (*pFuncFreeMan) (void *),
    void*(*pFuncStartObj)(void *),
    void (*pFuncFreeObj) (void *, void *) )
{
    Vec_Att_t * p;
    p = ((Vec_Att_t *) malloc(sizeof(Vec_Att_t) * (size_t)(1)));
    memset( p, 0, sizeof(Vec_Att_t) );
    p->pMan = pMan;
    p->pFuncFreeMan = pFuncFreeMan;
    p->pFuncStartObj = pFuncStartObj;
    p->pFuncFreeObj = pFuncFreeObj;
    p->nCap = nSize? nSize : 16;
    p->pArrayPtr = ((void * *) malloc(sizeof(void *) * (size_t)(p->nCap)));
    memset( p->pArrayPtr, 0, sizeof(void *) * (size_t)p->nCap );
    return p;
}
# 126 "/app/abc/src/misc/vec/vecAtt.h"
static inline void * Vec_AttFree( Vec_Att_t * p, int fFreeMan )
{
    void * pMan;
    if ( p == 
# 129 "/app/abc/src/misc/vec/vecAtt.h" 3 4
             ((void *)0) 
# 129 "/app/abc/src/misc/vec/vecAtt.h"
                  )
        return 
# 130 "/app/abc/src/misc/vec/vecAtt.h" 3 4
              ((void *)0)
# 130 "/app/abc/src/misc/vec/vecAtt.h"
                  ;

    if ( p->pFuncFreeObj )
    {
        int i;
        for ( i = 0; i < p->nCap; i++ )
            if ( p->pArrayPtr[i] )
                p->pFuncFreeObj( p->pMan, p->pArrayPtr[i] );
    }

    pMan = fFreeMan? 
# 140 "/app/abc/src/misc/vec/vecAtt.h" 3 4
                    ((void *)0) 
# 140 "/app/abc/src/misc/vec/vecAtt.h"
                         : p->pMan;
    if ( p->pMan && fFreeMan )
        p->pFuncFreeMan( p->pMan );
    ((p->pArrayPtr) ? (free((char *) (p->pArrayPtr)), (p->pArrayPtr) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
    return pMan;
}
# 159 "/app/abc/src/misc/vec/vecAtt.h"
static inline void Vec_AttClear( Vec_Att_t * p )
{

    if ( p->pFuncFreeObj )
    {
        int i;
        if ( p->pFuncFreeObj )
            for ( i = 0; i < p->nCap; i++ )
                if ( p->pArrayPtr[i] )
                    p->pFuncFreeObj( p->pMan, p->pArrayPtr[i] );
    }
    memset( p->pArrayPtr, 0, sizeof(void *) * (size_t)p->nCap );
}
# 184 "/app/abc/src/misc/vec/vecAtt.h"
static inline void Vec_AttFreeEntry( Vec_Att_t * p, int i )
{
    if ( i >= p->nCap )
        return;
    if ( p->pMan )
    {
        if ( p->pArrayPtr[i] && p->pFuncFreeObj )
            p->pFuncFreeObj( p->pMan, (void *)p->pArrayPtr[i] );
    }
    p->pArrayPtr[i] = 
# 193 "/app/abc/src/misc/vec/vecAtt.h" 3 4
                     ((void *)0)
# 193 "/app/abc/src/misc/vec/vecAtt.h"
                         ;
}
# 207 "/app/abc/src/misc/vec/vecAtt.h"
static inline void Vec_AttGrow( Vec_Att_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArrayPtr = ((p->pArrayPtr) ? ((void * *) realloc((char *)(p->pArrayPtr), sizeof(void *) * (size_t)(nCapMin))) : ((void * *) malloc(sizeof(void *) * (size_t)(nCapMin))));
    memset( p->pArrayPtr + p->nCap, 0, sizeof(void *) * (size_t)(nCapMin - p->nCap) );
    p->nCap = nCapMin;
}
# 227 "/app/abc/src/misc/vec/vecAtt.h"
static inline void Vec_AttWriteEntry( Vec_Att_t * p, int i, void * pEntry )
{
    
# 229 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ((void) sizeof ((
# 229 "/app/abc/src/misc/vec/vecAtt.h"
   p->pArrayPtr
# 229 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 229 "/app/abc/src/misc/vec/vecAtt.h"
   p->pArrayPtr
# 229 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ) ; else __assert_fail (
# 229 "/app/abc/src/misc/vec/vecAtt.h"
   "p->pArrayPtr"
# 229 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   , "/app/abc/src/misc/vec/vecAtt.h", 229, __extension__ __PRETTY_FUNCTION__); }))
# 229 "/app/abc/src/misc/vec/vecAtt.h"
                         ;
    
# 230 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ((void) sizeof ((
# 230 "/app/abc/src/misc/vec/vecAtt.h"
   p->pFuncStartObj == 
# 230 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 230 "/app/abc/src/misc/vec/vecAtt.h"
   p->pFuncStartObj == 
# 230 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ((void *)0)) ; else __assert_fail (
# 230 "/app/abc/src/misc/vec/vecAtt.h"
   "p->pFuncStartObj == NULL"
# 230 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   , "/app/abc/src/misc/vec/vecAtt.h", 230, __extension__ __PRETTY_FUNCTION__); }))
# 230 "/app/abc/src/misc/vec/vecAtt.h"
                                     ;
    if ( i >= p->nCap )
        Vec_AttGrow( p, (2 * p->nCap > i)? 2 * p->nCap : i + 10 );
    p->pArrayPtr[i] = pEntry;
}
# 247 "/app/abc/src/misc/vec/vecAtt.h"
static inline void * Vec_AttEntry( Vec_Att_t * p, int i )
{
    
# 249 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ((void) sizeof ((
# 249 "/app/abc/src/misc/vec/vecAtt.h"
   p->pArrayPtr
# 249 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 249 "/app/abc/src/misc/vec/vecAtt.h"
   p->pArrayPtr
# 249 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   ) ; else __assert_fail (
# 249 "/app/abc/src/misc/vec/vecAtt.h"
   "p->pArrayPtr"
# 249 "/app/abc/src/misc/vec/vecAtt.h" 3 4
   , "/app/abc/src/misc/vec/vecAtt.h", 249, __extension__ __PRETTY_FUNCTION__); }))
# 249 "/app/abc/src/misc/vec/vecAtt.h"
                         ;
    if ( i >= p->nCap )
        Vec_AttGrow( p, (2 * p->nCap > i)? 2 * p->nCap : i + 10 );
    if ( p->pArrayPtr[i] == 
# 252 "/app/abc/src/misc/vec/vecAtt.h" 3 4
                           ((void *)0) 
# 252 "/app/abc/src/misc/vec/vecAtt.h"
                                && p->pFuncStartObj )
        p->pArrayPtr[i] = p->pFuncStartObj( p->pMan );
    return p->pArrayPtr[i];
}
# 268 "/app/abc/src/misc/vec/vecAtt.h"
static inline void * Vec_AttMan( Vec_Att_t * p )
{
    return p->pMan;
}
# 284 "/app/abc/src/misc/vec/vecAtt.h"
static inline void ** Vec_AttArray( Vec_Att_t * p )
{
    return p->pArrayPtr;
}




# 37 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecWrd.h" 1
# 31 "/app/abc/src/misc/vec/vecWrd.h"

# 42 "/app/abc/src/misc/vec/vecWrd.h"
typedef struct Vec_Wrd_t_ Vec_Wrd_t;
struct Vec_Wrd_t_
{
    int nCap;
    int nSize;
    word * pArray;
};
# 82 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdAlloc( int nCap )
{
    Vec_Wrd_t * p;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 16 )
        nCap = 16;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((word *) malloc(sizeof(word) * (size_t)(p->nCap))) : 
# 90 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                                                     ((void *)0)
# 90 "/app/abc/src/misc/vec/vecWrd.h"
                                                         ;
    return p;
}
static inline Vec_Wrd_t * Vec_WrdAllocExact( int nCap )
{
    Vec_Wrd_t * p;
    
# 96 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 96 "/app/abc/src/misc/vec/vecWrd.h"
   nCap >= 0
# 96 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 96 "/app/abc/src/misc/vec/vecWrd.h"
   nCap >= 0
# 96 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 96 "/app/abc/src/misc/vec/vecWrd.h"
   "nCap >= 0"
# 96 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 96, __extension__ __PRETTY_FUNCTION__); }))
# 96 "/app/abc/src/misc/vec/vecWrd.h"
                      ;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((word *) malloc(sizeof(word) * (size_t)(p->nCap))) : 
# 100 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                                                     ((void *)0)
# 100 "/app/abc/src/misc/vec/vecWrd.h"
                                                         ;
    return p;
}
# 115 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdStart( int nSize )
{
    Vec_Wrd_t * p;
    p = Vec_WrdAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0, sizeof(word) * (size_t)nSize );
    return p;
}
# 135 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdStartFull( int nSize )
{
    Vec_Wrd_t * p;
    p = Vec_WrdAlloc( nSize );
    p->nSize = nSize;
    memset( p->pArray, 0xff, sizeof(word) * (size_t)nSize );
    return p;
}
# 155 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdStartNatural( int nSize )
{
    Vec_Wrd_t * p;
    int i;
    p = Vec_WrdAlloc( nSize );
    p->nSize = nSize;
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = i;
    return p;
}
static inline Vec_Wrd_t * Vec_WrdStartRandom( int nSize )
{
    Vec_Wrd_t * vSims = Vec_WrdStart( nSize ); int i;
    for ( i = 0; i < nSize; i++ )
        vSims->pArray[i] = Abc_RandomW(0);
    return vSims;
}
static inline Vec_Wrd_t * Vec_WrdStartTruthTables( int nVars )
{
    Vec_Wrd_t * p;
    unsigned Masks[5] = { 0xAAAAAAAA, 0xCCCCCCCC, 0xF0F0F0F0, 0xFF00FF00, 0xFFFF0000 };
    int i, k, nWords;
    nWords = nVars <= 6 ? 1 : (1 << (nVars - 6));
    p = Vec_WrdStart( nWords * nVars );
    for ( i = 0; i < nVars; i++ )
    {
        unsigned * pTruth = (unsigned *)(p->pArray + nWords * i);
        if ( i < 5 )
        {
            for ( k = 0; k < 2*nWords; k++ )
                pTruth[k] = Masks[i];
        }
        else
        {
            for ( k = 0; k < 2*nWords; k++ )
                if ( k & (1 << (i-5)) )
                    pTruth[k] = ~(unsigned)0;
                else
                    pTruth[k] = 0;
        }
    }
    return p;
}
static inline Vec_Wrd_t * Vec_WrdStartTruthTablesRev( int nVars )
{
    Vec_Wrd_t * p;
    unsigned Masks[5] = { 0xAAAAAAAA, 0xCCCCCCCC, 0xF0F0F0F0, 0xFF00FF00, 0xFFFF0000 };
    int i, k, nWords;
    nWords = nVars <= 6 ? 1 : (1 << (nVars - 6));
    p = Vec_WrdStart( nWords * nVars );
    for ( i = 0; i < nVars; i++ )
    {
        unsigned * pTruth = (unsigned *)(p->pArray + nWords * (nVars-1-i));
        if ( i < 5 )
        {
            for ( k = 0; k < 2*nWords; k++ )
                pTruth[k] = Masks[i];
        }
        else
        {
            for ( k = 0; k < 2*nWords; k++ )
                if ( k & (1 << (i-5)) )
                    pTruth[k] = ~(unsigned)0;
                else
                    pTruth[k] = 0;
        }
    }
    return p;
}
static inline int Vec_WrdShiftOne( Vec_Wrd_t * p, int nWords )
{
    int i, nObjs = p->nSize/nWords;
    
# 227 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 227 "/app/abc/src/misc/vec/vecWrd.h"
   nObjs * nWords == p->nSize
# 227 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 227 "/app/abc/src/misc/vec/vecWrd.h"
   nObjs * nWords == p->nSize
# 227 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 227 "/app/abc/src/misc/vec/vecWrd.h"
   "nObjs * nWords == p->nSize"
# 227 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 227, __extension__ __PRETTY_FUNCTION__); }))
# 227 "/app/abc/src/misc/vec/vecWrd.h"
                                       ;
    for ( i = 0; i < nObjs; i++ )
        p->pArray[i*nWords] <<= 1;
    return nObjs;
}
# 244 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdAllocArray( word * pArray, int nSize )
{
    Vec_Wrd_t * p;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = pArray;
    return p;
}
# 265 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdAllocArrayCopy( word * pArray, int nSize )
{
    Vec_Wrd_t * p;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    p->nSize = nSize;
    p->nCap = nSize;
    p->pArray = ((word *) malloc(sizeof(word) * (size_t)(nSize)));
    memcpy( p->pArray, pArray, sizeof(word) * (size_t)nSize );
    return p;
}
# 287 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdDup( Vec_Wrd_t * pVec )
{
    Vec_Wrd_t * p;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nSize;
    p->pArray = p->nCap? ((word *) malloc(sizeof(word) * (size_t)(p->nCap))) : 
# 293 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                                                     ((void *)0)
# 293 "/app/abc/src/misc/vec/vecWrd.h"
                                                         ;
    memcpy( p->pArray, pVec->pArray, sizeof(word) * (size_t)pVec->nSize );
    return p;
}
# 309 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdDupArray( Vec_Wrd_t * pVec )
{
    Vec_Wrd_t * p;
    p = ((Vec_Wrd_t *) malloc(sizeof(Vec_Wrd_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nCap;
    p->pArray = pVec->pArray;
    pVec->nSize = 0;
    pVec->nCap = 0;
    pVec->pArray = 
# 318 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                  ((void *)0)
# 318 "/app/abc/src/misc/vec/vecWrd.h"
                      ;
    return p;
}
# 333 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdErase( Vec_Wrd_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_WrdFree( Vec_Wrd_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 356 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdFreeP( Vec_Wrd_t ** p )
{
    if ( *p == 
# 358 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0) 
# 358 "/app/abc/src/misc/vec/vecWrd.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 375 "/app/abc/src/misc/vec/vecWrd.h"
static inline word * Vec_WrdReleaseArray( Vec_Wrd_t * p )
{
    word * pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 380 "/app/abc/src/misc/vec/vecWrd.h" 3 4
               ((void *)0)
# 380 "/app/abc/src/misc/vec/vecWrd.h"
                   ;
    return pArray;
}
# 395 "/app/abc/src/misc/vec/vecWrd.h"
static inline word * Vec_WrdArray( Vec_Wrd_t * p )
{
    return p->pArray;
}
static inline word * Vec_WrdLimit( Vec_Wrd_t * p )
{
    return p->pArray + p->nSize;
}
# 415 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdSize( Vec_Wrd_t * p )
{
    return p->nSize;
}
static inline int Vec_WrdChangeSize( Vec_Wrd_t * p, int Shift )
{
    return p->nSize += Shift;
}
# 435 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdCap( Vec_Wrd_t * p )
{
    return p->nCap;
}
# 451 "/app/abc/src/misc/vec/vecWrd.h"
static inline double Vec_WrdMemory( Vec_Wrd_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(word) * (size_t)p->nCap + sizeof(Vec_Wrd_t);
}
# 467 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdEntry( Vec_Wrd_t * p, int i )
{
    
# 469 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 469 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 469 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 469 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 469 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 469 "/app/abc/src/misc/vec/vecWrd.h"
   "i >= 0 && i < p->nSize"
# 469 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 469, __extension__ __PRETTY_FUNCTION__); }))
# 469 "/app/abc/src/misc/vec/vecWrd.h"
                                   ;
    return p->pArray[i];
}
# 484 "/app/abc/src/misc/vec/vecWrd.h"
static inline word * Vec_WrdEntryP( Vec_Wrd_t * p, int i )
{
    
# 486 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 486 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 486 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 486 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 486 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 486 "/app/abc/src/misc/vec/vecWrd.h"
   "i >= 0 && i < p->nSize"
# 486 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 486, __extension__ __PRETTY_FUNCTION__); }))
# 486 "/app/abc/src/misc/vec/vecWrd.h"
                                   ;
    return p->pArray + i;
}
# 501 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdWriteEntry( Vec_Wrd_t * p, int i, word Entry )
{
    
# 503 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 503 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 503 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 503 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 503 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 503 "/app/abc/src/misc/vec/vecWrd.h"
   "i >= 0 && i < p->nSize"
# 503 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 503, __extension__ __PRETTY_FUNCTION__); }))
# 503 "/app/abc/src/misc/vec/vecWrd.h"
                                   ;
    p->pArray[i] = Entry;
}
# 518 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdAddToEntry( Vec_Wrd_t * p, int i, word Addition )
{
    
# 520 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 520 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 520 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 520 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < p->nSize
# 520 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 520 "/app/abc/src/misc/vec/vecWrd.h"
   "i >= 0 && i < p->nSize"
# 520 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 520, __extension__ __PRETTY_FUNCTION__); }))
# 520 "/app/abc/src/misc/vec/vecWrd.h"
                                   ;
    return p->pArray[i] += Addition;
}
# 535 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdEntryLast( Vec_Wrd_t * p )
{
    
# 537 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 537 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize > 0
# 537 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 537 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize > 0
# 537 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 537 "/app/abc/src/misc/vec/vecWrd.h"
   "p->nSize > 0"
# 537 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 537, __extension__ __PRETTY_FUNCTION__); }))
# 537 "/app/abc/src/misc/vec/vecWrd.h"
                         ;
    return p->pArray[p->nSize-1];
}
# 552 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdGrow( Vec_Wrd_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((word *) realloc((char *)(p->pArray), sizeof(word) * (size_t)(nCapMin))) : ((word *) malloc(sizeof(word) * (size_t)(nCapMin))));
    
# 557 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 557 "/app/abc/src/misc/vec/vecWrd.h"
   p->pArray
# 557 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 557 "/app/abc/src/misc/vec/vecWrd.h"
   p->pArray
# 557 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 557 "/app/abc/src/misc/vec/vecWrd.h"
   "p->pArray"
# 557 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 557, __extension__ __PRETTY_FUNCTION__); }))
# 557 "/app/abc/src/misc/vec/vecWrd.h"
                      ;
    p->nCap = nCapMin;
}
# 572 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdFill( Vec_Wrd_t * p, int nSize, word Fill )
{
    int i;
    Vec_WrdGrow( p, nSize );
    for ( i = 0; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 592 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdFillExtra( Vec_Wrd_t * p, int nSize, word Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_WrdGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_WrdGrow( p, 2 * p->nCap );
    for ( i = p->nSize; i < nSize; i++ )
        p->pArray[i] = Fill;
    p->nSize = nSize;
}
# 617 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdGetEntry( Vec_Wrd_t * p, int i )
{
    Vec_WrdFillExtra( p, i + 1, 0 );
    return Vec_WrdEntry( p, i );
}
# 634 "/app/abc/src/misc/vec/vecWrd.h"
static inline word * Vec_WrdGetEntryP( Vec_Wrd_t * p, int i )
{
    Vec_WrdFillExtra( p, i + 1, 0 );
    return Vec_WrdEntryP( p, i );
}
# 651 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdSetEntry( Vec_Wrd_t * p, int i, word Entry )
{
    Vec_WrdFillExtra( p, i + 1, 0 );
    Vec_WrdWriteEntry( p, i, Entry );
}
# 668 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdShrink( Vec_Wrd_t * p, int nSizeNew )
{
    
# 670 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 670 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize >= nSizeNew
# 670 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 670 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize >= nSizeNew
# 670 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 670 "/app/abc/src/misc/vec/vecWrd.h"
   "p->nSize >= nSizeNew"
# 670 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 670, __extension__ __PRETTY_FUNCTION__); }))
# 670 "/app/abc/src/misc/vec/vecWrd.h"
                                 ;
    p->nSize = nSizeNew;
}
# 685 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdClear( Vec_Wrd_t * p )
{
    p->nSize = 0;
}
# 701 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdPush( Vec_Wrd_t * p, word Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_WrdGrow( p, 16 );
        else
            Vec_WrdGrow( p, 2 * p->nCap );
    }
    p->pArray[p->nSize++] = Entry;
}
static inline void Vec_WrdPushTwo( Vec_Wrd_t * p, word Entry1, word Entry2 )
{
    Vec_WrdPush( p, Entry1 );
    Vec_WrdPush( p, Entry2 );
}
static inline void Vec_WrdPushThree( Vec_Wrd_t * p, word Entry1, word Entry2, word Entry3 )
{
    Vec_WrdPush( p, Entry1 );
    Vec_WrdPush( p, Entry2 );
    Vec_WrdPush( p, Entry3 );
}
static inline void Vec_WrdPushFour( Vec_Wrd_t * p, word Entry1, word Entry2, word Entry3, word Entry4 )
{
    Vec_WrdPush( p, Entry1 );
    Vec_WrdPush( p, Entry2 );
    Vec_WrdPush( p, Entry3 );
    Vec_WrdPush( p, Entry4 );
}
static inline void Vec_WrdPushArray( Vec_Wrd_t * p, word * pEntries, int nEntries )
{
    int i;
    for ( i = 0; i < nEntries; i++ )
        Vec_WrdPush( p, pEntries[i] );
}
# 748 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdPushFirst( Vec_Wrd_t * p, word Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_WrdGrow( p, 16 );
        else
            Vec_WrdGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize - 1; i >= 1; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[0] = Entry;
}
# 775 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdPushOrder( Vec_Wrd_t * p, word Entry )
{
    int i;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_WrdGrow( p, 16 );
        else
            Vec_WrdGrow( p, 2 * p->nCap );
    }
    p->nSize++;
    for ( i = p->nSize-2; i >= 0; i-- )
        if ( p->pArray[i] > Entry )
            p->pArray[i+1] = p->pArray[i];
        else
            break;
    p->pArray[i+1] = Entry;
}
# 805 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdPushUniqueOrder( Vec_Wrd_t * p, word Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_WrdPushOrder( p, Entry );
    return 0;
}
# 826 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdPushUnique( Vec_Wrd_t * p, word Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return 1;
    Vec_WrdPush( p, Entry );
    return 0;
}
# 847 "/app/abc/src/misc/vec/vecWrd.h"
static inline word * Vec_WrdFetch( Vec_Wrd_t * p, int nWords )
{
    if ( nWords == 0 )
        return 
# 850 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 850 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    
# 851 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 851 "/app/abc/src/misc/vec/vecWrd.h"
   nWords > 0
# 851 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 851 "/app/abc/src/misc/vec/vecWrd.h"
   nWords > 0
# 851 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 851 "/app/abc/src/misc/vec/vecWrd.h"
   "nWords > 0"
# 851 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 851, __extension__ __PRETTY_FUNCTION__); }))
# 851 "/app/abc/src/misc/vec/vecWrd.h"
                       ;
    p->nSize += nWords;
    if ( p->nSize > p->nCap )
    {

        return 
# 856 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 856 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    }
    return p->pArray + p->nSize - nWords;
}
# 872 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdPop( Vec_Wrd_t * p )
{
    
# 874 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 874 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize > 0
# 874 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 874 "/app/abc/src/misc/vec/vecWrd.h"
   p->nSize > 0
# 874 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 874 "/app/abc/src/misc/vec/vecWrd.h"
   "p->nSize > 0"
# 874 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 874, __extension__ __PRETTY_FUNCTION__); }))
# 874 "/app/abc/src/misc/vec/vecWrd.h"
                         ;
    return p->pArray[--p->nSize];
}
# 889 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdFind( Vec_Wrd_t * p, word Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            return i;
    return -1;
}
# 909 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdRemove( Vec_Wrd_t * p, word Entry )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == Entry )
            break;
    if ( i == p->nSize )
        return 0;
    
# 917 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 917 "/app/abc/src/misc/vec/vecWrd.h"
   i < p->nSize
# 917 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 917 "/app/abc/src/misc/vec/vecWrd.h"
   i < p->nSize
# 917 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 917 "/app/abc/src/misc/vec/vecWrd.h"
   "i < p->nSize"
# 917 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 917, __extension__ __PRETTY_FUNCTION__); }))
# 917 "/app/abc/src/misc/vec/vecWrd.h"
                         ;
    for ( i++; i < p->nSize; i++ )
        p->pArray[i-1] = p->pArray[i];
    p->nSize--;
    return 1;
}
# 935 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdInsert( Vec_Wrd_t * p, int iHere, word Entry )
{
    int i;
    
# 938 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 938 "/app/abc/src/misc/vec/vecWrd.h"
   iHere >= 0 && iHere < p->nSize
# 938 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 938 "/app/abc/src/misc/vec/vecWrd.h"
   iHere >= 0 && iHere < p->nSize
# 938 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 938 "/app/abc/src/misc/vec/vecWrd.h"
   "iHere >= 0 && iHere < p->nSize"
# 938 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 938, __extension__ __PRETTY_FUNCTION__); }))
# 938 "/app/abc/src/misc/vec/vecWrd.h"
                                           ;
    Vec_WrdPush( p, 0 );
    for ( i = p->nSize - 1; i > iHere; i-- )
        p->pArray[i] = p->pArray[i-1];
    p->pArray[i] = Entry;
}
static inline void Vec_WrdDrop( Vec_Wrd_t * p, int i )
{
    int k;
    
# 947 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 947 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < Vec_WrdSize(p)
# 947 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 947 "/app/abc/src/misc/vec/vecWrd.h"
   i >= 0 && i < Vec_WrdSize(p)
# 947 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 947 "/app/abc/src/misc/vec/vecWrd.h"
   "i >= 0 && i < Vec_WrdSize(p)"
# 947 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 947, __extension__ __PRETTY_FUNCTION__); }))
# 947 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    p->nSize--;
    for ( k = i; k < p->nSize; k++ )
        p->pArray[k] = p->pArray[k+1];
}
# 964 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdFindMax( Vec_Wrd_t * p )
{
    word Best;
    int i;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best < p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
# 988 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdFindMin( Vec_Wrd_t * p )
{
    word Best;
    int i;
    if ( p->nSize == 0 )
        return 0;
    Best = p->pArray[0];
    for ( i = 1; i < p->nSize; i++ )
        if ( Best > p->pArray[i] )
            Best = p->pArray[i];
    return Best;
}
# 1012 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdReverseOrder( Vec_Wrd_t * p )
{
    word Temp;
    int i;
    for ( i = 0; i < p->nSize/2; i++ )
    {
        Temp = p->pArray[i];
        p->pArray[i] = p->pArray[p->nSize-1-i];
        p->pArray[p->nSize-1-i] = Temp;
    }
}
# 1035 "/app/abc/src/misc/vec/vecWrd.h"
static inline Vec_Wrd_t * Vec_WrdInvert( Vec_Wrd_t * p, word Fill )
{
    int i;
    word Entry;
    Vec_Wrd_t * vRes = Vec_WrdAlloc( 0 );
    Vec_WrdFill( vRes, Vec_WrdFindMax(p) + 1, Fill );
    for ( i = 0; (i < Vec_WrdSize(p)) && (((Entry) = Vec_WrdEntry(p, i)), 1); i++ )
        if ( Entry != Fill )
            Vec_WrdWriteEntry( vRes, Entry, i );
    return vRes;
}
# 1058 "/app/abc/src/misc/vec/vecWrd.h"
static inline word Vec_WrdSum( Vec_Wrd_t * p )
{
    word Counter = 0;
    int i;
    for ( i = 0; i < p->nSize; i++ )
        Counter += p->pArray[i];
    return Counter;
}
# 1078 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdCountZero( Vec_Wrd_t * p )
{
    int i, Counter = 0;
    for ( i = 0; i < p->nSize; i++ )
        Counter += (p->pArray[i] == 0);
    return Counter;
}
# 1097 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdEqual( Vec_Wrd_t * p1, Vec_Wrd_t * p2 )
{
    int i;
    if ( p1->nSize != p2->nSize )
        return 0;
    for ( i = 0; i < p1->nSize; i++ )
        if ( p1->pArray[i] != p2->pArray[i] )
            return 0;
    return 1;
}
# 1119 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdCountCommon( Vec_Wrd_t * p1, Vec_Wrd_t * p2 )
{
    Vec_Wrd_t * vTemp;
    word Entry;
    int i, Counter = 0;
    if ( Vec_WrdSize(p1) < Vec_WrdSize(p2) )
        vTemp = p1, p1 = p2, p2 = vTemp;
    
# 1126 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1126 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p1) >= Vec_WrdSize(p2)
# 1126 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1126 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p1) >= Vec_WrdSize(p2)
# 1126 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1126 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p1) >= Vec_WrdSize(p2)"
# 1126 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1126, __extension__ __PRETTY_FUNCTION__); }))
# 1126 "/app/abc/src/misc/vec/vecWrd.h"
                                               ;
    vTemp = Vec_WrdInvert( p2, -1 );
    Vec_WrdFillExtra( vTemp, Vec_WrdFindMax(p1) + 1, ~((word)0) );
    for ( i = 0; (i < Vec_WrdSize(p1)) && (((Entry) = Vec_WrdEntry(p1, i)), 1); i++ )
        if ( Vec_WrdEntry(vTemp, Entry) != ~((word)0) )
            Counter++;
    Vec_WrdFree( vTemp );
    return Counter;
}
# 1147 "/app/abc/src/misc/vec/vecWrd.h"
static int Vec_WrdSortCompare1( word * pp1, word * pp2 )
{

    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 1168 "/app/abc/src/misc/vec/vecWrd.h"
static int Vec_WrdSortCompare2( word * pp1, word * pp2 )
{

    if ( *pp1 > *pp2 )
        return -1;
    if ( *pp1 < *pp2 )
        return 1;
    return 0;
}
# 1189 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdSort( Vec_Wrd_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(word),
                (int (*)(const void *, const void *)) Vec_WrdSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(word),
                (int (*)(const void *, const void *)) Vec_WrdSortCompare1 );
}
# 1210 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdUniqify( Vec_Wrd_t * p )
{
    int i, k;
    if ( p->nSize < 2 )
        return;
    Vec_WrdSort( p, 0 );
    for ( i = k = 1; i < p->nSize; i++ )
        if ( p->pArray[i] != p->pArray[i-1] )
            p->pArray[k++] = p->pArray[i];
    p->nSize = k;
}
static inline int Vec_WrdUniqueCount( Vec_Wrd_t * vData, int nWordSize, Vec_Int_t ** pvMap )
{
    int Result;
    Vec_Int_t * vDataInt = (Vec_Int_t *)vData;
    vDataInt->nSize *= 2;
    vDataInt->nCap *= 2;
    Result = Vec_IntUniqueCount( vDataInt, 2 * nWordSize, pvMap );
    vDataInt->nSize /= 2;
    vDataInt->nCap /= 2;
    return Result;
}
static inline Vec_Wrd_t * Vec_WrdUniqifyHash( Vec_Wrd_t * vData, int nWordSize )
{
    Vec_Int_t * vResInt;
    Vec_Int_t * vDataInt = (Vec_Int_t *)vData;
    vDataInt->nSize *= 2;
    vDataInt->nCap *= 2;
    vResInt = Vec_IntUniqifyHash( vDataInt, 2 * nWordSize );
    vDataInt->nSize /= 2;
    vDataInt->nCap /= 2;
    vResInt->nSize /= 2;
    vResInt->nCap /= 2;
    return (Vec_Wrd_t *)vResInt;
}
# 1257 "/app/abc/src/misc/vec/vecWrd.h"
static inline int Vec_WrdTwoCountCommon( Vec_Wrd_t * vArr1, Vec_Wrd_t * vArr2 )
{
    word * pBeg1 = vArr1->pArray;
    word * pBeg2 = vArr2->pArray;
    word * pEnd1 = vArr1->pArray + vArr1->nSize;
    word * pEnd2 = vArr2->pArray + vArr2->nSize;
    int Counter = 0;
    while ( pBeg1 < pEnd1 && pBeg2 < pEnd2 )
    {
        if ( *pBeg1 == *pBeg2 )
            pBeg1++, pBeg2++, Counter++;
        else if ( *pBeg1 < *pBeg2 )
            pBeg1++;
        else
            pBeg2++;
    }
    return Counter;
}
# 1287 "/app/abc/src/misc/vec/vecWrd.h"
static int Vec_WrdSortCompareUnsigned( word * pp1, word * pp2 )
{
    if ( *pp1 < *pp2 )
        return -1;
    if ( *pp1 > *pp2 )
        return 1;
    return 0;
}
# 1307 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdSortUnsigned( Vec_Wrd_t * p )
{
    qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(word),
            (int (*)(const void *, const void *)) Vec_WrdSortCompareUnsigned );
}
# 1325 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdAppend( Vec_Wrd_t * vVec1, Vec_Wrd_t * vVec2 )
{
    word Entry; int i;
    for ( i = 0; (i < Vec_WrdSize(vVec2)) && (((Entry) = Vec_WrdEntry(vVec2, i)), 1); i++ )
        Vec_WrdPush( vVec1, Entry );
}
# 1343 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdDumpBoolOne( FILE * pFile, word * pSim, int nBits, int fReverse )
{
    int k;
    if ( fReverse )
        for ( k = nBits-1; k >= 0; k-- )
            fprintf( pFile, "%d", (int)((pSim[k/64] >> (k%64)) & 1) );
    else
        for ( k = 0; k < nBits; k++ )
            fprintf( pFile, "%d", (int)((pSim[k/64] >> (k%64)) & 1) );
    fprintf( pFile, "\n" );
}
static inline void Vec_WrdDumpBool( char * pFileName, Vec_Wrd_t * p, int nWords, int nBits, int fReverse, int fVerbose )
{
    int i, nNodes = Vec_WrdSize(p) / nWords;
    FILE * pFile = fopen( pFileName, "wb" );
    if ( pFile == 
# 1358 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                 ((void *)0) 
# 1358 "/app/abc/src/misc/vec/vecWrd.h"
                      )
    {
        printf( "Cannot open file \"%s\" for writing.\n", pFileName );
        return;
    }
    
# 1363 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1363 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1363 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1363 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1363 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1363 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p) % nWords == 0"
# 1363 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1363, __extension__ __PRETTY_FUNCTION__); }))
# 1363 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    for ( i = 0; i < nNodes; i++ )
        Vec_WrdDumpBoolOne( pFile, Vec_WrdEntryP(p, i*nWords), nBits, fReverse );
    fclose( pFile );
    if ( fVerbose )
        printf( "Written %d bits of simulation data for %d objects into file \"%s\".\n", nBits, Vec_WrdSize(p)/nWords, pFileName );
}
# 1382 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdPrintBin( Vec_Wrd_t * p, int nWords )
{
    int i, k, nNodes = Vec_WrdSize(p) / nWords;
    
# 1385 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1385 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1385 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1385 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1385 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1385 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p) % nWords == 0"
# 1385 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1385, __extension__ __PRETTY_FUNCTION__); }))
# 1385 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    printf( "The array contains %d bit-strings of %d bits:\n", nNodes, 64*nWords );
    for ( i = 0; i < nNodes; i++, printf("\n") )
        for ( k = 0; k < 64*nWords; k++ )
            printf( "%d", Abc_InfoHasBit((unsigned*)Vec_WrdEntryP(p, i*nWords), k) );
}
# 1403 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdDumpHexOne( FILE * pFile, word * pSim, int nWords )
{
    int k, Digit, nDigits = nWords*16;
    for ( k = 0; k < nDigits; k++ )
    {
        Digit = (int)((pSim[k/16] >> ((k%16) * 4)) & 15);
        if ( Digit < 10 )
            fprintf( pFile, "%d", Digit );
        else
            fprintf( pFile, "%c", 'A' + Digit-10 );
    }
    fprintf( pFile, "\n" );
}
static inline void Vec_WrdPrintHex( Vec_Wrd_t * p, int nWords )
{
    int i, nNodes = Vec_WrdSize(p) / nWords;
    
# 1419 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1419 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1419 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1419 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1419 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1419 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p) % nWords == 0"
# 1419 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1419, __extension__ __PRETTY_FUNCTION__); }))
# 1419 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    printf( "The array contains %d bit-strings of %d bits:\n", nNodes, 64*nWords );
    for ( i = 0; i < nNodes; i++ )
        Vec_WrdDumpHexOne( 
# 1422 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                          stdout
# 1422 "/app/abc/src/misc/vec/vecWrd.h"
                                , Vec_WrdEntryP(p, i*nWords), nWords );
}
static inline void Vec_WrdDumpHex( char * pFileName, Vec_Wrd_t * p, int nWords, int fVerbose )
{
    int i, nNodes = Vec_WrdSize(p) / nWords;
    FILE * pFile = fopen( pFileName, "wb" );
    if ( pFile == 
# 1428 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                 ((void *)0) 
# 1428 "/app/abc/src/misc/vec/vecWrd.h"
                      )
    {
        printf( "Cannot open file \"%s\" for writing.\n", pFileName );
        return;
    }
    
# 1433 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1433 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1433 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1433 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1433 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1433 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p) % nWords == 0"
# 1433 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1433, __extension__ __PRETTY_FUNCTION__); }))
# 1433 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    for ( i = 0; i < nNodes; i++ )
        Vec_WrdDumpHexOne( pFile, Vec_WrdEntryP(p, i*nWords), nWords );
    fclose( pFile );
    if ( fVerbose )
        printf( "Written %d words of simulation data for %d objects into file \"%s\".\n", nWords, Vec_WrdSize(p)/nWords, pFileName );
}
static inline int Vec_WrdReadHexOne( char c )
{
    int Digit = 0;
    if ( c >= '0' && c <= '9' )
        Digit = c - '0';
    else if ( c >= 'A' && c <= 'F' )
        Digit = c - 'A' + 10;
    else if ( c >= 'a' && c <= 'f' )
        Digit = c - 'a' + 10;
    else 
# 1449 "/app/abc/src/misc/vec/vecWrd.h" 3 4
        ((void) sizeof ((
# 1449 "/app/abc/src/misc/vec/vecWrd.h"
        0
# 1449 "/app/abc/src/misc/vec/vecWrd.h" 3 4
        ) ? 1 : 0), __extension__ ({ if (
# 1449 "/app/abc/src/misc/vec/vecWrd.h"
        0
# 1449 "/app/abc/src/misc/vec/vecWrd.h" 3 4
        ) ; else __assert_fail (
# 1449 "/app/abc/src/misc/vec/vecWrd.h"
        "0"
# 1449 "/app/abc/src/misc/vec/vecWrd.h" 3 4
        , "/app/abc/src/misc/vec/vecWrd.h", 1449, __extension__ __PRETTY_FUNCTION__); }))
# 1449 "/app/abc/src/misc/vec/vecWrd.h"
                   ;
    
# 1450 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1450 "/app/abc/src/misc/vec/vecWrd.h"
   Digit >= 0 && Digit < 16
# 1450 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1450 "/app/abc/src/misc/vec/vecWrd.h"
   Digit >= 0 && Digit < 16
# 1450 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1450 "/app/abc/src/misc/vec/vecWrd.h"
   "Digit >= 0 && Digit < 16"
# 1450 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1450, __extension__ __PRETTY_FUNCTION__); }))
# 1450 "/app/abc/src/misc/vec/vecWrd.h"
                                     ;
    return Digit;
}
static inline Vec_Wrd_t * Vec_WrdReadHex( char * pFileName, int * pnWords, int fVerbose )
{
    Vec_Wrd_t * p = 
# 1455 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                   ((void *)0)
# 1455 "/app/abc/src/misc/vec/vecWrd.h"
                       ;
    int c, nWords = -1, nChars = 0; word Num = 0;
    FILE * pFile = fopen( pFileName, "rb" );
    if ( pFile == 
# 1458 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                 ((void *)0) 
# 1458 "/app/abc/src/misc/vec/vecWrd.h"
                      )
    {
        printf( "Cannot open file \"%s\" for reading.\n", pFileName );
        return 
# 1461 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 1461 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    }
    p = Vec_WrdAlloc( 1000 );
    while ( (c = fgetc(pFile)) != 
# 1464 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                                 (-1) 
# 1464 "/app/abc/src/misc/vec/vecWrd.h"
                                     )
    {
        if ( c == '\r' || c == '\t' || c == ' ' )
            continue;
        if ( c == '\n' )
        {
            if ( nChars > 0 )
            {
                Vec_WrdPush( p, Num );
                nChars = 0;
                Num = 0;
            }
            if ( nWords == -1 && Vec_WrdSize(p) > 0 )
                nWords = Vec_WrdSize(p);
            continue;
        }
        Num |= (word)Vec_WrdReadHexOne((char)c) << (nChars * 4);
        if ( ++nChars < 16 )
            continue;
        Vec_WrdPush( p, Num );
        nChars = 0;
        Num = 0;
    }
    
# 1487 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ((void) sizeof ((
# 1487 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1487 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1487 "/app/abc/src/misc/vec/vecWrd.h"
   Vec_WrdSize(p) % nWords == 0
# 1487 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   ) ; else __assert_fail (
# 1487 "/app/abc/src/misc/vec/vecWrd.h"
   "Vec_WrdSize(p) % nWords == 0"
# 1487 "/app/abc/src/misc/vec/vecWrd.h" 3 4
   , "/app/abc/src/misc/vec/vecWrd.h", 1487, __extension__ __PRETTY_FUNCTION__); }))
# 1487 "/app/abc/src/misc/vec/vecWrd.h"
                                         ;
    fclose( pFile );
    if ( pnWords )
        *pnWords = nWords;
    if ( fVerbose )
        printf( "Read %d words of simulation data for %d objects.\n", nWords, Vec_WrdSize(p)/nWords );
    return p;
}
# 1507 "/app/abc/src/misc/vec/vecWrd.h"
static inline void Vec_WrdDumpBin( char * pFileName, Vec_Wrd_t * p, int fVerbose )
{
    int RetValue;
    FILE * pFile = fopen( pFileName, "wb" );
    if ( pFile == 
# 1511 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                 ((void *)0) 
# 1511 "/app/abc/src/misc/vec/vecWrd.h"
                      )
    {
        printf( "Cannot open file \"%s\" for writing.\n", pFileName );
        return;
    }
    RetValue = fwrite( Vec_WrdArray(p), 1, 8*Vec_WrdSize(p), pFile );
    fclose( pFile );
    if ( RetValue != 8*Vec_WrdSize(p) )
        printf( "Error reading data from file.\n" );
    if ( fVerbose )
        printf( "Written %d words of simulation data into file \"%s\".\n", Vec_WrdSize(p), pFileName );
}
static inline Vec_Wrd_t * Vec_WrdReadBin( char * pFileName, int fVerbose )
{
    Vec_Wrd_t * p = 
# 1525 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                   ((void *)0)
# 1525 "/app/abc/src/misc/vec/vecWrd.h"
                       ; int nSize, RetValue;
    FILE * pFile = fopen( pFileName, "rb" );
    if ( pFile == 
# 1527 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                 ((void *)0) 
# 1527 "/app/abc/src/misc/vec/vecWrd.h"
                      )
    {
        printf( "Cannot open file \"%s\" for reading.\n", pFileName );
        return 
# 1530 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 1530 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    }
    fseek( pFile, 0, 
# 1532 "/app/abc/src/misc/vec/vecWrd.h" 3 4
                    2 
# 1532 "/app/abc/src/misc/vec/vecWrd.h"
                             );
    nSize = ftell( pFile );
    if ( nSize == 0 )
    {
        printf( "The input file is empty.\n" );
        fclose( pFile );
        return 
# 1538 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 1538 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    }
    if ( nSize % 8 > 0 )
    {
        printf( "Cannot read file with simulation data that is not aligned at 8 bytes (remainder = %d).\n", nSize % 8 );
        fclose( pFile );
        return 
# 1544 "/app/abc/src/misc/vec/vecWrd.h" 3 4
              ((void *)0)
# 1544 "/app/abc/src/misc/vec/vecWrd.h"
                  ;
    }
    rewind( pFile );
    p = Vec_WrdStart( nSize/8 );
    RetValue = fread( Vec_WrdArray(p), 1, nSize, pFile );
    fclose( pFile );
    if ( RetValue != nSize )
        printf( "Error reading data from file.\n" );
    if ( fVerbose )
        printf( "Read %d words of simulation data from file \"%s\".\n", nSize/8, pFileName );
    return p;
}


# 38 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecBit.h" 1
# 31 "/app/abc/src/misc/vec/vecBit.h"

# 42 "/app/abc/src/misc/vec/vecBit.h"
typedef struct Vec_Bit_t_ Vec_Bit_t;
struct Vec_Bit_t_
{
    int nCap;
    int nSize;
    int * pArray;
};
# 80 "/app/abc/src/misc/vec/vecBit.h"
static inline Vec_Bit_t * Vec_BitAlloc( int nCap )
{
    Vec_Bit_t * p;
    nCap = (nCap >> 5) + ((nCap & 31) > 0);
    p = ((Vec_Bit_t *) malloc(sizeof(Vec_Bit_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap * 32;
    p->pArray = nCap? ((int *) malloc(sizeof(int) * (size_t)(nCap))) : 
# 87 "/app/abc/src/misc/vec/vecBit.h" 3 4
                                              ((void *)0)
# 87 "/app/abc/src/misc/vec/vecBit.h"
                                                  ;
    return p;
}
# 102 "/app/abc/src/misc/vec/vecBit.h"
static inline Vec_Bit_t * Vec_BitStart( int nSize )
{
    Vec_Bit_t * p;
    nSize = (nSize >> 5) + ((nSize & 31) > 0);
    p = Vec_BitAlloc( nSize * 32 );
    p->nSize = nSize * 32;
    memset( p->pArray, 0, sizeof(int) * (size_t)nSize );
    return p;
}
# 123 "/app/abc/src/misc/vec/vecBit.h"
static inline Vec_Bit_t * Vec_BitStartFull( int nSize )
{
    Vec_Bit_t * p;
    nSize = (nSize >> 5) + ((nSize & 31) > 0);
    p = Vec_BitAlloc( nSize * 32 );
    p->nSize = nSize * 32;
    memset( p->pArray, 0xff, sizeof(int) * (size_t)nSize );
    return p;
}
# 144 "/app/abc/src/misc/vec/vecBit.h"
static inline Vec_Bit_t * Vec_BitDup( Vec_Bit_t * pVec )
{
    Vec_Bit_t * p;
    
# 147 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 147 "/app/abc/src/misc/vec/vecBit.h"
   (pVec->nSize & 31) == 0
# 147 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 147 "/app/abc/src/misc/vec/vecBit.h"
   (pVec->nSize & 31) == 0
# 147 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 147 "/app/abc/src/misc/vec/vecBit.h"
   "(pVec->nSize & 31) == 0"
# 147 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 147, __extension__ __PRETTY_FUNCTION__); }))
# 147 "/app/abc/src/misc/vec/vecBit.h"
                                    ;
    p = ((Vec_Bit_t *) malloc(sizeof(Vec_Bit_t) * (size_t)(1)));
    p->nSize = pVec->nSize;
    p->nCap = pVec->nSize;
    p->pArray = p->nCap? ((int *) malloc(sizeof(int) * (size_t)(p->nCap >> 5))) : 
# 151 "/app/abc/src/misc/vec/vecBit.h" 3 4
                                                         ((void *)0)
# 151 "/app/abc/src/misc/vec/vecBit.h"
                                                             ;
    memcpy( p->pArray, pVec->pArray, sizeof(int) * (size_t)(p->nCap >> 5) );
    return p;
}
# 167 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitFree( Vec_Bit_t * p )
{
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 184 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitFreeP( Vec_Bit_t ** p )
{
    if ( *p == 
# 186 "/app/abc/src/misc/vec/vecBit.h" 3 4
              ((void *)0) 
# 186 "/app/abc/src/misc/vec/vecBit.h"
                   )
        return;
    (((*p)->pArray) ? (free((char *) ((*p)->pArray)), ((*p)->pArray) = 0) : 0);
    (((*p)) ? (free((char *) ((*p))), ((*p)) = 0) : 0);
}
# 203 "/app/abc/src/misc/vec/vecBit.h"
static inline int * Vec_BitReleaseArray( Vec_Bit_t * p )
{
    int * pArray = p->pArray;
    p->nCap = 0;
    p->nSize = 0;
    p->pArray = 
# 208 "/app/abc/src/misc/vec/vecBit.h" 3 4
               ((void *)0)
# 208 "/app/abc/src/misc/vec/vecBit.h"
                   ;
    return pArray;
}
# 223 "/app/abc/src/misc/vec/vecBit.h"
static inline int * Vec_BitArray( Vec_Bit_t * p )
{
    return p->pArray;
}
# 239 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitSize( Vec_Bit_t * p )
{
    return p->nSize;
}
# 255 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitCap( Vec_Bit_t * p )
{
    return p->nCap;
}
# 271 "/app/abc/src/misc/vec/vecBit.h"
static inline double Vec_BitMemory( Vec_Bit_t * p )
{
    return !p ? 0.0 : 1.0 * sizeof(int) * p->nCap + sizeof(Vec_Bit_t);
}
# 287 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitEntry( Vec_Bit_t * p, int i )
{
    
# 289 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 289 "/app/abc/src/misc/vec/vecBit.h"
   i >= 0 && i < p->nSize
# 289 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 289 "/app/abc/src/misc/vec/vecBit.h"
   i >= 0 && i < p->nSize
# 289 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 289 "/app/abc/src/misc/vec/vecBit.h"
   "i >= 0 && i < p->nSize"
# 289 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 289, __extension__ __PRETTY_FUNCTION__); }))
# 289 "/app/abc/src/misc/vec/vecBit.h"
                                   ;
    return (p->pArray[i >> 5] >> (i & 31)) & 1;
}
# 304 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitWriteEntry( Vec_Bit_t * p, int i, int Entry )
{
    
# 306 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 306 "/app/abc/src/misc/vec/vecBit.h"
   i >= 0 && i < p->nSize
# 306 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 306 "/app/abc/src/misc/vec/vecBit.h"
   i >= 0 && i < p->nSize
# 306 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 306 "/app/abc/src/misc/vec/vecBit.h"
   "i >= 0 && i < p->nSize"
# 306 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 306, __extension__ __PRETTY_FUNCTION__); }))
# 306 "/app/abc/src/misc/vec/vecBit.h"
                                   ;
    if ( Entry == 1 )
        p->pArray[i >> 5] |= (1 << (i & 31));
    else if ( Entry == 0 )
        p->pArray[i >> 5] &= ~(1 << (i & 31));
    else 
# 311 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ((void) sizeof ((
# 311 "/app/abc/src/misc/vec/vecBit.h"
        0
# 311 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ? 1 : 0), __extension__ ({ if (
# 311 "/app/abc/src/misc/vec/vecBit.h"
        0
# 311 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ; else __assert_fail (
# 311 "/app/abc/src/misc/vec/vecBit.h"
        "0"
# 311 "/app/abc/src/misc/vec/vecBit.h" 3 4
        , "/app/abc/src/misc/vec/vecBit.h", 311, __extension__ __PRETTY_FUNCTION__); }))
# 311 "/app/abc/src/misc/vec/vecBit.h"
                 ;
}
static inline int Vec_BitAddEntry( Vec_Bit_t * p, int i )
{
    if ( Vec_BitEntry(p, i) )
        return 1;
    Vec_BitWriteEntry( p, i, 1 );
    return 0;
}
# 332 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitEntryLast( Vec_Bit_t * p )
{
    
# 334 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 334 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize > 0
# 334 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 334 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize > 0
# 334 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 334 "/app/abc/src/misc/vec/vecBit.h"
   "p->nSize > 0"
# 334 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 334, __extension__ __PRETTY_FUNCTION__); }))
# 334 "/app/abc/src/misc/vec/vecBit.h"
                         ;
    return Vec_BitEntry( p, p->nSize-1 );
}
# 349 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitGrow( Vec_Bit_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    nCapMin = (nCapMin >> 5) + ((nCapMin & 31) > 0);
    p->pArray = ((p->pArray) ? ((int *) realloc((char *)(p->pArray), sizeof(int) * (size_t)(nCapMin))) : ((int *) malloc(sizeof(int) * (size_t)(nCapMin))));
    
# 355 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 355 "/app/abc/src/misc/vec/vecBit.h"
   p->pArray
# 355 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 355 "/app/abc/src/misc/vec/vecBit.h"
   p->pArray
# 355 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 355 "/app/abc/src/misc/vec/vecBit.h"
   "p->pArray"
# 355 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 355, __extension__ __PRETTY_FUNCTION__); }))
# 355 "/app/abc/src/misc/vec/vecBit.h"
                      ;
    p->nCap = nCapMin * 32;
}
# 370 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitFill( Vec_Bit_t * p, int nSize, int Fill )
{
    int i;
    Vec_BitGrow( p, nSize );
    nSize = (nSize >> 5) + ((nSize & 31) > 0);
    if ( Fill == 0 )
    {
        for ( i = 0; i < nSize; i++ )
            p->pArray[i] = 0;
    }
    else if ( Fill == 1 )
    {
        for ( i = 0; i < nSize; i++ )
            p->pArray[i] = ~0;
    }
    else 
# 385 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ((void) sizeof ((
# 385 "/app/abc/src/misc/vec/vecBit.h"
        0
# 385 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ? 1 : 0), __extension__ ({ if (
# 385 "/app/abc/src/misc/vec/vecBit.h"
        0
# 385 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ; else __assert_fail (
# 385 "/app/abc/src/misc/vec/vecBit.h"
        "0"
# 385 "/app/abc/src/misc/vec/vecBit.h" 3 4
        , "/app/abc/src/misc/vec/vecBit.h", 385, __extension__ __PRETTY_FUNCTION__); }))
# 385 "/app/abc/src/misc/vec/vecBit.h"
                   ;
    p->nSize = nSize * 32;
}
# 400 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitFillExtra( Vec_Bit_t * p, int nSize, int Fill )
{
    int i;
    if ( nSize <= p->nSize )
        return;
    if ( nSize > 2 * p->nCap )
        Vec_BitGrow( p, nSize );
    else if ( nSize > p->nCap )
        Vec_BitGrow( p, 2 * p->nCap );

    
# 410 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 410 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize < nSize
# 410 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 410 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize < nSize
# 410 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 410 "/app/abc/src/misc/vec/vecBit.h"
   "p->nSize < nSize"
# 410 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 410, __extension__ __PRETTY_FUNCTION__); }))
# 410 "/app/abc/src/misc/vec/vecBit.h"
                             ;
    if ( (p->nSize >> 5) == (nSize >> 5) )
    {
        unsigned Mask = (~(~0 << (nSize-p->nSize)) << p->nSize);
        if ( Fill == 1 )
            p->pArray[nSize >> 5] |= Mask;
        else if ( Fill == 0 )
            p->pArray[nSize >> 5] &= ~Mask;
        else 
# 418 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ((void) sizeof ((
# 418 "/app/abc/src/misc/vec/vecBit.h"
            0
# 418 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ) ? 1 : 0), __extension__ ({ if (
# 418 "/app/abc/src/misc/vec/vecBit.h"
            0
# 418 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ) ; else __assert_fail (
# 418 "/app/abc/src/misc/vec/vecBit.h"
            "0"
# 418 "/app/abc/src/misc/vec/vecBit.h" 3 4
            , "/app/abc/src/misc/vec/vecBit.h", 418, __extension__ __PRETTY_FUNCTION__); }))
# 418 "/app/abc/src/misc/vec/vecBit.h"
                       ;
    }
    else
    {
        unsigned Mask1 = (p->nSize & 31) ? ~0 << (p->nSize & 31) : 0;
        unsigned Mask2 = (nSize & 31) ? ~(~0 << (nSize & 31)) : 0;
        int w1 = (p->nSize >> 5);
        int w2 = (nSize >> 5);
        if ( Fill == 1 )
        {
            p->pArray[w1] |= Mask1;
            p->pArray[w2] |= Mask2;
            for ( i = w1 + 1; i < w2; i++ )
                p->pArray[i] = ~0;
        }
        else if ( Fill == 0 )
        {
            p->pArray[w1] &= ~Mask1;
            p->pArray[w2] &= ~Mask2;
            for ( i = w1 + 1; i < w2; i++ )
                p->pArray[i] = 0;
        }
        else 
# 440 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ((void) sizeof ((
# 440 "/app/abc/src/misc/vec/vecBit.h"
            0
# 440 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ) ? 1 : 0), __extension__ ({ if (
# 440 "/app/abc/src/misc/vec/vecBit.h"
            0
# 440 "/app/abc/src/misc/vec/vecBit.h" 3 4
            ) ; else __assert_fail (
# 440 "/app/abc/src/misc/vec/vecBit.h"
            "0"
# 440 "/app/abc/src/misc/vec/vecBit.h" 3 4
            , "/app/abc/src/misc/vec/vecBit.h", 440, __extension__ __PRETTY_FUNCTION__); }))
# 440 "/app/abc/src/misc/vec/vecBit.h"
                       ;
    }
    p->nSize = nSize;
}
# 456 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitGetEntry( Vec_Bit_t * p, int i )
{
    Vec_BitFillExtra( p, i + 1, 0 );
    return Vec_BitEntry( p, i );
}
# 473 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitSetEntry( Vec_Bit_t * p, int i, int Entry )
{
    Vec_BitFillExtra( p, i + 1, 0 );
    Vec_BitWriteEntry( p, i, Entry );
}
# 490 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitShrink( Vec_Bit_t * p, int nSizeNew )
{
    
# 492 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 492 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize >= nSizeNew
# 492 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 492 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize >= nSizeNew
# 492 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 492 "/app/abc/src/misc/vec/vecBit.h"
   "p->nSize >= nSizeNew"
# 492 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 492, __extension__ __PRETTY_FUNCTION__); }))
# 492 "/app/abc/src/misc/vec/vecBit.h"
                                 ;
    p->nSize = nSizeNew;
}
# 507 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitClear( Vec_Bit_t * p )
{
    p->nSize = 0;
}
# 523 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitPush( Vec_Bit_t * p, int Entry )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_BitGrow( p, 16 );
        else
            Vec_BitGrow( p, 2 * p->nCap );
    }
    if ( Entry == 1 )
        p->pArray[p->nSize >> 5] |= (1 << (p->nSize & 31));
    else if ( Entry == 0 )
        p->pArray[p->nSize >> 5] &= ~(1 << (p->nSize & 31));
    else 
# 536 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ((void) sizeof ((
# 536 "/app/abc/src/misc/vec/vecBit.h"
        0
# 536 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ? 1 : 0), __extension__ ({ if (
# 536 "/app/abc/src/misc/vec/vecBit.h"
        0
# 536 "/app/abc/src/misc/vec/vecBit.h" 3 4
        ) ; else __assert_fail (
# 536 "/app/abc/src/misc/vec/vecBit.h"
        "0"
# 536 "/app/abc/src/misc/vec/vecBit.h" 3 4
        , "/app/abc/src/misc/vec/vecBit.h", 536, __extension__ __PRETTY_FUNCTION__); }))
# 536 "/app/abc/src/misc/vec/vecBit.h"
                   ;
    p->nSize++;
}
# 551 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitPop( Vec_Bit_t * p )
{
    int Entry;
    
# 554 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ((void) sizeof ((
# 554 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize > 0
# 554 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 554 "/app/abc/src/misc/vec/vecBit.h"
   p->nSize > 0
# 554 "/app/abc/src/misc/vec/vecBit.h" 3 4
   ) ; else __assert_fail (
# 554 "/app/abc/src/misc/vec/vecBit.h"
   "p->nSize > 0"
# 554 "/app/abc/src/misc/vec/vecBit.h" 3 4
   , "/app/abc/src/misc/vec/vecBit.h", 554, __extension__ __PRETTY_FUNCTION__); }))
# 554 "/app/abc/src/misc/vec/vecBit.h"
                         ;
    Entry = Vec_BitEntryLast( p );
    p->nSize--;
    return Entry;
}
# 571 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitCountWord( unsigned uWord )
{
    uWord = (uWord & 0x55555555) + ((uWord>>1) & 0x55555555);
    uWord = (uWord & 0x33333333) + ((uWord>>2) & 0x33333333);
    uWord = (uWord & 0x0F0F0F0F) + ((uWord>>4) & 0x0F0F0F0F);
    uWord = (uWord & 0x00FF00FF) + ((uWord>>8) & 0x00FF00FF);
    return (uWord & 0x0000FFFF) + (uWord>>16);
}
# 591 "/app/abc/src/misc/vec/vecBit.h"
static inline int Vec_BitCount( Vec_Bit_t * p )
{
    unsigned * pArray = (unsigned *)p->pArray;
    int nWords = (p->nSize >> 5) + ((p->nSize & 31) > 0);
    int i, Counter = 0;
    if ( p->nSize & 31 )
    {
        
# 598 "/app/abc/src/misc/vec/vecBit.h" 3 4
       ((void) sizeof ((
# 598 "/app/abc/src/misc/vec/vecBit.h"
       nWords > 0
# 598 "/app/abc/src/misc/vec/vecBit.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 598 "/app/abc/src/misc/vec/vecBit.h"
       nWords > 0
# 598 "/app/abc/src/misc/vec/vecBit.h" 3 4
       ) ; else __assert_fail (
# 598 "/app/abc/src/misc/vec/vecBit.h"
       "nWords > 0"
# 598 "/app/abc/src/misc/vec/vecBit.h" 3 4
       , "/app/abc/src/misc/vec/vecBit.h", 598, __extension__ __PRETTY_FUNCTION__); }))
# 598 "/app/abc/src/misc/vec/vecBit.h"
                           ;
        for ( i = 0; i < nWords-1; i++ )
            Counter += Vec_BitCountWord( pArray[i] );
        Counter += Vec_BitCountWord( pArray[i] & ~(~0 << (p->nSize & 31)) );
    }
    else
    {
        for ( i = 0; i < nWords; i++ )
            Counter += Vec_BitCountWord( pArray[i] );
    }
    return Counter;
}
# 622 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitReset( Vec_Bit_t * p )
{
    int i, nWords = (p->nSize >> 5) + ((p->nSize & 31) > 0);
    for ( i = 0; i < nWords; i++ )
        p->pArray[i] = 0;
}
# 641 "/app/abc/src/misc/vec/vecBit.h"
static inline void Vec_BitPrint( Vec_Bit_t * p )
{
    int i, Entry;
    printf( "Vector has %d entries: {", Vec_BitSize(p) );
    for ( i = 0; (i < Vec_BitSize(p)) && (((Entry) = Vec_BitEntry(p, i)), 1); i++ )
        printf( " %d", Entry );
    printf( " }\n" );
}


# 39 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecMem.h" 1
# 31 "/app/abc/src/misc/vec/vecMem.h"

# 50 "/app/abc/src/misc/vec/vecMem.h"
typedef struct Vec_Mem_t_ Vec_Mem_t;
struct Vec_Mem_t_
{
    int nEntrySize;
    int nEntries;
    int LogPageSze;
    int PageMask;
    int nPageAlloc;
    int iPage;
    word ** ppPages;
    Vec_Int_t * vTable;
    Vec_Int_t * vNexts;
};
# 87 "/app/abc/src/misc/vec/vecMem.h"
static inline void Vec_MemAlloc_( Vec_Mem_t * p, int nEntrySize, int LogPageSze )
{
    memset( p, 0, sizeof(Vec_Mem_t) );
    p->nEntrySize = nEntrySize;
    p->LogPageSze = LogPageSze;
    p->PageMask = (1 << p->LogPageSze) - 1;
    p->iPage = -1;
}
static inline Vec_Mem_t * Vec_MemAlloc( int nEntrySize, int LogPageSze )
{
    Vec_Mem_t * p;
    p = ((Vec_Mem_t *) calloc((size_t)(1), sizeof(Vec_Mem_t)));
    p->nEntrySize = nEntrySize;
    p->LogPageSze = LogPageSze;
    p->PageMask = (1 << p->LogPageSze) - 1;
    p->iPage = -1;
    return p;
}
static inline void Vec_MemFree( Vec_Mem_t * p )
{
    int i;
    for ( i = 0; i <= p->iPage; i++ )
        ((p->ppPages[i]) ? (free((char *) (p->ppPages[i])), (p->ppPages[i]) = 0) : 0);
    ((p->ppPages) ? (free((char *) (p->ppPages)), (p->ppPages) = 0) : 0);
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
static inline void Vec_MemFreeP( Vec_Mem_t ** p )
{
    if ( *p == 
# 115 "/app/abc/src/misc/vec/vecMem.h" 3 4
              ((void *)0) 
# 115 "/app/abc/src/misc/vec/vecMem.h"
                   )
        return;
    Vec_MemFree( *p );
    *p = 
# 118 "/app/abc/src/misc/vec/vecMem.h" 3 4
        ((void *)0)
# 118 "/app/abc/src/misc/vec/vecMem.h"
            ;
}
static inline Vec_Mem_t * Vec_MemDup( Vec_Mem_t * pVec )
{
    Vec_Mem_t * p = 
# 122 "/app/abc/src/misc/vec/vecMem.h" 3 4
                   ((void *)0)
# 122 "/app/abc/src/misc/vec/vecMem.h"
                       ;
    return p;
}
# 137 "/app/abc/src/misc/vec/vecMem.h"
static inline void Vec_MemFill( Vec_Mem_t * pVec, int nEntries )
{
}
static inline void Vec_MemClean( Vec_Mem_t * pVec, int nEntries )
{
}
# 155 "/app/abc/src/misc/vec/vecMem.h"
static inline int Vec_MemEntrySize( Vec_Mem_t * p )
{
    return p->nEntrySize;
}
static inline int Vec_MemEntryNum( Vec_Mem_t * p )
{
    return p->nEntries;
}
static inline int Vec_MemPageSize( Vec_Mem_t * p )
{
    return p->LogPageSze;
}
static inline int Vec_MemPageNum( Vec_Mem_t * p )
{
    return p->iPage+1;
}
# 183 "/app/abc/src/misc/vec/vecMem.h"
static inline double Vec_MemMemory( Vec_Mem_t * p )
{
    return (double)sizeof(word) * p->nEntrySize * (1 << p->LogPageSze) * (p->iPage + 1) + (double)sizeof(word *) * p->nPageAlloc + (double)sizeof(Vec_Mem_t);
}
# 199 "/app/abc/src/misc/vec/vecMem.h"
static inline word * Vec_MemReadEntry( Vec_Mem_t * p, int i )
{
    
# 201 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 201 "/app/abc/src/misc/vec/vecMem.h"
   i >= 0 && i < p->nEntries
# 201 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 201 "/app/abc/src/misc/vec/vecMem.h"
   i >= 0 && i < p->nEntries
# 201 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 201 "/app/abc/src/misc/vec/vecMem.h"
   "i >= 0 && i < p->nEntries"
# 201 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 201, __extension__ __PRETTY_FUNCTION__); }))
# 201 "/app/abc/src/misc/vec/vecMem.h"
                                      ;
    return p->ppPages[i >> p->LogPageSze] + p->nEntrySize * (i & p->PageMask);
}
static inline word * Vec_MemReadEntryLast( Vec_Mem_t * p )
{
    
# 206 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 206 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries > 0
# 206 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 206 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries > 0
# 206 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 206 "/app/abc/src/misc/vec/vecMem.h"
   "p->nEntries > 0"
# 206 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 206, __extension__ __PRETTY_FUNCTION__); }))
# 206 "/app/abc/src/misc/vec/vecMem.h"
                            ;
    return Vec_MemReadEntry( p, p->nEntries-1 );
}
static inline void Vec_MemWriteEntry( Vec_Mem_t * p, int i, word * pEntry )
{
    word * pPlace = Vec_MemReadEntry( p, i );
    memmove( pPlace, pEntry, sizeof(word) * p->nEntrySize );
}
static inline word * Vec_MemGetEntry( Vec_Mem_t * p, int i )
{
    
# 216 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 216 "/app/abc/src/misc/vec/vecMem.h"
   i >= 0
# 216 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 216 "/app/abc/src/misc/vec/vecMem.h"
   i >= 0
# 216 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 216 "/app/abc/src/misc/vec/vecMem.h"
   "i >= 0"
# 216 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 216, __extension__ __PRETTY_FUNCTION__); }))
# 216 "/app/abc/src/misc/vec/vecMem.h"
                   ;
    if ( i >= p->nEntries )
    {
        int k, iPageNew = (i >> p->LogPageSze);
        if ( p->iPage < iPageNew )
        {

            if ( iPageNew >= p->nPageAlloc )
                p->ppPages = ((p->ppPages) ? ((word * *) realloc((char *)(p->ppPages), sizeof(word *) * (size_t)((p->nPageAlloc = p->nPageAlloc ? 2 * p->nPageAlloc : iPageNew + 32)))) : ((word * *) malloc(sizeof(word *) * (size_t)((p->nPageAlloc = p->nPageAlloc ? 2 * p->nPageAlloc : iPageNew + 32)))));

            for ( k = p->iPage + 1; k <= iPageNew; k++ )
                p->ppPages[k] = ((word *) malloc(sizeof(word) * (size_t)(p->nEntrySize * (1 << p->LogPageSze))));

            p->iPage = iPageNew;
        }

        p->nEntries = i + 1;
    }
    return Vec_MemReadEntry( p, i );
}
static inline void Vec_MemSetEntry( Vec_Mem_t * p, int i, word * pEntry )
{
    word * pPlace = Vec_MemGetEntry( p, i );
    memmove( pPlace, pEntry, sizeof(word) * (size_t)p->nEntrySize );
}
static inline void Vec_MemPush( Vec_Mem_t * p, word * pEntry )
{
    word * pPlace = Vec_MemGetEntry( p, p->nEntries );
    memmove( pPlace, pEntry, sizeof(word) * (size_t)p->nEntrySize );
}
# 258 "/app/abc/src/misc/vec/vecMem.h"
static inline void Vec_MemShrink( Vec_Mem_t * p, int nEntriesNew )
{
    int i, iPageOld = p->iPage;
    
# 261 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 261 "/app/abc/src/misc/vec/vecMem.h"
   nEntriesNew <= p->nEntries
# 261 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 261 "/app/abc/src/misc/vec/vecMem.h"
   nEntriesNew <= p->nEntries
# 261 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 261 "/app/abc/src/misc/vec/vecMem.h"
   "nEntriesNew <= p->nEntries"
# 261 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 261, __extension__ __PRETTY_FUNCTION__); }))
# 261 "/app/abc/src/misc/vec/vecMem.h"
                                       ;
    p->nEntries = nEntriesNew;
    p->iPage = (nEntriesNew >> p->LogPageSze);
    for ( i = p->iPage + 1; i <= iPageOld; i++ )
        ((p->ppPages[i]) ? (free((char *) (p->ppPages[i])), (p->ppPages[i]) = 0) : 0);
}
# 279 "/app/abc/src/misc/vec/vecMem.h"
static inline void Vec_MemDumpDigit( FILE * pFile, int HexDigit )
{
    
# 281 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 281 "/app/abc/src/misc/vec/vecMem.h"
   HexDigit >= 0 && HexDigit < 16
# 281 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 281 "/app/abc/src/misc/vec/vecMem.h"
   HexDigit >= 0 && HexDigit < 16
# 281 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 281 "/app/abc/src/misc/vec/vecMem.h"
   "HexDigit >= 0 && HexDigit < 16"
# 281 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 281, __extension__ __PRETTY_FUNCTION__); }))
# 281 "/app/abc/src/misc/vec/vecMem.h"
                                           ;
    if ( HexDigit < 10 )
        fprintf( pFile, "%d", HexDigit );
    else
        fprintf( pFile, "%c", 'A' + HexDigit-10 );
}
static inline void Vec_MemDump( FILE * pFile, Vec_Mem_t * pVec )
{
    word * pEntry;
    int i, w, d;
    if ( pFile == 
# 291 "/app/abc/src/misc/vec/vecMem.h" 3 4
                 stdout 
# 291 "/app/abc/src/misc/vec/vecMem.h"
                        )
        printf( "Memory vector has %d entries: \n", Vec_MemEntryNum(pVec) );
    for ( i = 0; (i < Vec_MemEntryNum(pVec)) && ((pEntry) = Vec_MemReadEntry(pVec, i)); i++ )
    {
        for ( w = pVec->nEntrySize - 1; w >= 0; w-- )
            for ( d = 15; d >= 0; d-- )
                Vec_MemDumpDigit( pFile, (int)(pEntry[w] >> (d<<2)) & 15 );
        fprintf( pFile, "\n" );
    }
}
# 313 "/app/abc/src/misc/vec/vecMem.h"
static inline void Vec_MemHashAlloc( Vec_Mem_t * p, int nTableSize )
{
    
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 315 "/app/abc/src/misc/vec/vecMem.h"
   p->vTable == 
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void *)0) 
# 315 "/app/abc/src/misc/vec/vecMem.h"
   && p->vNexts == 
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 315 "/app/abc/src/misc/vec/vecMem.h"
   p->vTable == 
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void *)0) 
# 315 "/app/abc/src/misc/vec/vecMem.h"
   && p->vNexts == 
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void *)0)) ; else __assert_fail (
# 315 "/app/abc/src/misc/vec/vecMem.h"
   "p->vTable == NULL && p->vNexts == NULL"
# 315 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 315, __extension__ __PRETTY_FUNCTION__); }))
# 315 "/app/abc/src/misc/vec/vecMem.h"
                                                   ;
    p->vTable = Vec_IntStartFull( Abc_PrimeCudd(nTableSize) );
    p->vNexts = Vec_IntAlloc( nTableSize );
}
static inline void Vec_MemHashFree( Vec_Mem_t * p )
{
    if ( p == 
# 321 "/app/abc/src/misc/vec/vecMem.h" 3 4
             ((void *)0) 
# 321 "/app/abc/src/misc/vec/vecMem.h"
                  )
        return;
    Vec_IntFreeP( &p->vTable );
    Vec_IntFreeP( &p->vNexts );
}
static inline unsigned Vec_MemHashKey( Vec_Mem_t * p, word * pEntry )
{
    static int s_Primes[8] = { 1699, 4177, 5147, 5647, 6343, 7103, 7873, 8147 };
    int i, nData = 2 * p->nEntrySize;
    unsigned * pData = (unsigned *)pEntry;
    unsigned uHash = 0;
    for ( i = 0; i < nData; i++ )
        uHash += pData[i] * s_Primes[i & 0x7];
    return uHash % Vec_IntSize(p->vTable);
}
static int * Vec_MemHashLookup( Vec_Mem_t * p, word * pEntry )
{
    int * pSpot = Vec_IntEntryP( p->vTable, Vec_MemHashKey(p, pEntry) );
    for ( ; *pSpot != -1; pSpot = Vec_IntEntryP(p->vNexts, *pSpot) )
        if ( !memcmp( Vec_MemReadEntry(p, *pSpot), pEntry, sizeof(word) * p->nEntrySize ) )
            return pSpot;
    return pSpot;
}
static void Vec_MemHashProfile( Vec_Mem_t * p )
{
    int e;
    for ( e = 0; e < 1000; e++ )
    {
        int Count = 0;
        int * pSpot = Vec_IntEntryP( p->vTable, e );
        for ( ; *pSpot != -1; pSpot = Vec_IntEntryP(p->vNexts, *pSpot) )
            Count++;
        printf( "%d ", Count );
    }
    printf( "\n" );
}
static void Vec_MemHashResize( Vec_Mem_t * p )
{
    word * pEntry;
    int i, * pSpot;

    Vec_IntFill( p->vTable, Abc_PrimeCudd(2 * Vec_IntSize(p->vTable)), -1 );
    Vec_IntClear( p->vNexts );
    for ( i = 0; (i < Vec_MemEntryNum(p)) && ((pEntry) = Vec_MemReadEntry(p, i)); i++ )
    {
        pSpot = Vec_MemHashLookup( p, pEntry );
        
# 367 "/app/abc/src/misc/vec/vecMem.h" 3 4
       ((void) sizeof ((
# 367 "/app/abc/src/misc/vec/vecMem.h"
       *pSpot == -1
# 367 "/app/abc/src/misc/vec/vecMem.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 367 "/app/abc/src/misc/vec/vecMem.h"
       *pSpot == -1
# 367 "/app/abc/src/misc/vec/vecMem.h" 3 4
       ) ; else __assert_fail (
# 367 "/app/abc/src/misc/vec/vecMem.h"
       "*pSpot == -1"
# 367 "/app/abc/src/misc/vec/vecMem.h" 3 4
       , "/app/abc/src/misc/vec/vecMem.h", 367, __extension__ __PRETTY_FUNCTION__); }))
# 367 "/app/abc/src/misc/vec/vecMem.h"
                             ;
        *pSpot = Vec_IntSize(p->vNexts);
        Vec_IntPush( p->vNexts, -1 );
    }
    
# 371 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 371 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries == Vec_IntSize(p->vNexts)
# 371 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 371 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries == Vec_IntSize(p->vNexts)
# 371 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 371 "/app/abc/src/misc/vec/vecMem.h"
   "p->nEntries == Vec_IntSize(p->vNexts)"
# 371 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 371, __extension__ __PRETTY_FUNCTION__); }))
# 371 "/app/abc/src/misc/vec/vecMem.h"
                                                  ;
}
static int Vec_MemHashInsert( Vec_Mem_t * p, word * pEntry )
{
    int * pSpot;
    if ( p->nEntries > Vec_IntSize(p->vTable) )
        Vec_MemHashResize( p );
    pSpot = Vec_MemHashLookup( p, pEntry );
    if ( *pSpot != -1 )
        return *pSpot;
    *pSpot = Vec_IntSize(p->vNexts);
    Vec_IntPush( p->vNexts, -1 );
    Vec_MemPush( p, pEntry );
    
# 384 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ((void) sizeof ((
# 384 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries == Vec_IntSize(p->vNexts)
# 384 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 384 "/app/abc/src/misc/vec/vecMem.h"
   p->nEntries == Vec_IntSize(p->vNexts)
# 384 "/app/abc/src/misc/vec/vecMem.h" 3 4
   ) ; else __assert_fail (
# 384 "/app/abc/src/misc/vec/vecMem.h"
   "p->nEntries == Vec_IntSize(p->vNexts)"
# 384 "/app/abc/src/misc/vec/vecMem.h" 3 4
   , "/app/abc/src/misc/vec/vecMem.h", 384, __extension__ __PRETTY_FUNCTION__); }))
# 384 "/app/abc/src/misc/vec/vecMem.h"
                                                  ;
    return Vec_IntSize(p->vNexts) - 1;
}
# 400 "/app/abc/src/misc/vec/vecMem.h"
static inline Vec_Mem_t * Vec_MemAllocForTTSimple( int nVars )
{
    int nWords = (nVars <= 6 ? 1 : (1 << (nVars - 6)));
    Vec_Mem_t * vTtMem = Vec_MemAlloc( nWords, 12 );
    Vec_MemHashAlloc( vTtMem, 10000 );
    return vTtMem;
}
static inline Vec_Mem_t * Vec_MemAllocForTT( int nVars, int fCompl )
{
    int Value, nWords = (nVars <= 6 ? 1 : (1 << (nVars - 6)));
    word * uTruth = ((word *) malloc(sizeof(word) * (size_t)(nWords)));
    Vec_Mem_t * vTtMem = Vec_MemAlloc( nWords, 12 );
    Vec_MemHashAlloc( vTtMem, 10000 );
    memset( uTruth, 0x00, sizeof(word) * nWords );
    Value = Vec_MemHashInsert( vTtMem, uTruth ); 
# 414 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ((void) sizeof ((
# 414 "/app/abc/src/misc/vec/vecMem.h"
                                                Value == 0
# 414 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ) ? 1 : 0), __extension__ ({ if (
# 414 "/app/abc/src/misc/vec/vecMem.h"
                                                Value == 0
# 414 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ) ; else __assert_fail (
# 414 "/app/abc/src/misc/vec/vecMem.h"
                                                "Value == 0"
# 414 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                , "/app/abc/src/misc/vec/vecMem.h", 414, __extension__ __PRETTY_FUNCTION__); }))
# 414 "/app/abc/src/misc/vec/vecMem.h"
                                                                    ;
    if ( fCompl )
        memset( uTruth, 0x55, sizeof(word) * nWords );
    else
        memset( uTruth, 0xAA, sizeof(word) * nWords );
    Value = Vec_MemHashInsert( vTtMem, uTruth ); 
# 419 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ((void) sizeof ((
# 419 "/app/abc/src/misc/vec/vecMem.h"
                                                Value == 1
# 419 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ) ? 1 : 0), __extension__ ({ if (
# 419 "/app/abc/src/misc/vec/vecMem.h"
                                                Value == 1
# 419 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                ) ; else __assert_fail (
# 419 "/app/abc/src/misc/vec/vecMem.h"
                                                "Value == 1"
# 419 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                , "/app/abc/src/misc/vec/vecMem.h", 419, __extension__ __PRETTY_FUNCTION__); }))
# 419 "/app/abc/src/misc/vec/vecMem.h"
                                                                    ;
    ((uTruth) ? (free((char *) (uTruth)), (uTruth) = 0) : 0);
    return vTtMem;
}
static inline void Vec_MemAddMuxTT( Vec_Mem_t * p, int nVars )
{
    int Value, nWords = (nVars <= 6 ? 1 : (1 << (nVars - 6)));
    word * uTruth = ((word *) malloc(sizeof(word) * (size_t)(nWords)));
    memset( uTruth, 0xCA, sizeof(word) * nWords );
    Value = Vec_MemHashInsert( p, uTruth ); 
# 428 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                           ((void) sizeof ((
# 428 "/app/abc/src/misc/vec/vecMem.h"
                                           Value == 2
# 428 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                           ) ? 1 : 0), __extension__ ({ if (
# 428 "/app/abc/src/misc/vec/vecMem.h"
                                           Value == 2
# 428 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                           ) ; else __assert_fail (
# 428 "/app/abc/src/misc/vec/vecMem.h"
                                           "Value == 2"
# 428 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                           , "/app/abc/src/misc/vec/vecMem.h", 428, __extension__ __PRETTY_FUNCTION__); }))
# 428 "/app/abc/src/misc/vec/vecMem.h"
                                                               ;
    ((uTruth) ? (free((char *) (uTruth)), (uTruth) = 0) : 0);
}
static inline void Vec_MemDumpTruthTables( Vec_Mem_t * p, char * pName, int nLutSize )
{
    FILE * pFile;
    char pFileName[1000];
    sprintf( pFileName, "tt_%s_%02d.txt", pName ? pName : 
# 435 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                                         ((void *)0)
# 435 "/app/abc/src/misc/vec/vecMem.h"
                                                             , nLutSize );
    pFile = pName ? fopen( pFileName, "wb" ) : 
# 436 "/app/abc/src/misc/vec/vecMem.h" 3 4
                                              stdout
# 436 "/app/abc/src/misc/vec/vecMem.h"
                                                    ;
    Vec_MemDump( pFile, p );
    if ( pFile != 
# 438 "/app/abc/src/misc/vec/vecMem.h" 3 4
                 stdout 
# 438 "/app/abc/src/misc/vec/vecMem.h"
                        )
        fclose( pFile );
    printf( "Dumped %d %d-var truth tables into file \"%s\" (%.2f MB).\n",
        Vec_MemEntryNum(p), nLutSize, pName ? pFileName : "stdout",
        8.0 * Vec_MemEntryNum(p) * Vec_MemEntrySize(p) / (1 << 20) );
}


# 40 "/app/abc/src/misc/vec/vec.h" 2
# 1 "/app/abc/src/misc/vec/vecWec.h" 1
# 31 "/app/abc/src/misc/vec/vecWec.h"

# 42 "/app/abc/src/misc/vec/vecWec.h"
typedef struct Vec_Wec_t_ Vec_Wec_t;
struct Vec_Wec_t_
{
    int nCap;
    int nSize;
    Vec_Int_t * pArray;
};
# 89 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Wec_t * Vec_WecAlloc( int nCap )
{
    Vec_Wec_t * p;
    p = ((Vec_Wec_t *) malloc(sizeof(Vec_Wec_t) * (size_t)(1)));
    if ( nCap > 0 && nCap < 8 )
        nCap = 8;
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((Vec_Int_t *) calloc((size_t)(p->nCap), sizeof(Vec_Int_t))) : 
# 97 "/app/abc/src/misc/vec/vecWec.h" 3 4
                                                           ((void *)0)
# 97 "/app/abc/src/misc/vec/vecWec.h"
                                                               ;
    return p;
}
static inline Vec_Wec_t * Vec_WecAllocExact( int nCap )
{
    Vec_Wec_t * p;
    
# 103 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 103 "/app/abc/src/misc/vec/vecWec.h"
   nCap >= 0
# 103 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 103 "/app/abc/src/misc/vec/vecWec.h"
   nCap >= 0
# 103 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 103 "/app/abc/src/misc/vec/vecWec.h"
   "nCap >= 0"
# 103 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 103, __extension__ __PRETTY_FUNCTION__); }))
# 103 "/app/abc/src/misc/vec/vecWec.h"
                      ;
    p = ((Vec_Wec_t *) malloc(sizeof(Vec_Wec_t) * (size_t)(1)));
    p->nSize = 0;
    p->nCap = nCap;
    p->pArray = p->nCap? ((Vec_Int_t *) calloc((size_t)(p->nCap), sizeof(Vec_Int_t))) : 
# 107 "/app/abc/src/misc/vec/vecWec.h" 3 4
                                                           ((void *)0)
# 107 "/app/abc/src/misc/vec/vecWec.h"
                                                               ;
    return p;
}
static inline Vec_Wec_t * Vec_WecStart( int nSize )
{
    Vec_Wec_t * p;
    p = Vec_WecAlloc( nSize );
    p->nSize = nSize;
    return p;
}
# 129 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecGrow( Vec_Wec_t * p, int nCapMin )
{
    if ( p->nCap >= nCapMin )
        return;
    p->pArray = ((p->pArray) ? ((Vec_Int_t *) realloc((char *)(p->pArray), sizeof(Vec_Int_t) * (size_t)(nCapMin))) : ((Vec_Int_t *) malloc(sizeof(Vec_Int_t) * (size_t)(nCapMin))));
    memset( p->pArray + p->nCap, 0, sizeof(Vec_Int_t) * (size_t)(nCapMin - p->nCap) );
    p->nCap = nCapMin;
}
static inline void Vec_WecInit( Vec_Wec_t * p, int nSize )
{
    Vec_WecGrow( p, nSize );
    p->nSize = nSize;
}
# 154 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Int_t * Vec_WecEntry( Vec_Wec_t * p, int i )
{
    
# 156 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 156 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 156 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 156 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 156 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 156 "/app/abc/src/misc/vec/vecWec.h"
   "i >= 0 && i < p->nSize"
# 156 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 156, __extension__ __PRETTY_FUNCTION__); }))
# 156 "/app/abc/src/misc/vec/vecWec.h"
                                   ;
    return p->pArray + i;
}
static inline Vec_Int_t * Vec_WecEntryLast( Vec_Wec_t * p )
{
    
# 161 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 161 "/app/abc/src/misc/vec/vecWec.h"
   p->nSize > 0
# 161 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 161 "/app/abc/src/misc/vec/vecWec.h"
   p->nSize > 0
# 161 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 161 "/app/abc/src/misc/vec/vecWec.h"
   "p->nSize > 0"
# 161 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 161, __extension__ __PRETTY_FUNCTION__); }))
# 161 "/app/abc/src/misc/vec/vecWec.h"
                         ;
    return p->pArray + p->nSize - 1;
}
static inline int Vec_WecEntryEntry( Vec_Wec_t * p, int i, int k )
{
    return Vec_IntEntry( Vec_WecEntry(p, i), k );
}
# 180 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Int_t * Vec_WecArray( Vec_Wec_t * p )
{
    return p->pArray;
}
static inline int Vec_WecLevelId( Vec_Wec_t * p, Vec_Int_t * vLevel )
{
    
# 186 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 186 "/app/abc/src/misc/vec/vecWec.h"
   p->pArray <= vLevel && vLevel < p->pArray + p->nSize
# 186 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 186 "/app/abc/src/misc/vec/vecWec.h"
   p->pArray <= vLevel && vLevel < p->pArray + p->nSize
# 186 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 186 "/app/abc/src/misc/vec/vecWec.h"
   "p->pArray <= vLevel && vLevel < p->pArray + p->nSize"
# 186 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 186, __extension__ __PRETTY_FUNCTION__); }))
# 186 "/app/abc/src/misc/vec/vecWec.h"
                                                                 ;
    return vLevel - p->pArray;
}
# 201 "/app/abc/src/misc/vec/vecWec.h"
static inline int Vec_WecCap( Vec_Wec_t * p )
{
    return p->nCap;
}
static inline int Vec_WecSize( Vec_Wec_t * p )
{
    return p->nSize;
}
static inline int Vec_WecLevelSize( Vec_Wec_t * p, int i )
{
    
# 211 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 211 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 211 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 211 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 211 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 211 "/app/abc/src/misc/vec/vecWec.h"
   "i >= 0 && i < p->nSize"
# 211 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 211, __extension__ __PRETTY_FUNCTION__); }))
# 211 "/app/abc/src/misc/vec/vecWec.h"
                                   ;
    return Vec_IntSize( p->pArray + i );
}
static inline int Vec_WecSizeSize( Vec_Wec_t * p )
{
    Vec_Int_t * vVec;
    int i, Counter = 0;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Counter += Vec_IntSize(vVec);
    return Counter;
}
static inline int Vec_WecSizeUsed( Vec_Wec_t * p )
{
    Vec_Int_t * vVec;
    int i, Counter = 0;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Counter += (int)(Vec_IntSize(vVec) > 0);
    return Counter;
}
static inline int Vec_WecSizeUsedLimits( Vec_Wec_t * p, int iStart, int iStop )
{
    Vec_Int_t * vVec;
    int i, Counter = 0;
    for ( i = iStart; (i < iStop) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Counter += (int)(Vec_IntSize(vVec) > 0);
    return Counter;
}
# 250 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecShrink( Vec_Wec_t * p, int nSizeNew )
{
    Vec_Int_t * vVec; int i;
    for ( i = nSizeNew; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Vec_IntShrink( vVec, 0 );
    
# 255 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 255 "/app/abc/src/misc/vec/vecWec.h"
   p->nSize >= nSizeNew
# 255 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 255 "/app/abc/src/misc/vec/vecWec.h"
   p->nSize >= nSizeNew
# 255 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 255 "/app/abc/src/misc/vec/vecWec.h"
   "p->nSize >= nSizeNew"
# 255 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 255, __extension__ __PRETTY_FUNCTION__); }))
# 255 "/app/abc/src/misc/vec/vecWec.h"
                                 ;
    p->nSize = nSizeNew;
}
# 270 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecClear( Vec_Wec_t * p )
{
    Vec_Int_t * vVec;
    int i;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Vec_IntClear( vVec );
    p->nSize = 0;
}
static inline void Vec_WecClearLevels( Vec_Wec_t * p )
{
    Vec_Int_t * vVec;
    int i;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        Vec_IntClear( vVec );
}
# 297 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecPush( Vec_Wec_t * p, int Level, int Entry )
{
    if ( p->nSize < Level + 1 )
    {
        Vec_WecGrow( p, Abc_MaxInt(2*p->nSize, Level + 1) );
        p->nSize = Level + 1;
    }
    Vec_IntPush( Vec_WecEntry(p, Level), Entry );
}
static inline void Vec_WecPushTwo( Vec_Wec_t * p, int Level, int Entry1, int Entry2 )
{
    if ( p->nSize < Level + 1 )
    {
        Vec_WecGrow( p, Abc_MaxInt(2*p->nSize, Level + 1) );
        p->nSize = Level + 1;
    }
    Vec_IntPushTwo( Vec_WecEntry(p, Level), Entry1, Entry2 );
}
static inline Vec_Int_t * Vec_WecPushLevel( Vec_Wec_t * p )
{
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_WecGrow( p, 16 );
        else
            Vec_WecGrow( p, 2 * p->nCap );
    }
    ++p->nSize;
    return Vec_WecEntryLast( p );
}
static inline Vec_Int_t * Vec_WecInsertLevel( Vec_Wec_t * p, int i )
{
    Vec_Int_t * pTemp;
    if ( p->nSize == p->nCap )
    {
        if ( p->nCap < 16 )
            Vec_WecGrow( p, 16 );
        else
            Vec_WecGrow( p, 2 * p->nCap );
    }
    ++p->nSize;
    
# 338 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 338 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 338 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 338 "/app/abc/src/misc/vec/vecWec.h"
   i >= 0 && i < p->nSize
# 338 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 338 "/app/abc/src/misc/vec/vecWec.h"
   "i >= 0 && i < p->nSize"
# 338 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 338, __extension__ __PRETTY_FUNCTION__); }))
# 338 "/app/abc/src/misc/vec/vecWec.h"
                                   ;
    for ( pTemp = p->pArray + p->nSize - 2; pTemp >= p->pArray + i; pTemp-- )
        pTemp[1] = pTemp[0];
    Vec_IntZero( p->pArray + i );
    return p->pArray + i;
}
# 356 "/app/abc/src/misc/vec/vecWec.h"
static inline double Vec_WecMemory( Vec_Wec_t * p )
{
    int i;
    double Mem;
    if ( p == 
# 360 "/app/abc/src/misc/vec/vecWec.h" 3 4
             ((void *)0) 
# 360 "/app/abc/src/misc/vec/vecWec.h"
                  ) return 0.0;
    Mem = sizeof(Vec_Int_t) * Vec_WecCap(p);
    for ( i = 0; i < p->nSize; i++ )
        Mem += sizeof(int) * (size_t)Vec_IntCap( Vec_WecEntry(p, i) );
    return Mem;
}
# 378 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecZero( Vec_Wec_t * p )
{
    p->pArray = 
# 380 "/app/abc/src/misc/vec/vecWec.h" 3 4
               ((void *)0)
# 380 "/app/abc/src/misc/vec/vecWec.h"
                   ;
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_WecErase( Vec_Wec_t * p )
{
    int i;
    for ( i = 0; i < p->nCap; i++ )
        ((p->pArray[i].pArray) ? (free((char *) (p->pArray[i].pArray)), (p->pArray[i].pArray) = 0) : 0);
    ((p->pArray) ? (free((char *) (p->pArray)), (p->pArray) = 0) : 0);
    p->nSize = 0;
    p->nCap = 0;
}
static inline void Vec_WecFree( Vec_Wec_t * p )
{
    Vec_WecErase( p );
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
static inline void Vec_WecFreeP( Vec_Wec_t ** p )
{
    if ( *p == 
# 400 "/app/abc/src/misc/vec/vecWec.h" 3 4
              ((void *)0) 
# 400 "/app/abc/src/misc/vec/vecWec.h"
                   )
        return;
    Vec_WecFree( *p );
    *p = 
# 403 "/app/abc/src/misc/vec/vecWec.h" 3 4
        ((void *)0)
# 403 "/app/abc/src/misc/vec/vecWec.h"
            ;
}
# 417 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecPushUnique( Vec_Wec_t * p, int Level, int Entry )
{
    if ( p->nSize < Level + 1 )
        Vec_WecPush( p, Level, Entry );
    else
        Vec_IntPushUnique( Vec_WecEntry(p, Level), Entry );
}
# 436 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Wec_t * Vec_WecDup( Vec_Wec_t * p )
{
    Vec_Wec_t * vNew;
    Vec_Int_t * vVec;
    int i, k, Entry;
    vNew = Vec_WecStart( Vec_WecSize(p) );
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
        for ( k = 0; (k < Vec_IntSize(vVec)) && (((Entry) = Vec_IntEntry(vVec, k)), 1); k++ )
            Vec_WecPush( vNew, i, Entry );
    return vNew;
}
# 459 "/app/abc/src/misc/vec/vecWec.h"
static int Vec_WecSortCompare1( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntSize(p1) < Vec_IntSize(p2) )
        return -1;
    if ( Vec_IntSize(p1) > Vec_IntSize(p2) )
        return 1;
    return 0;
}
static int Vec_WecSortCompare2( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntSize(p1) > Vec_IntSize(p2) )
        return -1;
    if ( Vec_IntSize(p1) < Vec_IntSize(p2) )
        return 1;
    return 0;
}
static inline void Vec_WecSort( Vec_Wec_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare2 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare1 );
}
# 497 "/app/abc/src/misc/vec/vecWec.h"
static int Vec_WecSortCompare3( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntEntry(p1,0) < Vec_IntEntry(p2,0) )
        return -1;
    if ( Vec_IntEntry(p1,0) > Vec_IntEntry(p2,0) )
        return 1;
    return 0;
}
static int Vec_WecSortCompare4( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntEntry(p1,0) > Vec_IntEntry(p2,0) )
        return -1;
    if ( Vec_IntEntry(p1,0) < Vec_IntEntry(p2,0) )
        return 1;
    return 0;
}
static inline void Vec_WecSortByFirstInt( Vec_Wec_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare4 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare3 );
}
# 534 "/app/abc/src/misc/vec/vecWec.h"
static int Vec_WecSortCompare5( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntEntryLast(p1) < Vec_IntEntryLast(p2) )
        return -1;
    if ( Vec_IntEntryLast(p1) > Vec_IntEntryLast(p2) )
        return 1;
    return 0;
}
static int Vec_WecSortCompare6( Vec_Int_t * p1, Vec_Int_t * p2 )
{
    if ( Vec_IntEntryLast(p1) > Vec_IntEntryLast(p2) )
        return -1;
    if ( Vec_IntEntryLast(p1) < Vec_IntEntryLast(p2) )
        return 1;
    return 0;
}
static inline void Vec_WecSortByLastInt( Vec_Wec_t * p, int fReverse )
{
    if ( fReverse )
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare6 );
    else
        qsort( (void *)p->pArray, (size_t)p->nSize, sizeof(Vec_Int_t),
                (int (*)(const void *, const void *)) Vec_WecSortCompare5 );
}
# 571 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecKeepLevels( Vec_Wec_t * p, int Limit )
{
    Vec_Int_t * vLevel; int i, k = 0;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vLevel) = Vec_WecEntry(p, i)), 1); i++ )
        if ( Vec_IntSize(vLevel) > Limit )
        {
            { Vec_Int_t t = Vec_WecArray(p)[i]; Vec_WecArray(p)[i] = Vec_WecArray(p)[k]; Vec_WecArray(p)[k] = t; };
            k++;
        }
    Vec_WecShrink( p, k );
}
# 594 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecPrint( Vec_Wec_t * p, int fSkipSingles )
{
    Vec_Int_t * vVec;
    int i, k, Entry;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
    {
        if ( fSkipSingles && Vec_IntSize(vVec) == 1 )
            continue;
        printf( " %4d : {", i );
        for ( k = 0; (k < Vec_IntSize(vVec)) && (((Entry) = Vec_IntEntry(vVec, k)), 1); k++ )
            printf( " %d", Entry );
        printf( " }\n" );
    }
}
static inline void Vec_WecPrintLits( Vec_Wec_t * p )
{
    Vec_Int_t * vVec;
    int i, k, iLit;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vVec) = Vec_WecEntry(p, i)), 1); i++ )
    {
        printf( " %4d : %2d  {", i, Vec_IntSize(vVec) );
        for ( k = 0; (k < Vec_IntSize(vVec)) && (((iLit) = Vec_IntEntry(vVec, k)), 1); k++ )
            printf( " %c%d", Abc_LitIsCompl(iLit) ? '-' : '+', Abc_Lit2Var(iLit) );
        printf( " }\n" );
    }
}
# 632 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Wec_t * Vec_WecCreateClasses( Vec_Int_t * vMap )
{
    Vec_Wec_t * vClasses;
    int i, Entry;
    vClasses = Vec_WecStart( Vec_IntFindMax(vMap) + 1 );
    for ( i = 0; (i < Vec_IntSize(vMap)) && (((Entry) = Vec_IntEntry(vMap, i)), 1); i++ )
        Vec_WecPush( vClasses, Entry, i );
    return vClasses;
}
# 653 "/app/abc/src/misc/vec/vecWec.h"
static inline int Vec_WecCountNonTrivial( Vec_Wec_t * p, int * pnUsed )
{
    Vec_Int_t * vClass;
    int i, nClasses = 0;
    *pnUsed = 0;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vClass) = Vec_WecEntry(p, i)), 1); i++ )
    {
        if ( Vec_IntSize(vClass) < 2 )
            continue;
        nClasses++;
        (*pnUsed) += Vec_IntSize(vClass);
    }
    return nClasses;
}
# 679 "/app/abc/src/misc/vec/vecWec.h"
static inline int Vec_WecMaxLevelSize( Vec_Wec_t * p )
{
    Vec_Int_t * vTemp; int i, Res = 0;
    for ( i = 0; (i < Vec_WecSize(p)) && (((vTemp) = Vec_WecEntry(p, i)), 1); i++ )
        Res = Abc_MaxInt( Res, Vec_IntSize(vTemp) );
    return Res;
}
# 698 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Int_t * Vec_WecCollectFirsts( Vec_Wec_t * p )
{
    Vec_Int_t * vFirsts, * vLevel;
    int i;
    vFirsts = Vec_IntAlloc( Vec_WecSize(p) );
    for ( i = 0; (i < Vec_WecSize(p)) && (((vLevel) = Vec_WecEntry(p, i)), 1); i++ )
        if ( Vec_IntSize(vLevel) > 0 )
            Vec_IntPush( vFirsts, Vec_IntEntry(vLevel, 0) );
    return vFirsts;
}
# 720 "/app/abc/src/misc/vec/vecWec.h"
static inline Vec_Ptr_t * Vec_WecConvertToVecPtr( Vec_Wec_t * p )
{
    Vec_Ptr_t * vCopy;
    Vec_Int_t * vLevel;
    int i;
    vCopy = Vec_PtrAlloc( Vec_WecSize(p) );
    for ( i = 0; (i < Vec_WecSize(p)) && (((vLevel) = Vec_WecEntry(p, i)), 1); i++ )
        Vec_PtrPush( vCopy, Vec_IntDup(vLevel) );
    return vCopy;
}
# 743 "/app/abc/src/misc/vec/vecWec.h"
static inline int Vec_WecIntHasMark( Vec_Int_t * vVec ) { return (vVec->nCap >> 30) & 1; }
static inline void Vec_WecIntSetMark( Vec_Int_t * vVec ) { vVec->nCap |= (1<<30); }
static inline void Vec_WecIntXorMark( Vec_Int_t * vVec ) { vVec->nCap ^= (1<<30); }
static inline void Vec_WecMarkLevels( Vec_Wec_t * vCubes, Vec_Int_t * vLevels )
{
    Vec_Int_t * vCube;
    int i;
    for ( i = 0; (i < Vec_IntSize(vLevels)) && (((vCube) = Vec_WecEntry(vCubes, Vec_IntEntry(vLevels, i))), 1); i++ )
    {
        
# 752 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ((void) sizeof ((
# 752 "/app/abc/src/misc/vec/vecWec.h"
       !Vec_WecIntHasMark( vCube )
# 752 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 752 "/app/abc/src/misc/vec/vecWec.h"
       !Vec_WecIntHasMark( vCube )
# 752 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ; else __assert_fail (
# 752 "/app/abc/src/misc/vec/vecWec.h"
       "!Vec_WecIntHasMark( vCube )"
# 752 "/app/abc/src/misc/vec/vecWec.h" 3 4
       , "/app/abc/src/misc/vec/vecWec.h", 752, __extension__ __PRETTY_FUNCTION__); }))
# 752 "/app/abc/src/misc/vec/vecWec.h"
                                            ;
        Vec_WecIntXorMark( vCube );
    }
}
static inline void Vec_WecUnmarkLevels( Vec_Wec_t * vCubes, Vec_Int_t * vLevels )
{
    Vec_Int_t * vCube;
    int i;
    for ( i = 0; (i < Vec_IntSize(vLevels)) && (((vCube) = Vec_WecEntry(vCubes, Vec_IntEntry(vLevels, i))), 1); i++ )
    {
        
# 762 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ((void) sizeof ((
# 762 "/app/abc/src/misc/vec/vecWec.h"
       Vec_WecIntHasMark( vCube )
# 762 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 762 "/app/abc/src/misc/vec/vecWec.h"
       Vec_WecIntHasMark( vCube )
# 762 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ; else __assert_fail (
# 762 "/app/abc/src/misc/vec/vecWec.h"
       "Vec_WecIntHasMark( vCube )"
# 762 "/app/abc/src/misc/vec/vecWec.h" 3 4
       , "/app/abc/src/misc/vec/vecWec.h", 762, __extension__ __PRETTY_FUNCTION__); }))
# 762 "/app/abc/src/misc/vec/vecWec.h"
                                           ;
        Vec_WecIntXorMark( vCube );
    }
}
# 778 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecRemoveEmpty( Vec_Wec_t * vCubes )
{
    Vec_Int_t * vCube;
    int i, k = 0;
    for ( i = 0; (i < Vec_WecSize(vCubes)) && (((vCube) = Vec_WecEntry(vCubes, i)), 1); i++ )
        if ( Vec_IntSize(vCube) > 0 )
            vCubes->pArray[k++] = *vCube;
        else
            ((vCube->pArray) ? (free((char *) (vCube->pArray)), (vCube->pArray) = 0) : 0);
    for ( i = k; i < Vec_WecSize(vCubes); i++ )
        Vec_IntZero( Vec_WecEntry(vCubes, i) );
    Vec_WecShrink( vCubes, k );

}
# 805 "/app/abc/src/misc/vec/vecWec.h"
static inline void Vec_WecDumpBin( char * pFileName, Vec_Wec_t * p, int fVerbose )
{
    Vec_Int_t * vLevel;
    int i, nSize, RetValue;
    FILE * pFile = fopen( pFileName, "wb" );
    if ( pFile == 
# 810 "/app/abc/src/misc/vec/vecWec.h" 3 4
                 ((void *)0) 
# 810 "/app/abc/src/misc/vec/vecWec.h"
                      )
    {
        printf( "Cannot open file \"%s\" for writing.\n", pFileName );
        return;
    }
    nSize = Vec_WecSize(p);
    RetValue = fwrite( &nSize, 1, sizeof(int), pFile );
    for ( i = 0; (i < Vec_WecSize(p)) && (((vLevel) = Vec_WecEntry(p, i)), 1); i++ )
    {
        nSize = Vec_IntSize(vLevel);
        RetValue += fwrite( &nSize, 1, sizeof(int), pFile );
        RetValue += fwrite( Vec_IntArray(vLevel), 1, sizeof(int)*nSize, pFile );
    }
    fclose( pFile );
    if ( RetValue != (int)sizeof(int)*(Vec_WecSizeSize(p)+Vec_WecSize(p)+1) )
        printf( "Error writing data into file.\n" );
    if ( fVerbose )
        printf( "Written %d integer arrays into file \"%s\".\n", Vec_WecSize(p), pFileName );
}
static inline Vec_Wec_t * Vec_WecReadBin( char * pFileName, int fVerbose )
{
    Vec_Wec_t * p = 
# 831 "/app/abc/src/misc/vec/vecWec.h" 3 4
                   ((void *)0)
# 831 "/app/abc/src/misc/vec/vecWec.h"
                       ; Vec_Int_t * vLevel; int i, nSize, RetValue;
    FILE * pFile = fopen( pFileName, "rb" );
    if ( pFile == 
# 833 "/app/abc/src/misc/vec/vecWec.h" 3 4
                 ((void *)0) 
# 833 "/app/abc/src/misc/vec/vecWec.h"
                      )
    {
        printf( "Cannot open file \"%s\" for reading.\n", pFileName );
        return 
# 836 "/app/abc/src/misc/vec/vecWec.h" 3 4
              ((void *)0)
# 836 "/app/abc/src/misc/vec/vecWec.h"
                  ;
    }
    fseek( pFile, 0, 
# 838 "/app/abc/src/misc/vec/vecWec.h" 3 4
                    2 
# 838 "/app/abc/src/misc/vec/vecWec.h"
                             );
    nSize = ftell( pFile );
    if ( nSize == 0 )
    {
        printf( "The input file is empty.\n" );
        fclose( pFile );
        return 
# 844 "/app/abc/src/misc/vec/vecWec.h" 3 4
              ((void *)0)
# 844 "/app/abc/src/misc/vec/vecWec.h"
                  ;
    }
    if ( nSize % sizeof(int) > 0 )
    {
        printf( "Cannot read file with integers because it is not aligned at 4 bytes (remainder = %d).\n", (int)(nSize % sizeof(int)) );
        fclose( pFile );
        return 
# 850 "/app/abc/src/misc/vec/vecWec.h" 3 4
              ((void *)0)
# 850 "/app/abc/src/misc/vec/vecWec.h"
                  ;
    }
    rewind( pFile );
    RetValue = fread( &nSize, 1, sizeof(int), pFile );
    
# 854 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ((void) sizeof ((
# 854 "/app/abc/src/misc/vec/vecWec.h"
   RetValue == 4
# 854 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 854 "/app/abc/src/misc/vec/vecWec.h"
   RetValue == 4
# 854 "/app/abc/src/misc/vec/vecWec.h" 3 4
   ) ; else __assert_fail (
# 854 "/app/abc/src/misc/vec/vecWec.h"
   "RetValue == 4"
# 854 "/app/abc/src/misc/vec/vecWec.h" 3 4
   , "/app/abc/src/misc/vec/vecWec.h", 854, __extension__ __PRETTY_FUNCTION__); }))
# 854 "/app/abc/src/misc/vec/vecWec.h"
                          ;
    p = Vec_WecStart( nSize );
    for ( i = 0; (i < Vec_WecSize(p)) && (((vLevel) = Vec_WecEntry(p, i)), 1); i++ )
    {
        RetValue = fread( &nSize, 1, sizeof(int), pFile );
        
# 859 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ((void) sizeof ((
# 859 "/app/abc/src/misc/vec/vecWec.h"
       RetValue == 4
# 859 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 859 "/app/abc/src/misc/vec/vecWec.h"
       RetValue == 4
# 859 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ; else __assert_fail (
# 859 "/app/abc/src/misc/vec/vecWec.h"
       "RetValue == 4"
# 859 "/app/abc/src/misc/vec/vecWec.h" 3 4
       , "/app/abc/src/misc/vec/vecWec.h", 859, __extension__ __PRETTY_FUNCTION__); }))
# 859 "/app/abc/src/misc/vec/vecWec.h"
                              ;
        Vec_IntFill( vLevel, nSize, 0 );
        RetValue = fread( Vec_IntArray(vLevel), 1, sizeof(int)*nSize, pFile );
        
# 862 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ((void) sizeof ((
# 862 "/app/abc/src/misc/vec/vecWec.h"
       RetValue == 4*nSize
# 862 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 862 "/app/abc/src/misc/vec/vecWec.h"
       RetValue == 4*nSize
# 862 "/app/abc/src/misc/vec/vecWec.h" 3 4
       ) ; else __assert_fail (
# 862 "/app/abc/src/misc/vec/vecWec.h"
       "RetValue == 4*nSize"
# 862 "/app/abc/src/misc/vec/vecWec.h" 3 4
       , "/app/abc/src/misc/vec/vecWec.h", 862, __extension__ __PRETTY_FUNCTION__); }))
# 862 "/app/abc/src/misc/vec/vecWec.h"
                                    ;
    }
    fclose( pFile );
    if ( fVerbose )
        printf( "Read %d integer arrays from file \"%s\".\n", Vec_WecSize(p), pFileName );
    return p;
}



# 41 "/app/abc/src/misc/vec/vec.h" 2
# 52 "/app/abc/src/misc/vec/vec.h"

# 65 "/app/abc/src/misc/vec/vec.h"

# 34 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/aig/hop/hop.h" 1
# 32 "/app/abc/src/aig/hop/hop.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/aig/hop/hop.h" 2
# 42 "/app/abc/src/aig/hop/hop.h"







typedef struct Hop_Man_t_ Hop_Man_t;
typedef struct Hop_Obj_t_ Hop_Obj_t;
typedef int Hop_Edge_t;


typedef enum {
    AIG_NONE,
    AIG_CONST1,
    AIG_PI,
    AIG_PO,
    AIG_AND,
    AIG_EXOR,
    AIG_VOID
} Hop_Type_t;


struct Hop_Obj_t_
{
    union {
        void * pData;
        int iData; };
    union {
        Hop_Obj_t * pNext;
        int PioNum; };
    Hop_Obj_t * pFanin0;
    Hop_Obj_t * pFanin1;
    unsigned int Type : 3;
    unsigned int fPhase : 1;
    unsigned int fMarkA : 1;
    unsigned int fMarkB : 1;
    unsigned int nRefs : 26;
    int Id;
};


struct Hop_Man_t_
{

    Vec_Ptr_t * vPis;
    Vec_Ptr_t * vPos;
    Vec_Ptr_t * vObjs;
    Hop_Obj_t * pConst1;
    Hop_Obj_t Ghost;

    int nObjs[AIG_VOID];
    int nCreated;
    int nDeleted;

    Hop_Obj_t ** pTable;
    int nTableSize;

    void * pData;
    int nTravIds;
    int fRefCount;
    int fCatchExor;

    Vec_Ptr_t * vChunks;
    Vec_Ptr_t * vPages;
    Hop_Obj_t * pListFree;

    abctime time1;
    abctime time2;
};




extern void Hop_ManAddMemory( Hop_Man_t * p );

static inline int Hop_BitWordNum( int nBits ) { return (nBits>>5) + ((nBits&31) > 0); }
static inline int Hop_TruthWordNum( int nVars ) { return nVars <= 5 ? 1 : (1 << (nVars - 5)); }
static inline int Hop_InfoHasBit( unsigned * p, int i ) { return (p[(i)>>5] & (1<<((i) & 31))) > 0; }
static inline void Hop_InfoSetBit( unsigned * p, int i ) { p[(i)>>5] |= (1<<((i) & 31)); }
static inline void Hop_InfoXorBit( unsigned * p, int i ) { p[(i)>>5] ^= (1<<((i) & 31)); }
static inline int Hop_Base2Log( unsigned n ) { int r; if ( n < 2 ) return n; for ( r = 0, n--; n; n >>= 1, r++ ) {}; return r; }
static inline int Hop_Base10Log( unsigned n ) { int r; if ( n < 2 ) return n; for ( r = 0, n--; n; n /= 10, r++ ) {}; return r; }

static inline Hop_Obj_t * Hop_Regular( Hop_Obj_t * p ) { return (Hop_Obj_t *)((ABC_PTRUINT_T)(p) & ~01); }
static inline Hop_Obj_t * Hop_Not( Hop_Obj_t * p ) { return (Hop_Obj_t *)((ABC_PTRUINT_T)(p) ^ 01); }
static inline Hop_Obj_t * Hop_NotCond( Hop_Obj_t * p, int c ) { return (Hop_Obj_t *)((ABC_PTRUINT_T)(p) ^ (c)); }
static inline int Hop_IsComplement( Hop_Obj_t * p ) { return (int)((ABC_PTRUINT_T)(p) & 01); }

static inline Hop_Obj_t * Hop_ManConst0( Hop_Man_t * p ) { return Hop_Not(p->pConst1); }
static inline Hop_Obj_t * Hop_ManConst1( Hop_Man_t * p ) { return p->pConst1; }
static inline Hop_Obj_t * Hop_ManGhost( Hop_Man_t * p ) { return &p->Ghost; }
static inline Hop_Obj_t * Hop_ManPi( Hop_Man_t * p, int i ) { return (Hop_Obj_t *)Vec_PtrEntry(p->vPis, i); }
static inline Hop_Obj_t * Hop_ManPo( Hop_Man_t * p, int i ) { return (Hop_Obj_t *)Vec_PtrEntry(p->vPos, i); }
static inline Hop_Obj_t * Hop_ManObj( Hop_Man_t * p, int i ) { return p->vObjs ? (Hop_Obj_t *)Vec_PtrEntry(p->vObjs, i) : 
# 136 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                                                                              ((void *)0)
# 136 "/app/abc/src/aig/hop/hop.h"
                                                                                                                                  ; }

static inline Hop_Edge_t Hop_EdgeCreate( int Id, int fCompl ) { return (Id << 1) | fCompl; }
static inline int Hop_EdgeId( Hop_Edge_t Edge ) { return Edge >> 1; }
static inline int Hop_EdgeIsComplement( Hop_Edge_t Edge ) { return Edge & 1; }
static inline Hop_Edge_t Hop_EdgeRegular( Hop_Edge_t Edge ) { return (Edge >> 1) << 1; }
static inline Hop_Edge_t Hop_EdgeNot( Hop_Edge_t Edge ) { return Edge ^ 1; }
static inline Hop_Edge_t Hop_EdgeNotCond( Hop_Edge_t Edge, int fCond ) { return Edge ^ fCond; }

static inline int Hop_ManPiNum( Hop_Man_t * p ) { return p->nObjs[AIG_PI]; }
static inline int Hop_ManPoNum( Hop_Man_t * p ) { return p->nObjs[AIG_PO]; }
static inline int Hop_ManAndNum( Hop_Man_t * p ) { return p->nObjs[AIG_AND]; }
static inline int Hop_ManExorNum( Hop_Man_t * p ) { return p->nObjs[AIG_EXOR]; }
static inline int Hop_ManNodeNum( Hop_Man_t * p ) { return p->nObjs[AIG_AND]+p->nObjs[AIG_EXOR];}
static inline int Hop_ManGetCost( Hop_Man_t * p ) { return p->nObjs[AIG_AND]+3*p->nObjs[AIG_EXOR]; }
static inline int Hop_ManObjNum( Hop_Man_t * p ) { return p->nCreated - p->nDeleted; }

static inline Hop_Type_t Hop_ObjType( Hop_Obj_t * pObj ) { return (Hop_Type_t)pObj->Type; }
static inline int Hop_ObjIsNone( Hop_Obj_t * pObj ) { return pObj->Type == AIG_NONE; }
static inline int Hop_ObjIsConst1( Hop_Obj_t * pObj ) { 
# 155 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 155 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 155 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 155 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 155 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 155 "/app/abc/src/aig/hop/hop.h"
                                                                   "!Hop_IsComplement(pObj)"
# 155 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 155, __extension__ __PRETTY_FUNCTION__); }))
# 155 "/app/abc/src/aig/hop/hop.h"
                                                                                                  ; return pObj->Type == AIG_CONST1; }
static inline int Hop_ObjIsPi( Hop_Obj_t * pObj ) { return pObj->Type == AIG_PI; }
static inline int Hop_ObjIsPo( Hop_Obj_t * pObj ) { return pObj->Type == AIG_PO; }
static inline int Hop_ObjIsAnd( Hop_Obj_t * pObj ) { return pObj->Type == AIG_AND; }
static inline int Hop_ObjIsExor( Hop_Obj_t * pObj ) { return pObj->Type == AIG_EXOR; }
static inline int Hop_ObjIsNode( Hop_Obj_t * pObj ) { return pObj->Type == AIG_AND || pObj->Type == AIG_EXOR; }
static inline int Hop_ObjIsTerm( Hop_Obj_t * pObj ) { return pObj->Type == AIG_PI || pObj->Type == AIG_PO || pObj->Type == AIG_CONST1; }
static inline int Hop_ObjIsHash( Hop_Obj_t * pObj ) { return pObj->Type == AIG_AND || pObj->Type == AIG_EXOR; }

static inline int Hop_ObjIsMarkA( Hop_Obj_t * pObj ) { return pObj->fMarkA; }
static inline void Hop_ObjSetMarkA( Hop_Obj_t * pObj ) { pObj->fMarkA = 1; }
static inline void Hop_ObjClearMarkA( Hop_Obj_t * pObj ) { pObj->fMarkA = 0; }

static inline void Hop_ObjSetTravId( Hop_Obj_t * pObj, int TravId ) { pObj->pData = (void *)(ABC_PTRINT_T)TravId; }
static inline void Hop_ObjSetTravIdCurrent( Hop_Man_t * p, Hop_Obj_t * pObj ) { pObj->pData = (void *)(ABC_PTRINT_T)p->nTravIds; }
static inline void Hop_ObjSetTravIdPrevious( Hop_Man_t * p, Hop_Obj_t * pObj ) { pObj->pData = (void *)(ABC_PTRINT_T)(p->nTravIds - 1); }
static inline int Hop_ObjIsTravIdCurrent( Hop_Man_t * p, Hop_Obj_t * pObj ) { return (int)((int)(ABC_PTRINT_T)pObj->pData == p->nTravIds); }
static inline int Hop_ObjIsTravIdPrevious( Hop_Man_t * p, Hop_Obj_t * pObj ) { return (int)((int)(ABC_PTRINT_T)pObj->pData == p->nTravIds - 1); }

static inline int Hop_ObjTravId( Hop_Obj_t * pObj ) { return (int)(ABC_PTRINT_T)pObj->pData; }
static inline int Hop_ObjPhase( Hop_Obj_t * pObj ) { return pObj->fPhase; }
static inline int Hop_ObjRefs( Hop_Obj_t * pObj ) { return pObj->nRefs; }
static inline void Hop_ObjRef( Hop_Obj_t * pObj ) { pObj->nRefs++; }
static inline void Hop_ObjDeref( Hop_Obj_t * pObj ) { 
# 178 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 178 "/app/abc/src/aig/hop/hop.h"
                                                                   pObj->nRefs > 0
# 178 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 178 "/app/abc/src/aig/hop/hop.h"
                                                                   pObj->nRefs > 0
# 178 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 178 "/app/abc/src/aig/hop/hop.h"
                                                                   "pObj->nRefs > 0"
# 178 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 178, __extension__ __PRETTY_FUNCTION__); }))
# 178 "/app/abc/src/aig/hop/hop.h"
                                                                                            ; pObj->nRefs--; }
static inline void Hop_ObjClearRef( Hop_Obj_t * pObj ) { pObj->nRefs = 0; }
static inline int Hop_ObjFaninC0( Hop_Obj_t * pObj ) { return Hop_IsComplement(pObj->pFanin0); }
static inline int Hop_ObjFaninC1( Hop_Obj_t * pObj ) { return Hop_IsComplement(pObj->pFanin1); }
static inline Hop_Obj_t * Hop_ObjFanin0( Hop_Obj_t * pObj ) { return Hop_Regular(pObj->pFanin0); }
static inline Hop_Obj_t * Hop_ObjFanin1( Hop_Obj_t * pObj ) { return Hop_Regular(pObj->pFanin1); }
static inline Hop_Obj_t * Hop_ObjChild0( Hop_Obj_t * pObj ) { return pObj->pFanin0; }
static inline Hop_Obj_t * Hop_ObjChild1( Hop_Obj_t * pObj ) { return pObj->pFanin1; }
static inline Hop_Obj_t * Hop_ObjChild0Copy( Hop_Obj_t * pObj ) { 
# 186 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 186 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 186 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 186 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 186 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 186 "/app/abc/src/aig/hop/hop.h"
                                                                   "!Hop_IsComplement(pObj)"
# 186 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 186, __extension__ __PRETTY_FUNCTION__); }))
# 186 "/app/abc/src/aig/hop/hop.h"
                                                                                                    ; return Hop_ObjFanin0(pObj)? Hop_NotCond((Hop_Obj_t *)Hop_ObjFanin0(pObj)->pData, Hop_ObjFaninC0(pObj)) : 
# 186 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 186 "/app/abc/src/aig/hop/hop.h"
                                                                                                                                                                                                                   ; }
static inline Hop_Obj_t * Hop_ObjChild1Copy( Hop_Obj_t * pObj ) { 
# 187 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 187 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 187 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 187 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 187 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 187 "/app/abc/src/aig/hop/hop.h"
                                                                   "!Hop_IsComplement(pObj)"
# 187 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 187, __extension__ __PRETTY_FUNCTION__); }))
# 187 "/app/abc/src/aig/hop/hop.h"
                                                                                                    ; return Hop_ObjFanin1(pObj)? Hop_NotCond((Hop_Obj_t *)Hop_ObjFanin1(pObj)->pData, Hop_ObjFaninC1(pObj)) : 
# 187 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 187 "/app/abc/src/aig/hop/hop.h"
                                                                                                                                                                                                                   ; }
static inline int Hop_ObjChild0CopyI( Hop_Obj_t * pObj ) { 
# 188 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 188 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 188 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 188 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 188 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 188 "/app/abc/src/aig/hop/hop.h"
                                                                   "!Hop_IsComplement(pObj)"
# 188 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 188, __extension__ __PRETTY_FUNCTION__); }))
# 188 "/app/abc/src/aig/hop/hop.h"
                                                                                                    ; return Hop_ObjFanin0(pObj)? Abc_LitNotCond(Hop_ObjFanin0(pObj)->iData, Hop_ObjFaninC0(pObj)) : -1; }
static inline int Hop_ObjChild1CopyI( Hop_Obj_t * pObj ) { 
# 189 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ((void) sizeof ((
# 189 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 189 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 189 "/app/abc/src/aig/hop/hop.h"
                                                                   !Hop_IsComplement(pObj)
# 189 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   ) ; else __assert_fail (
# 189 "/app/abc/src/aig/hop/hop.h"
                                                                   "!Hop_IsComplement(pObj)"
# 189 "/app/abc/src/aig/hop/hop.h" 3 4
                                                                   , "/app/abc/src/aig/hop/hop.h", 189, __extension__ __PRETTY_FUNCTION__); }))
# 189 "/app/abc/src/aig/hop/hop.h"
                                                                                                    ; return Hop_ObjFanin1(pObj)? Abc_LitNotCond(Hop_ObjFanin1(pObj)->iData, Hop_ObjFaninC1(pObj)) : -1; }
static inline int Hop_ObjLevel( Hop_Obj_t * pObj ) { return pObj->nRefs; }
static inline int Hop_ObjLevelNew( Hop_Obj_t * pObj ) { return 1 + Hop_ObjIsExor(pObj) + Abc_MaxInt(Hop_ObjFanin0(pObj)->nRefs, Hop_ObjFanin1(pObj)->nRefs); }
static inline int Hop_ObjPhaseCompl( Hop_Obj_t * pObj ) { return Hop_IsComplement(pObj)? !Hop_Regular(pObj)->fPhase : pObj->fPhase; }
static inline void Hop_ObjClean( Hop_Obj_t * pObj ) { memset( pObj, 0, sizeof(Hop_Obj_t) ); }
static inline int Hop_ObjWhatFanin( Hop_Obj_t * pObj, Hop_Obj_t * pFanin )
{
    if ( Hop_ObjFanin0(pObj) == pFanin ) return 0;
    if ( Hop_ObjFanin1(pObj) == pFanin ) return 1;
    
# 198 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void) sizeof ((
# 198 "/app/abc/src/aig/hop/hop.h"
   0
# 198 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 198 "/app/abc/src/aig/hop/hop.h"
   0
# 198 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ; else __assert_fail (
# 198 "/app/abc/src/aig/hop/hop.h"
   "0"
# 198 "/app/abc/src/aig/hop/hop.h" 3 4
   , "/app/abc/src/aig/hop/hop.h", 198, __extension__ __PRETTY_FUNCTION__); }))
# 198 "/app/abc/src/aig/hop/hop.h"
            ; return -1;
}
static inline int Hop_ObjFanoutC( Hop_Obj_t * pObj, Hop_Obj_t * pFanout )
{
    if ( Hop_ObjFanin0(pFanout) == pObj ) return Hop_ObjFaninC0(pObj);
    if ( Hop_ObjFanin1(pFanout) == pObj ) return Hop_ObjFaninC1(pObj);
    
# 204 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void) sizeof ((
# 204 "/app/abc/src/aig/hop/hop.h"
   0
# 204 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 204 "/app/abc/src/aig/hop/hop.h"
   0
# 204 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ; else __assert_fail (
# 204 "/app/abc/src/aig/hop/hop.h"
   "0"
# 204 "/app/abc/src/aig/hop/hop.h" 3 4
   , "/app/abc/src/aig/hop/hop.h", 204, __extension__ __PRETTY_FUNCTION__); }))
# 204 "/app/abc/src/aig/hop/hop.h"
            ; return -1;
}


static inline Hop_Obj_t * Hop_ObjCreateGhost( Hop_Man_t * p, Hop_Obj_t * p0, Hop_Obj_t * p1, Hop_Type_t Type )
{
    Hop_Obj_t * pGhost;
    
# 211 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void) sizeof ((
# 211 "/app/abc/src/aig/hop/hop.h"
   Type != AIG_AND || !Hop_ObjIsConst1(Hop_Regular(p0))
# 211 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 211 "/app/abc/src/aig/hop/hop.h"
   Type != AIG_AND || !Hop_ObjIsConst1(Hop_Regular(p0))
# 211 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ; else __assert_fail (
# 211 "/app/abc/src/aig/hop/hop.h"
   "Type != AIG_AND || !Hop_ObjIsConst1(Hop_Regular(p0))"
# 211 "/app/abc/src/aig/hop/hop.h" 3 4
   , "/app/abc/src/aig/hop/hop.h", 211, __extension__ __PRETTY_FUNCTION__); }))
# 211 "/app/abc/src/aig/hop/hop.h"
                                                                 ;
    
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void) sizeof ((
# 212 "/app/abc/src/aig/hop/hop.h"
   p1 == 
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void *)0) 
# 212 "/app/abc/src/aig/hop/hop.h"
   || !Hop_ObjIsConst1(Hop_Regular(p1))
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 212 "/app/abc/src/aig/hop/hop.h"
   p1 == 
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void *)0) 
# 212 "/app/abc/src/aig/hop/hop.h"
   || !Hop_ObjIsConst1(Hop_Regular(p1))
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ; else __assert_fail (
# 212 "/app/abc/src/aig/hop/hop.h"
   "p1 == NULL || !Hop_ObjIsConst1(Hop_Regular(p1))"
# 212 "/app/abc/src/aig/hop/hop.h" 3 4
   , "/app/abc/src/aig/hop/hop.h", 212, __extension__ __PRETTY_FUNCTION__); }))
# 212 "/app/abc/src/aig/hop/hop.h"
                                                            ;
    
# 213 "/app/abc/src/aig/hop/hop.h" 3 4
   ((void) sizeof ((
# 213 "/app/abc/src/aig/hop/hop.h"
   Type == AIG_PI || Hop_Regular(p0) != Hop_Regular(p1)
# 213 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 213 "/app/abc/src/aig/hop/hop.h"
   Type == AIG_PI || Hop_Regular(p0) != Hop_Regular(p1)
# 213 "/app/abc/src/aig/hop/hop.h" 3 4
   ) ; else __assert_fail (
# 213 "/app/abc/src/aig/hop/hop.h"
   "Type == AIG_PI || Hop_Regular(p0) != Hop_Regular(p1)"
# 213 "/app/abc/src/aig/hop/hop.h" 3 4
   , "/app/abc/src/aig/hop/hop.h", 213, __extension__ __PRETTY_FUNCTION__); }))
# 213 "/app/abc/src/aig/hop/hop.h"
                                                                 ;
    pGhost = Hop_ManGhost(p);
    pGhost->Type = Type;
    if ( Hop_Regular(p0)->Id < Hop_Regular(p1)->Id )
    {
        pGhost->pFanin0 = p0;
        pGhost->pFanin1 = p1;
    }
    else
    {
        pGhost->pFanin0 = p1;
        pGhost->pFanin1 = p0;
    }
    return pGhost;
}


static inline Hop_Obj_t * Hop_ManFetchMemory( Hop_Man_t * p )
{
    Hop_Obj_t * pTemp;
    if ( p->pListFree == 
# 233 "/app/abc/src/aig/hop/hop.h" 3 4
                        ((void *)0) 
# 233 "/app/abc/src/aig/hop/hop.h"
                             )
        Hop_ManAddMemory( p );
    pTemp = p->pListFree;
    p->pListFree = *((Hop_Obj_t **)pTemp);
    memset( pTemp, 0, sizeof(Hop_Obj_t) );
    if ( p->vObjs )
    {
        
# 240 "/app/abc/src/aig/hop/hop.h" 3 4
       ((void) sizeof ((
# 240 "/app/abc/src/aig/hop/hop.h"
       p->nCreated == Vec_PtrSize(p->vObjs)
# 240 "/app/abc/src/aig/hop/hop.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 240 "/app/abc/src/aig/hop/hop.h"
       p->nCreated == Vec_PtrSize(p->vObjs)
# 240 "/app/abc/src/aig/hop/hop.h" 3 4
       ) ; else __assert_fail (
# 240 "/app/abc/src/aig/hop/hop.h"
       "p->nCreated == Vec_PtrSize(p->vObjs)"
# 240 "/app/abc/src/aig/hop/hop.h" 3 4
       , "/app/abc/src/aig/hop/hop.h", 240, __extension__ __PRETTY_FUNCTION__); }))
# 240 "/app/abc/src/aig/hop/hop.h"
                                                     ;
        Vec_PtrPush( p->vObjs, pTemp );
    }
    pTemp->Id = p->nCreated++;
    return pTemp;
}
static inline void Hop_ManRecycleMemory( Hop_Man_t * p, Hop_Obj_t * pEntry )
{
    pEntry->Type = AIG_NONE;
    *((Hop_Obj_t **)pEntry) = p->pListFree;
    p->pListFree = pEntry;
}
# 274 "/app/abc/src/aig/hop/hop.h"
extern Hop_Man_t * Hop_ManBalance( Hop_Man_t * p, int fUpdateLevel );
extern Hop_Obj_t * Hop_NodeBalanceBuildSuper( Hop_Man_t * p, Vec_Ptr_t * vSuper, Hop_Type_t Type, int fUpdateLevel );

extern int Hop_ManCheck( Hop_Man_t * p );

extern Vec_Ptr_t * Hop_ManDfs( Hop_Man_t * p );
extern Vec_Ptr_t * Hop_ManDfsNode( Hop_Man_t * p, Hop_Obj_t * pNode );
extern int Hop_ManCountLevels( Hop_Man_t * p );
extern void Hop_ManCreateRefs( Hop_Man_t * p );
extern int Hop_DagSize( Hop_Obj_t * pObj );
extern int Hop_ObjFanoutCount( Hop_Obj_t * pObj, Hop_Obj_t * pPivot );
extern void Hop_ConeUnmark_rec( Hop_Obj_t * pObj );
extern Hop_Obj_t * Hop_Transfer( Hop_Man_t * pSour, Hop_Man_t * pDest, Hop_Obj_t * pObj, int nVars );
extern Hop_Obj_t * Hop_Compose( Hop_Man_t * p, Hop_Obj_t * pRoot, Hop_Obj_t * pFunc, int iVar );
extern Hop_Obj_t * Hop_Complement( Hop_Man_t * p, Hop_Obj_t * pRoot, int iVar );
extern Hop_Obj_t * Hop_Remap( Hop_Man_t * p, Hop_Obj_t * pRoot, unsigned uSupp, int nVars );
extern Hop_Obj_t * Hop_Permute( Hop_Man_t * p, Hop_Obj_t * pRoot, int nRootVars, int * pPermute );

extern Hop_Man_t * Hop_ManStart();
extern Hop_Man_t * Hop_ManDup( Hop_Man_t * p );
extern void Hop_ManStop( Hop_Man_t * p );
extern int Hop_ManCleanup( Hop_Man_t * p );
extern void Hop_ManPrintStats( Hop_Man_t * p );

extern void Hop_ManStartMemory( Hop_Man_t * p );
extern void Hop_ManStopMemory( Hop_Man_t * p );

extern Hop_Obj_t * Hop_ObjCreatePi( Hop_Man_t * p );
extern Hop_Obj_t * Hop_ObjCreatePo( Hop_Man_t * p, Hop_Obj_t * pDriver );
extern Hop_Obj_t * Hop_ObjCreate( Hop_Man_t * p, Hop_Obj_t * pGhost );
extern void Hop_ObjConnect( Hop_Man_t * p, Hop_Obj_t * pObj, Hop_Obj_t * pFan0, Hop_Obj_t * pFan1 );
extern void Hop_ObjDisconnect( Hop_Man_t * p, Hop_Obj_t * pObj );
extern void Hop_ObjDelete( Hop_Man_t * p, Hop_Obj_t * pObj );
extern void Hop_ObjDelete_rec( Hop_Man_t * p, Hop_Obj_t * pObj );
extern Hop_Obj_t * Hop_ObjRepr( Hop_Obj_t * pObj );
extern void Hop_ObjCreateChoice( Hop_Obj_t * pOld, Hop_Obj_t * pNew );

extern Hop_Obj_t * Hop_IthVar( Hop_Man_t * p, int i );
extern Hop_Obj_t * Hop_Oper( Hop_Man_t * p, Hop_Obj_t * p0, Hop_Obj_t * p1, Hop_Type_t Type );
extern Hop_Obj_t * Hop_And( Hop_Man_t * p, Hop_Obj_t * p0, Hop_Obj_t * p1 );
extern Hop_Obj_t * Hop_Or( Hop_Man_t * p, Hop_Obj_t * p0, Hop_Obj_t * p1 );
extern Hop_Obj_t * Hop_Exor( Hop_Man_t * p, Hop_Obj_t * p0, Hop_Obj_t * p1 );
extern Hop_Obj_t * Hop_Mux( Hop_Man_t * p, Hop_Obj_t * pC, Hop_Obj_t * p1, Hop_Obj_t * p0 );
extern Hop_Obj_t * Hop_Maj( Hop_Man_t * p, Hop_Obj_t * pA, Hop_Obj_t * pB, Hop_Obj_t * pC );
extern Hop_Obj_t * Hop_Miter( Hop_Man_t * p, Vec_Ptr_t * vPairs );
extern Hop_Obj_t * Hop_CreateAnd( Hop_Man_t * p, int nVars );
extern Hop_Obj_t * Hop_CreateOr( Hop_Man_t * p, int nVars );
extern Hop_Obj_t * Hop_CreateExor( Hop_Man_t * p, int nVars );

extern Hop_Obj_t * Hop_TableLookup( Hop_Man_t * p, Hop_Obj_t * pGhost );
extern void Hop_TableInsert( Hop_Man_t * p, Hop_Obj_t * pObj );
extern void Hop_TableDelete( Hop_Man_t * p, Hop_Obj_t * pObj );
extern int Hop_TableCountEntries( Hop_Man_t * p );
extern void Hop_TableProfile( Hop_Man_t * p );

extern unsigned * Hop_ManConvertAigToTruth( Hop_Man_t * p, Hop_Obj_t * pRoot, int nVars, Vec_Int_t * vTruth, int fMsbFirst );
extern word Hop_ManComputeTruth6( Hop_Man_t * p, Hop_Obj_t * pObj, int nVars );

extern void Hop_ManIncrementTravId( Hop_Man_t * p );
extern void Hop_ManCleanData( Hop_Man_t * p );
extern void Hop_ObjCleanData_rec( Hop_Obj_t * pObj );
extern void Hop_ObjCollectMulti( Hop_Obj_t * pFunc, Vec_Ptr_t * vSuper );
extern int Hop_ObjIsMuxType( Hop_Obj_t * pObj );
extern int Hop_ObjRecognizeExor( Hop_Obj_t * pObj, Hop_Obj_t ** ppFan0, Hop_Obj_t ** ppFan1 );
extern Hop_Obj_t * Hop_ObjRecognizeMux( Hop_Obj_t * pObj, Hop_Obj_t ** ppObjT, Hop_Obj_t ** ppObjE );
extern void Hop_ObjPrintEqn( FILE * pFile, Hop_Obj_t * pObj, Vec_Vec_t * vLevels, int Level );
extern void Hop_ObjPrintVerilog( FILE * pFile, Hop_Obj_t * pObj, Vec_Vec_t * vLevels, int Level, int fOnlyAnds );
extern void Hop_ObjPrintVerbose( Hop_Obj_t * pObj, int fHaig );
extern void Hop_ManPrintVerbose( Hop_Man_t * p, int fHaig );
extern void Hop_ManDumpBlif( Hop_Man_t * p, char * pFileName );




# 35 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/aig/gia/gia.h" 1
# 32 "/app/abc/src/aig/gia/gia.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/aig/gia/gia.h" 2


# 1 "/app/abc/src/misc/vec/vecWec.h" 1
# 36 "/app/abc/src/aig/gia/gia.h" 2
# 1 "/app/abc/src/misc/util/utilCex.h" 1
# 32 "/app/abc/src/misc/util/utilCex.h"







typedef struct Abc_Cex_t_ Abc_Cex_t;
struct Abc_Cex_t_
{
    int iPo;
    int iFrame;
    int nRegs;
    int nPis;
    int nBits;
    unsigned pData[0];
};
# 59 "/app/abc/src/misc/util/utilCex.h"
extern Abc_Cex_t * Abc_CexAlloc( int nRegs, int nTruePis, int nFrames );
extern Abc_Cex_t * Abc_CexAllocFull( int nRegs, int nTruePis, int nFrames );
extern Abc_Cex_t * Abc_CexMakeTriv( int nRegs, int nTruePis, int nTruePos, int iFrameOut );
extern Abc_Cex_t * Abc_CexCreate( int nRegs, int nTruePis, int * pArray, int iFrame, int iPo, int fSkipRegs );
extern Abc_Cex_t * Abc_CexDup( Abc_Cex_t * p, int nRegsNew );
extern Abc_Cex_t * Abc_CexDeriveFromCombModel( int * pModel, int nPis, int nRegs, int iPo );
extern Abc_Cex_t * Abc_CexMerge( Abc_Cex_t * pCex, Abc_Cex_t * pPart, int iFrBeg, int iFrEnd );
extern void Abc_CexPrintStats( Abc_Cex_t * p );
extern void Abc_CexPrintStatsInputs( Abc_Cex_t * p, int nInputs );
extern void Abc_CexPrint( Abc_Cex_t * p );
extern void Abc_CexFreeP( Abc_Cex_t ** p );
extern void Abc_CexFree( Abc_Cex_t * p );
extern Abc_Cex_t * Abc_CexTransformPhase( Abc_Cex_t * p, int nPisOld, int nPosOld, int nRegsOld );
extern Abc_Cex_t * Abc_CexTransformTempor( Abc_Cex_t * p, int nPisOld, int nPosOld, int nRegsOld );
extern Abc_Cex_t * Abc_CexTransformUndc( Abc_Cex_t * p, char * pInit );
extern Abc_Cex_t * Abc_CexPermute( Abc_Cex_t * p, Vec_Int_t * vMapOld2New );
extern Abc_Cex_t * Abc_CexPermuteTwo( Abc_Cex_t * p, Vec_Int_t * vPermOld, Vec_Int_t * vPermNew );
extern int Abc_CexCountOnes( Abc_Cex_t * p );


# 37 "/app/abc/src/aig/gia/gia.h" 2







# 52 "/app/abc/src/aig/gia/gia.h"
typedef struct Gia_MmFixed_t_ Gia_MmFixed_t;
typedef struct Gia_MmFlex_t_ Gia_MmFlex_t;
typedef struct Gia_MmStep_t_ Gia_MmStep_t;
typedef struct Gia_Dat_t_ Gia_Dat_t;

typedef struct Gia_Rpr_t_ Gia_Rpr_t;
struct Gia_Rpr_t_
{
    unsigned iRepr : 28;
    unsigned fProved : 1;
    unsigned fFailed : 1;
    unsigned fColorA : 1;
    unsigned fColorB : 1;
};

typedef struct Gia_Plc_t_ Gia_Plc_t;
struct Gia_Plc_t_
{
    unsigned fFixed : 1;
    unsigned xCoord : 15;
    unsigned fUndef : 1;
    unsigned yCoord : 15;
};

typedef struct Gia_Obj_t_ Gia_Obj_t;
struct Gia_Obj_t_
{
    unsigned iDiff0 : 29;
    unsigned fCompl0: 1;
    unsigned fMark0 : 1;
    unsigned fTerm : 1;

    unsigned iDiff1 : 29;
    unsigned fCompl1: 1;
    unsigned fMark1 : 1;
    unsigned fPhase : 1;

    unsigned Value;
};





typedef struct Gia_Man_t_ Gia_Man_t;
struct Gia_Man_t_
{
    char * pName;
    char * pSpec;
    int nRegs;
    int nRegsAlloc;
    int nObjs;
    int nObjsAlloc;
    Gia_Obj_t * pObjs;
    unsigned * pMuxes;
    int nXors;
    int nMuxes;
    int nBufs;
    Vec_Int_t * vCis;
    Vec_Int_t * vCos;
    Vec_Int_t vHash;
    Vec_Int_t vHTable;
    int fAddStrash;
    int fSweeper;
    int fGiaSimple;
    Vec_Int_t vRefs;
    int * pRefs;
    int * pLutRefs;
    Vec_Int_t * vLevels;
    int nLevels;
    int nConstrs;
    int nTravIds;
    int nFront;
    int * pReprsOld;
    Gia_Rpr_t * pReprs;
    int * pNexts;
    int * pSibls;
    int * pIso;
    int nTerLoop;
    int nTerStates;
    int * pFanData;
    int nFansAlloc;
    Vec_Int_t * vFanoutNums;
    Vec_Int_t * vFanout;
    Vec_Int_t * vMapping;
    Vec_Wec_t * vMapping2;
    Vec_Wec_t * vFanouts2;
    Vec_Int_t * vCellMapping;
    void * pSatlutWinman;
    Vec_Int_t * vPacking;
    Vec_Int_t * vConfigs;
    char * pCellStr;
    Vec_Int_t * vLutConfigs;
    Vec_Int_t * vEdgeDelay;
    Vec_Int_t * vEdgeDelayR;
    Vec_Int_t * vEdge1;
    Vec_Int_t * vEdge2;
    Abc_Cex_t * pCexComb;
    Abc_Cex_t * pCexSeq;
    Vec_Ptr_t * vSeqModelVec;
    Vec_Int_t vCopies;
    Vec_Int_t vCopies2;
    Vec_Int_t * vVar2Obj;
    Vec_Int_t * vTruths;
    Vec_Int_t * vFlopClasses;
    Vec_Int_t * vGateClasses;
    Vec_Int_t * vObjClasses;
    Vec_Int_t * vInitClasses;
    Vec_Int_t * vRegClasses;
    Vec_Int_t * vRegInits;
    Vec_Int_t * vDoms;
    Vec_Int_t * vBarBufs;
    Vec_Int_t * vXors;
    unsigned char* pSwitching;
    Gia_Plc_t * pPlacement;
    Gia_Man_t * pAigExtra;
    Vec_Flt_t * vInArrs;
    Vec_Flt_t * vOutReqs;
    Vec_Int_t * vCiArrs;
    Vec_Int_t * vCoReqs;
    Vec_Int_t * vCoArrs;
    Vec_Int_t * vCoAttrs;
    Vec_Int_t * vWeights;
    int And2Delay;
    float DefInArrs;
    float DefOutReqs;
    Vec_Int_t * vSwitching;
    int * pTravIds;
    int nTravIdsAlloc;
    Vec_Ptr_t * vNamesIn;
    Vec_Ptr_t * vNamesOut;
    Vec_Ptr_t * vNamesNode;
    Vec_Int_t * vUserPiIds;
    Vec_Int_t * vUserPoIds;
    Vec_Int_t * vUserFfIds;
    Vec_Int_t * vCiNumsOrig;
    Vec_Int_t * vCoNumsOrig;
    Vec_Int_t * vIdsOrig;
    Vec_Int_t * vIdsEquiv;
    Vec_Int_t * vCofVars;
    Vec_Vec_t * vClockDoms;
    Vec_Flt_t * vTiming;
    void * pManTime;
    void * pLutLib;
    word nHashHit;
    word nHashMiss;
    void * pData;
    unsigned * pData2;
    int iData;
    int iData2;
    int nAnd2Delay;
    int fVerbose;
    int MappedArea;
    int MappedDelay;

    int fBuiltInSim;
    int iPatsPi;
    int nSimWords;
    int nSimWordsT;
    int iPastPiMax;
    int nSimWordsMax;
    Vec_Wrd_t * vSims;
    Vec_Wrd_t * vSimsT;
    Vec_Wrd_t * vSimsPi;
    Vec_Wrd_t * vSimsPo;
    Vec_Int_t * vClassOld;
    Vec_Int_t * vClassNew;
    Vec_Int_t * vPats;
    Vec_Bit_t * vPolars;

    int fIncrSim;
    int iNextPi;
    int iTimeStamp;
    Vec_Int_t * vTimeStamps;

    int nTtVars;
    int nTtWords;
    Vec_Int_t * vTtNums;
    Vec_Int_t * vTtNodes;
    Vec_Ptr_t * vTtInputs;
    Vec_Wrd_t * vTtMemory;

    Vec_Int_t * vSuper;
    Vec_Int_t * vStore;

    int iSuppPi;
    int nSuppWords;
    Vec_Wrd_t * vSuppWords;
    Vec_Int_t vCopiesTwo;
    Vec_Int_t vSuppVars;
    Vec_Int_t vVarMap;
    Gia_Dat_t * pUData;

    Vec_Str_t * vStopsF;
    Vec_Str_t * vStopsB;

    int iFirstNonPiId;
    int iFirstPoId;
    int iFirstAndObj;
    int iFirstPoObj;
};


typedef struct Gps_Par_t_ Gps_Par_t;
struct Gps_Par_t_
{
    int fTents;
    int fSwitch;
    int fCut;
    int fNpn;
    int fLutProf;
    int fMuxXor;
    int fMiter;
    int fSkipMap;
    int fSlacks;
    int fNoColor;
    char * pDumpFile;
};

typedef struct Emb_Par_t_ Emb_Par_t;
struct Emb_Par_t_
{
    int nDims;
    int nSols;
    int nIters;
    int fRefine;
    int fCluster;
    int fDump;
    int fDumpLarge;
    int fShowImage;
    int fVerbose;
};



typedef struct Gia_ParFra_t_ Gia_ParFra_t;
struct Gia_ParFra_t_
{
    int nFrames;
    int fInit;
    int fSaveLastLit;
    int fDisableSt;
    int fOrPos;
    int fVerbose;
};



typedef struct Gia_ParSim_t_ Gia_ParSim_t;
struct Gia_ParSim_t_
{

    int nWords;
    int nIters;
    int RandSeed;
    int TimeLimit;
    int fCheckMiter;
    int fVerbose;
    int iOutFail;
};

typedef struct Gia_ManSim_t_ Gia_ManSim_t;
struct Gia_ManSim_t_
{
    Gia_Man_t * pAig;
    Gia_ParSim_t * pPars;
    int nWords;
    Vec_Int_t * vCis2Ids;
    Vec_Int_t * vConsts;

    unsigned * pDataSim;
    unsigned * pDataSimCis;
    unsigned * pDataSimCos;
};

typedef struct Jf_Par_t_ Jf_Par_t;
struct Jf_Par_t_
{
    int nLutSize;
    int nCutNum;
    int nProcNum;
    int nRounds;
    int nRoundsEla;
    int nRelaxRatio;
    int nCoarseLimit;
    int nAreaTuner;
    int nReqTimeFlex;
    int nVerbLimit;
    int nDelayLut1;
    int nDelayLut2;
    int nFastEdges;
    int DelayTarget;
    int fAreaOnly;
    int fPinPerm;
    int fPinQuick;
    int fPinFilter;
    int fOptEdge;
    int fUseMux7;
    int fPower;
    int fCoarsen;
    int fCutMin;
    int fFuncDsd;
    int fGenCnf;
    int fGenLit;
    int fCnfObjIds;
    int fAddOrCla;
    int fCnfMapping;
    int fPureAig;
    int fDoAverage;
    int fCutHashing;
    int fCutSimple;
    int fCutGroup;
    int fVerbose;
    int fVeryVerbose;
    int nLutSizeMax;
    int nCutNumMax;
    int nProcNumMax;
    int nLutSizeMux;
    word Delay;
    word Area;
    word Edge;
    word Clause;
    word Mux7;
    word WordMapDelay;
    word WordMapArea;
    word WordMapDelayTarget;
    int MapDelay;
    float MapArea;
    float MapAreaF;
    float MapDelayTarget;
    float Epsilon;
    float * pTimesArr;
    float * pTimesReq;
};

static inline unsigned Gia_ObjCutSign( unsigned ObjId ) { return (1 << (ObjId & 31)); }
static inline int Gia_WordHasOneBit( unsigned uWord ) { return (uWord & (uWord-1)) == 0; }
static inline int Gia_WordHasOnePair( unsigned uWord ) { return Gia_WordHasOneBit(uWord & (uWord>>1) & 0x55555555); }
static inline int Gia_WordCountOnes( unsigned uWord )
{
    uWord = (uWord & 0x55555555) + ((uWord>>1) & 0x55555555);
    uWord = (uWord & 0x33333333) + ((uWord>>2) & 0x33333333);
    uWord = (uWord & 0x0F0F0F0F) + ((uWord>>4) & 0x0F0F0F0F);
    uWord = (uWord & 0x00FF00FF) + ((uWord>>8) & 0x00FF00FF);
    return (uWord & 0x0000FFFF) + (uWord>>16);
}
static inline int Gia_WordFindFirstBit( unsigned uWord )
{
    int i;
    for ( i = 0; i < 32; i++ )
        if ( uWord & (1 << i) )
            return i;
    return -1;
}

static inline int Gia_ManTruthIsConst0( unsigned * pIn, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn[w] )
            return 0;
    return 1;
}
static inline int Gia_ManTruthIsConst1( unsigned * pIn, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn[w] != ~(unsigned)0 )
            return 0;
    return 1;
}
static inline void Gia_ManTruthCopy( unsigned * pOut, unsigned * pIn, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = pIn[w];
}
static inline void Gia_ManTruthClear( unsigned * pOut, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = 0;
}
static inline void Gia_ManTruthFill( unsigned * pOut, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = ~(unsigned)0;
}
static inline void Gia_ManTruthNot( unsigned * pOut, unsigned * pIn, int nVars )
{
    int w;
    for ( w = Abc_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = ~pIn[w];
}

static inline int Gia_ManConst0Lit() { return 0; }
static inline int Gia_ManConst1Lit() { return 1; }
static inline int Gia_ManIsConst0Lit( int iLit ) { return (iLit == 0); }
static inline int Gia_ManIsConst1Lit( int iLit ) { return (iLit == 1); }
static inline int Gia_ManIsConstLit( int iLit ) { return (iLit <= 1); }

static inline Gia_Obj_t * Gia_Regular( Gia_Obj_t * p ) { return (Gia_Obj_t *)((ABC_PTRUINT_T)(p) & ~01); }
static inline Gia_Obj_t * Gia_Not( Gia_Obj_t * p ) { return (Gia_Obj_t *)((ABC_PTRUINT_T)(p) ^ 01); }
static inline Gia_Obj_t * Gia_NotCond( Gia_Obj_t * p, int c ) { return (Gia_Obj_t *)((ABC_PTRUINT_T)(p) ^ (c)); }
static inline int Gia_IsComplement( Gia_Obj_t * p ) { return (int)((ABC_PTRUINT_T)(p) & 01); }

static inline char * Gia_ManName( Gia_Man_t * p ) { return p->pName; }
static inline int Gia_ManCiNum( Gia_Man_t * p ) { return Vec_IntSize(p->vCis); }
static inline int Gia_ManCoNum( Gia_Man_t * p ) { return Vec_IntSize(p->vCos); }
static inline int Gia_ManPiNum( Gia_Man_t * p ) { return Vec_IntSize(p->vCis) - p->nRegs; }
static inline int Gia_ManPoNum( Gia_Man_t * p ) { return Vec_IntSize(p->vCos) - p->nRegs; }
static inline int Gia_ManRegNum( Gia_Man_t * p ) { return p->nRegs; }
static inline int Gia_ManObjNum( Gia_Man_t * p ) { return p->nObjs; }
static inline int Gia_ManAndNum( Gia_Man_t * p ) { return p->nObjs - Vec_IntSize(p->vCis) - Vec_IntSize(p->vCos) - 1; }
static inline int Gia_ManXorNum( Gia_Man_t * p ) { return p->nXors; }
static inline int Gia_ManMuxNum( Gia_Man_t * p ) { return p->nMuxes; }
static inline int Gia_ManBufNum( Gia_Man_t * p ) { return p->nBufs; }
static inline int Gia_ManAndNotBufNum( Gia_Man_t * p ){ return Gia_ManAndNum(p) - Gia_ManBufNum(p); }
static inline int Gia_ManCandNum( Gia_Man_t * p ) { return Gia_ManCiNum(p) + Gia_ManAndNum(p); }
static inline int Gia_ManConstrNum( Gia_Man_t * p ) { return p->nConstrs; }
static inline void Gia_ManFlipVerbose( Gia_Man_t * p ) { p->fVerbose ^= 1; }
static inline int Gia_ManHasChoices( Gia_Man_t * p ) { return p->pSibls != 
# 474 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void *)0)
# 474 "/app/abc/src/aig/gia/gia.h"
                                                                                        ; }
static inline int Gia_ManChoiceNum( Gia_Man_t * p ) { int c = 0; if (p->pSibls) { int i; for (i = 0; i < p->nObjs; i++) c += (int)(p->pSibls[i] > 0); } return c; }

static inline Gia_Obj_t * Gia_ManConst0( Gia_Man_t * p ) { return p->pObjs; }
static inline Gia_Obj_t * Gia_ManConst1( Gia_Man_t * p ) { return Gia_Not(Gia_ManConst0(p)); }
static inline Gia_Obj_t * Gia_ManObj( Gia_Man_t * p, int v ) { 
# 479 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ((void) sizeof ((
# 479 "/app/abc/src/aig/gia/gia.h"
                                                                v >= 0 && v < p->nObjs
# 479 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ? 1 : 0), __extension__ ({ if (
# 479 "/app/abc/src/aig/gia/gia.h"
                                                                v >= 0 && v < p->nObjs
# 479 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ; else __assert_fail (
# 479 "/app/abc/src/aig/gia/gia.h"
                                                                "v >= 0 && v < p->nObjs"
# 479 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                , "/app/abc/src/aig/gia/gia.h", 479, __extension__ __PRETTY_FUNCTION__); }))
# 479 "/app/abc/src/aig/gia/gia.h"
                                                                                                ; return p->pObjs + v; }
static inline Gia_Obj_t * Gia_ManCi( Gia_Man_t * p, int v ) { return Gia_ManObj( p, Vec_IntEntry(p->vCis,v) ); }
static inline Gia_Obj_t * Gia_ManCo( Gia_Man_t * p, int v ) { return Gia_ManObj( p, Vec_IntEntry(p->vCos,v) ); }
static inline Gia_Obj_t * Gia_ManPi( Gia_Man_t * p, int v ) { 
# 482 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ((void) sizeof ((
# 482 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManPiNum(p)
# 482 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ? 1 : 0), __extension__ ({ if (
# 482 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManPiNum(p)
# 482 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ; else __assert_fail (
# 482 "/app/abc/src/aig/gia/gia.h"
                                                                "v < Gia_ManPiNum(p)"
# 482 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                , "/app/abc/src/aig/gia/gia.h", 482, __extension__ __PRETTY_FUNCTION__); }))
# 482 "/app/abc/src/aig/gia/gia.h"
                                                                                             ; return Gia_ManCi( p, v ); }
static inline Gia_Obj_t * Gia_ManPo( Gia_Man_t * p, int v ) { 
# 483 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ((void) sizeof ((
# 483 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManPoNum(p)
# 483 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ? 1 : 0), __extension__ ({ if (
# 483 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManPoNum(p)
# 483 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ; else __assert_fail (
# 483 "/app/abc/src/aig/gia/gia.h"
                                                                "v < Gia_ManPoNum(p)"
# 483 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                , "/app/abc/src/aig/gia/gia.h", 483, __extension__ __PRETTY_FUNCTION__); }))
# 483 "/app/abc/src/aig/gia/gia.h"
                                                                                             ; return Gia_ManCo( p, v ); }
static inline Gia_Obj_t * Gia_ManRo( Gia_Man_t * p, int v ) { 
# 484 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ((void) sizeof ((
# 484 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManRegNum(p)
# 484 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ? 1 : 0), __extension__ ({ if (
# 484 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManRegNum(p)
# 484 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ; else __assert_fail (
# 484 "/app/abc/src/aig/gia/gia.h"
                                                                "v < Gia_ManRegNum(p)"
# 484 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                , "/app/abc/src/aig/gia/gia.h", 484, __extension__ __PRETTY_FUNCTION__); }))
# 484 "/app/abc/src/aig/gia/gia.h"
                                                                                              ; return Gia_ManCi( p, Gia_ManPiNum(p)+v ); }
static inline Gia_Obj_t * Gia_ManRi( Gia_Man_t * p, int v ) { 
# 485 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ((void) sizeof ((
# 485 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManRegNum(p)
# 485 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ? 1 : 0), __extension__ ({ if (
# 485 "/app/abc/src/aig/gia/gia.h"
                                                                v < Gia_ManRegNum(p)
# 485 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                ) ; else __assert_fail (
# 485 "/app/abc/src/aig/gia/gia.h"
                                                                "v < Gia_ManRegNum(p)"
# 485 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                , "/app/abc/src/aig/gia/gia.h", 485, __extension__ __PRETTY_FUNCTION__); }))
# 485 "/app/abc/src/aig/gia/gia.h"
                                                                                              ; return Gia_ManCo( p, Gia_ManPoNum(p)+v ); }

static inline int Gia_ObjId( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 487 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 487 "/app/abc/src/aig/gia/gia.h"
                                                                                p->pObjs <= pObj && pObj < p->pObjs + p->nObjs
# 487 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 487 "/app/abc/src/aig/gia/gia.h"
                                                                                p->pObjs <= pObj && pObj < p->pObjs + p->nObjs
# 487 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 487 "/app/abc/src/aig/gia/gia.h"
                                                                                "p->pObjs <= pObj && pObj < p->pObjs + p->nObjs"
# 487 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 487, __extension__ __PRETTY_FUNCTION__); }))
# 487 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                        ; return pObj - p->pObjs; }
static inline int Gia_ObjCioId( Gia_Obj_t * pObj ) { 
# 488 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 488 "/app/abc/src/aig/gia/gia.h"
                                                                                pObj->fTerm
# 488 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 488 "/app/abc/src/aig/gia/gia.h"
                                                                                pObj->fTerm
# 488 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 488 "/app/abc/src/aig/gia/gia.h"
                                                                                "pObj->fTerm"
# 488 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 488, __extension__ __PRETTY_FUNCTION__); }))
# 488 "/app/abc/src/aig/gia/gia.h"
                                                                                                     ; return pObj->iDiff1; }
static inline void Gia_ObjSetCioId( Gia_Obj_t * pObj, int v ) { 
# 489 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 489 "/app/abc/src/aig/gia/gia.h"
                                                                                pObj->fTerm
# 489 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 489 "/app/abc/src/aig/gia/gia.h"
                                                                                pObj->fTerm
# 489 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 489 "/app/abc/src/aig/gia/gia.h"
                                                                                "pObj->fTerm"
# 489 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 489, __extension__ __PRETTY_FUNCTION__); }))
# 489 "/app/abc/src/aig/gia/gia.h"
                                                                                                     ; pObj->iDiff1 = v; }
static inline int Gia_ObjValue( Gia_Obj_t * pObj ) { return pObj->Value; }
static inline void Gia_ObjSetValue( Gia_Obj_t * pObj, int i ) { pObj->Value = i; }
static inline int Gia_ObjPhase( Gia_Obj_t * pObj ) { return pObj->fPhase; }
static inline int Gia_ObjPhaseReal( Gia_Obj_t * pObj ) { return Gia_Regular(pObj)->fPhase ^ Gia_IsComplement(pObj); }
static inline int Gia_ObjPhaseDiff( Gia_Man_t * p, int i, int k ) { return Gia_ManObj(p, i)->fPhase ^ Gia_ManObj(p, k)->fPhase; }
static inline char * Gia_ObjCiName( Gia_Man_t * p, int i ) { return p->vNamesIn ? (char*)Vec_PtrEntry(p->vNamesIn, i) : 
# 495 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                               ((void *)0)
# 495 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                   ; }
static inline char * Gia_ObjCoName( Gia_Man_t * p, int i ) { return p->vNamesOut ? (char*)Vec_PtrEntry(p->vNamesOut, i) : 
# 496 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                               ((void *)0)
# 496 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                   ; }
static inline char * Gia_ObjName( Gia_Man_t * p, int i ) { return p->vNamesNode ? (char*)Vec_PtrEntry(p->vNamesNode, i) : 
# 497 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                               ((void *)0)
# 497 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                   ; }
static inline char * Gia_ObjNameObj( Gia_Man_t * p, Gia_Obj_t * pObj ) { return p->vNamesNode ? (char*)Vec_PtrEntry(p->vNamesNode, Gia_ObjId(p, pObj)) : 
# 498 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                                ((void *)0)
# 498 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                    ; }

static inline int Gia_ObjIsTerm( Gia_Obj_t * pObj ) { return pObj->fTerm; }
static inline int Gia_ObjIsAndOrConst0( Gia_Obj_t * pObj ) { return!pObj->fTerm; }
static inline int Gia_ObjIsCi( Gia_Obj_t * pObj ) { return pObj->fTerm && pObj->iDiff0 == 0x1FFFFFFF; }
static inline int Gia_ObjIsCo( Gia_Obj_t * pObj ) { return pObj->fTerm && pObj->iDiff0 != 0x1FFFFFFF; }
static inline int Gia_ObjIsAnd( Gia_Obj_t * pObj ) { return!pObj->fTerm && pObj->iDiff0 != 0x1FFFFFFF; }
static inline int Gia_ObjIsXor( Gia_Obj_t * pObj ) { return Gia_ObjIsAnd(pObj) && pObj->iDiff0 < pObj->iDiff1; }
static inline int Gia_ObjIsMuxId( Gia_Man_t * p, int iObj ) { return p->pMuxes && p->pMuxes[iObj] > 0; }
static inline int Gia_ObjIsMux( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsMuxId( p, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjIsAndReal( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsAnd(pObj) && pObj->iDiff0 > pObj->iDiff1 && !Gia_ObjIsMux(p, pObj); }
static inline int Gia_ObjIsBuf( Gia_Obj_t * pObj ) { return pObj->iDiff0 == pObj->iDiff1 && pObj->iDiff0 != 0x1FFFFFFF && !pObj->fTerm; }
static inline int Gia_ObjIsAndNotBuf( Gia_Obj_t * pObj ) { return Gia_ObjIsAnd(pObj) && pObj->iDiff0 != pObj->iDiff1; }
static inline int Gia_ObjIsCand( Gia_Obj_t * pObj ) { return Gia_ObjIsAnd(pObj) || Gia_ObjIsCi(pObj); }
static inline int Gia_ObjIsConst0( Gia_Obj_t * pObj ) { return pObj->iDiff0 == 0x1FFFFFFF && pObj->iDiff1 == 0x1FFFFFFF; }
static inline int Gia_ManObjIsConst0( Gia_Man_t * p, Gia_Obj_t * pObj){ return pObj == p->pObjs; }

static inline int Gia_Obj2Lit( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Abc_Var2Lit(Gia_ObjId(p, Gia_Regular(pObj)), Gia_IsComplement(pObj)); }
static inline Gia_Obj_t * Gia_Lit2Obj( Gia_Man_t * p, int iLit ) { return Gia_NotCond(Gia_ManObj(p, Abc_Lit2Var(iLit)), Abc_LitIsCompl(iLit)); }
static inline int Gia_ManCiLit( Gia_Man_t * p, int CiId ) { return Gia_Obj2Lit( p, Gia_ManCi(p, CiId) ); }

static inline int Gia_ManIdToCioId( Gia_Man_t * p, int Id ) { return Gia_ObjCioId( Gia_ManObj(p, Id) ); }
static inline int Gia_ManCiIdToId( Gia_Man_t * p, int CiId ) { return Gia_ObjId( p, Gia_ManCi(p, CiId) ); }
static inline int Gia_ManCoIdToId( Gia_Man_t * p, int CoId ) { return Gia_ObjId( p, Gia_ManCo(p, CoId) ); }

static inline int Gia_ObjIsPi( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsCi(pObj) && Gia_ObjCioId(pObj) < Gia_ManPiNum(p); }
static inline int Gia_ObjIsPo( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsCo(pObj) && Gia_ObjCioId(pObj) < Gia_ManPoNum(p); }
static inline int Gia_ObjIsRo( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsCi(pObj) && Gia_ObjCioId(pObj) >= Gia_ManPiNum(p); }
static inline int Gia_ObjIsRi( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjIsCo(pObj) && Gia_ObjCioId(pObj) >= Gia_ManPoNum(p); }

static inline Gia_Obj_t * Gia_ObjRoToRi( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 528 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 528 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsRo(p, pObj)
# 528 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 528 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsRo(p, pObj)
# 528 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 528 "/app/abc/src/aig/gia/gia.h"
                                                                                "Gia_ObjIsRo(p, pObj)"
# 528 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 528, __extension__ __PRETTY_FUNCTION__); }))
# 528 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; return Gia_ManCo(p, Gia_ManCoNum(p) - Gia_ManCiNum(p) + Gia_ObjCioId(pObj)); }
static inline Gia_Obj_t * Gia_ObjRiToRo( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 529 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 529 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsRi(p, pObj)
# 529 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 529 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsRi(p, pObj)
# 529 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 529 "/app/abc/src/aig/gia/gia.h"
                                                                                "Gia_ObjIsRi(p, pObj)"
# 529 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 529, __extension__ __PRETTY_FUNCTION__); }))
# 529 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; return Gia_ManCi(p, Gia_ManCiNum(p) - Gia_ManCoNum(p) + Gia_ObjCioId(pObj)); }
static inline int Gia_ObjRoToRiId( Gia_Man_t * p, int ObjId ) { return Gia_ObjId( p, Gia_ObjRoToRi( p, Gia_ManObj(p, ObjId) ) ); }
static inline int Gia_ObjRiToRoId( Gia_Man_t * p, int ObjId ) { return Gia_ObjId( p, Gia_ObjRiToRo( p, Gia_ManObj(p, ObjId) ) ); }

static inline int Gia_ObjDiff0( Gia_Obj_t * pObj ) { return pObj->iDiff0; }
static inline int Gia_ObjDiff1( Gia_Obj_t * pObj ) { return pObj->iDiff1; }
static inline int Gia_ObjFaninC0( Gia_Obj_t * pObj ) { return pObj->fCompl0; }
static inline int Gia_ObjFaninC1( Gia_Obj_t * pObj ) { return pObj->fCompl1; }
static inline int Gia_ObjFaninC2( Gia_Man_t * p, Gia_Obj_t * pObj ) { return p->pMuxes && Abc_LitIsCompl(p->pMuxes[Gia_ObjId(p, pObj)]); }
static inline int Gia_ObjFaninC( Gia_Obj_t * pObj, int n ) { return n ? Gia_ObjFaninC1(pObj) : Gia_ObjFaninC0(pObj); }
static inline Gia_Obj_t * Gia_ObjFanin0( Gia_Obj_t * pObj ) { return pObj - pObj->iDiff0; }
static inline Gia_Obj_t * Gia_ObjFanin1( Gia_Obj_t * pObj ) { return pObj - pObj->iDiff1; }
static inline Gia_Obj_t * Gia_ObjFanin2( Gia_Man_t * p, Gia_Obj_t * pObj ) { return p->pMuxes ? Gia_ManObj(p, Abc_Lit2Var(p->pMuxes[Gia_ObjId(p, pObj)])) : 
# 541 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                               ((void *)0)
# 541 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                   ; }
static inline Gia_Obj_t * Gia_ObjFanin( Gia_Obj_t * pObj, int n ) { return n ? Gia_ObjFanin1(pObj) : Gia_ObjFanin0(pObj); }
static inline Gia_Obj_t * Gia_ObjChild0( Gia_Obj_t * pObj ) { return Gia_NotCond( Gia_ObjFanin0(pObj), Gia_ObjFaninC0(pObj) ); }
static inline Gia_Obj_t * Gia_ObjChild1( Gia_Obj_t * pObj ) { return Gia_NotCond( Gia_ObjFanin1(pObj), Gia_ObjFaninC1(pObj) ); }
static inline Gia_Obj_t * Gia_ObjChild2( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_NotCond( Gia_ObjFanin2(p, pObj), Gia_ObjFaninC2(p, pObj) ); }
static inline int Gia_ObjFaninId0( Gia_Obj_t * pObj, int ObjId ) { return ObjId - pObj->iDiff0; }
static inline int Gia_ObjFaninId1( Gia_Obj_t * pObj, int ObjId ) { return ObjId - pObj->iDiff1; }
static inline int Gia_ObjFaninId2( Gia_Man_t * p, int ObjId ) { return (p->pMuxes && p->pMuxes[ObjId]) ? Abc_Lit2Var(p->pMuxes[ObjId]) : -1; }
static inline int Gia_ObjFaninId( Gia_Obj_t * pObj, int ObjId, int n ){ return n ? Gia_ObjFaninId1(pObj, ObjId) : Gia_ObjFaninId0(pObj, ObjId); }
static inline int Gia_ObjFaninId0p( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjFaninId0( pObj, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjFaninId1p( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjFaninId1( pObj, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjFaninId2p( Gia_Man_t * p, Gia_Obj_t * pObj ) { return (p->pMuxes && p->pMuxes[Gia_ObjId(p, pObj)]) ? Abc_Lit2Var(p->pMuxes[Gia_ObjId(p, pObj)]) : -1; }
static inline int Gia_ObjFaninIdp( Gia_Man_t * p, Gia_Obj_t * pObj, int n){ return n ? Gia_ObjFaninId1p(p, pObj) : Gia_ObjFaninId0p(p, pObj); }
static inline int Gia_ObjFaninLit0( Gia_Obj_t * pObj, int ObjId ) { return Abc_Var2Lit( Gia_ObjFaninId0(pObj, ObjId), Gia_ObjFaninC0(pObj) ); }
static inline int Gia_ObjFaninLit1( Gia_Obj_t * pObj, int ObjId ) { return Abc_Var2Lit( Gia_ObjFaninId1(pObj, ObjId), Gia_ObjFaninC1(pObj) ); }
static inline int Gia_ObjFaninLit2( Gia_Man_t * p, int ObjId ) { return (p->pMuxes && p->pMuxes[ObjId]) ? p->pMuxes[ObjId] : -1; }
static inline int Gia_ObjFaninLit( Gia_Obj_t * pObj, int ObjId, int n ){ return n ? Gia_ObjFaninLit1(pObj, ObjId) : Gia_ObjFaninLit0(pObj, ObjId);}
static inline int Gia_ObjFaninLit0p( Gia_Man_t * p, Gia_Obj_t * pObj) { return Abc_Var2Lit( Gia_ObjFaninId0p(p, pObj), Gia_ObjFaninC0(pObj) ); }
static inline int Gia_ObjFaninLit1p( Gia_Man_t * p, Gia_Obj_t * pObj) { return Abc_Var2Lit( Gia_ObjFaninId1p(p, pObj), Gia_ObjFaninC1(pObj) ); }
static inline int Gia_ObjFaninLit2p( Gia_Man_t * p, Gia_Obj_t * pObj) { return (p->pMuxes && p->pMuxes[Gia_ObjId(p, pObj)]) ? p->pMuxes[Gia_ObjId(p, pObj)] : -1; }
static inline int Gia_ObjFaninLitp( Gia_Man_t * p, Gia_Obj_t * pObj, int n ){ return n ? Gia_ObjFaninLit1p(p, pObj) : Gia_ObjFaninLit0p(p, pObj);}
static inline void Gia_ObjFlipFaninC0( Gia_Obj_t * pObj ) { 
# 562 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ((void) sizeof ((
# 562 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsCo(pObj)
# 562 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ? 1 : 0), __extension__ ({ if (
# 562 "/app/abc/src/aig/gia/gia.h"
                                                                                Gia_ObjIsCo(pObj)
# 562 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                ) ; else __assert_fail (
# 562 "/app/abc/src/aig/gia/gia.h"
                                                                                "Gia_ObjIsCo(pObj)"
# 562 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                , "/app/abc/src/aig/gia/gia.h", 562, __extension__ __PRETTY_FUNCTION__); }))
# 562 "/app/abc/src/aig/gia/gia.h"
                                                                                                           ; pObj->fCompl0 ^= 1; }
static inline int Gia_ObjFaninNum( Gia_Man_t * p, Gia_Obj_t * pObj ) { if ( Gia_ObjIsMux(p, pObj) ) return 3; if ( Gia_ObjIsAnd(pObj) ) return 2; if ( Gia_ObjIsCo(pObj) ) return 1; return 0; }
static inline int Gia_ObjWhatFanin( Gia_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pFanin ) { if ( Gia_ObjFanin0(pObj) == pFanin ) return 0; if ( Gia_ObjFanin1(pObj) == pFanin ) return 1; if ( Gia_ObjFanin2(p, pObj) == pFanin ) return 2; 
# 564 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                                                                                                                     ((void) sizeof ((
# 564 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                                                                                                     0
# 564 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                                                                                                                     ) ? 1 : 0), __extension__ ({ if (
# 564 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                                                                                                     0
# 564 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                                                                                                                     ) ; else __assert_fail (
# 564 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                                                                                                     "0"
# 564 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                                                                                                                     , "/app/abc/src/aig/gia/gia.h", 564, __extension__ __PRETTY_FUNCTION__); }))
# 564 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                                                                                                                              ; return -1; }

static inline int Gia_ManCoDriverId( Gia_Man_t * p, int iCoIndex ) { return Gia_ObjFaninId0p(p, Gia_ManCo(p, iCoIndex)); }
static inline int Gia_ManPoIsConst( Gia_Man_t * p, int iPoIndex ) { return Gia_ObjFaninId0p(p, Gia_ManPo(p, iPoIndex)) == 0; }
static inline int Gia_ManPoIsConst0( Gia_Man_t * p, int iPoIndex ) { return Gia_ManIsConst0Lit( Gia_ObjFaninLit0p(p, Gia_ManPo(p, iPoIndex)) ); }
static inline int Gia_ManPoIsConst1( Gia_Man_t * p, int iPoIndex ) { return Gia_ManIsConst1Lit( Gia_ObjFaninLit0p(p, Gia_ManPo(p, iPoIndex)) ); }

static inline Gia_Obj_t * Gia_ObjCopy( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ManObj( p, Abc_Lit2Var(pObj->Value) ); }
static inline int Gia_ObjLitCopy( Gia_Man_t * p, int iLit ) { return Abc_LitNotCond( Gia_ManObj(p, Abc_Lit2Var(iLit))->Value, Abc_LitIsCompl(iLit)); }

static inline int Gia_ObjFanin0Copy( Gia_Obj_t * pObj ) { return Abc_LitNotCond( Gia_ObjFanin0(pObj)->Value, Gia_ObjFaninC0(pObj) ); }
static inline int Gia_ObjFanin1Copy( Gia_Obj_t * pObj ) { return Abc_LitNotCond( Gia_ObjFanin1(pObj)->Value, Gia_ObjFaninC1(pObj) ); }
static inline int Gia_ObjFanin2Copy( Gia_Man_t * p, Gia_Obj_t * pObj ){ return Abc_LitNotCond(Gia_ObjFanin2(p, pObj)->Value, Gia_ObjFaninC2(p, pObj)); }

static inline int Gia_ObjCopyF( Gia_Man_t * p, int f, Gia_Obj_t * pObj ) { return Vec_IntEntry(&p->vCopies, Gia_ManObjNum(p) * f + Gia_ObjId(p,pObj)); }
static inline void Gia_ObjSetCopyF( Gia_Man_t * p, int f, Gia_Obj_t * pObj, int iLit ) { Vec_IntWriteEntry(&p->vCopies, Gia_ManObjNum(p) * f + Gia_ObjId(p,pObj), iLit); }
static inline int Gia_ObjCopyArray( Gia_Man_t * p, int iObj ) { return Vec_IntEntry(&p->vCopies, iObj); }
static inline void Gia_ObjSetCopyArray( Gia_Man_t * p, int iObj, int iLit ) { Vec_IntWriteEntry(&p->vCopies, iObj, iLit); }
static inline void Gia_ManCleanCopyArray( Gia_Man_t * p ) { Vec_IntFill( &p->vCopies, Gia_ManObjNum(p), -1 ); }

static inline int Gia_ObjCopy2Array( Gia_Man_t * p, int iObj ) { return Vec_IntEntry(&p->vCopies2, iObj); }
static inline void Gia_ObjSetCopy2Array( Gia_Man_t * p, int iObj, int iLit ) { Vec_IntWriteEntry(&p->vCopies2, iObj, iLit); }
static inline void Gia_ManCleanCopy2Array( Gia_Man_t * p ) { Vec_IntFill( &p->vCopies2, Gia_ManObjNum(p), -1 ); }

static inline int Gia_ObjFanin0CopyF( Gia_Man_t * p, int f, Gia_Obj_t * pObj ) { return Abc_LitNotCond(Gia_ObjCopyF(p, f, Gia_ObjFanin0(pObj)), Gia_ObjFaninC0(pObj)); }
static inline int Gia_ObjFanin1CopyF( Gia_Man_t * p, int f, Gia_Obj_t * pObj ) { return Abc_LitNotCond(Gia_ObjCopyF(p, f, Gia_ObjFanin1(pObj)), Gia_ObjFaninC1(pObj)); }
static inline int Gia_ObjFanin0CopyArray( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Abc_LitNotCond(Gia_ObjCopyArray(p, Gia_ObjFaninId0p(p,pObj)), Gia_ObjFaninC0(pObj)); }
static inline int Gia_ObjFanin1CopyArray( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Abc_LitNotCond(Gia_ObjCopyArray(p, Gia_ObjFaninId1p(p,pObj)), Gia_ObjFaninC1(pObj)); }

static inline Gia_Obj_t * Gia_ObjFromLit( Gia_Man_t * p, int iLit ) { return Gia_NotCond( Gia_ManObj(p, Abc_Lit2Var(iLit)), Abc_LitIsCompl(iLit) ); }
static inline int Gia_ObjToLit( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Abc_Var2Lit( Gia_ObjId(p, Gia_Regular(pObj)), Gia_IsComplement(pObj) ); }
static inline int Gia_ObjPhaseRealLit( Gia_Man_t * p, int iLit ) { return Gia_ObjPhaseReal( Gia_ObjFromLit(p, iLit) ); }

static inline int Gia_ObjLevelId( Gia_Man_t * p, int Id ) { return Vec_IntGetEntry(p->vLevels, Id); }
static inline int Gia_ObjLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjLevelId( p, Gia_ObjId(p,pObj) ); }
static inline void Gia_ObjUpdateLevelId( Gia_Man_t * p, int Id, int l ) { Vec_IntSetEntry(p->vLevels, Id, Abc_MaxInt(Vec_IntEntry(p->vLevels, Id), l)); }
static inline void Gia_ObjSetLevelId( Gia_Man_t * p, int Id, int l ) { Vec_IntSetEntry(p->vLevels, Id, l); }
static inline void Gia_ObjSetLevel( Gia_Man_t * p, Gia_Obj_t * pObj, int l ) { Gia_ObjSetLevelId( p, Gia_ObjId(p,pObj), l ); }
static inline void Gia_ObjSetCoLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 602 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ((void) sizeof ((
# 602 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsCo(pObj)
# 602 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ? 1 : 0), __extension__ ({ if (
# 602 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsCo(pObj)
# 602 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ; else __assert_fail (
# 602 "/app/abc/src/aig/gia/gia.h"
                                                                                  "Gia_ObjIsCo(pObj)"
# 602 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  , "/app/abc/src/aig/gia/gia.h", 602, __extension__ __PRETTY_FUNCTION__); }))
# 602 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; Gia_ObjSetLevel( p, pObj, Gia_ObjLevel(p,Gia_ObjFanin0(pObj)) ); }
static inline void Gia_ObjSetBufLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 603 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ((void) sizeof ((
# 603 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsAnd(pObj)
# 603 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ? 1 : 0), __extension__ ({ if (
# 603 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsAnd(pObj)
# 603 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ; else __assert_fail (
# 603 "/app/abc/src/aig/gia/gia.h"
                                                                                  "Gia_ObjIsAnd(pObj)"
# 603 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  , "/app/abc/src/aig/gia/gia.h", 603, __extension__ __PRETTY_FUNCTION__); }))
# 603 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; Gia_ObjSetLevel( p, pObj, Gia_ObjLevel(p,Gia_ObjFanin0(pObj)) ); }
static inline void Gia_ObjSetAndLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 604 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ((void) sizeof ((
# 604 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsAnd(pObj)
# 604 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ? 1 : 0), __extension__ ({ if (
# 604 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsAnd(pObj)
# 604 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ; else __assert_fail (
# 604 "/app/abc/src/aig/gia/gia.h"
                                                                                  "Gia_ObjIsAnd(pObj)"
# 604 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  , "/app/abc/src/aig/gia/gia.h", 604, __extension__ __PRETTY_FUNCTION__); }))
# 604 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; Gia_ObjSetLevel( p, pObj, 1+Abc_MaxInt(Gia_ObjLevel(p,Gia_ObjFanin0(pObj)),Gia_ObjLevel(p,Gia_ObjFanin1(pObj))) ); }
static inline void Gia_ObjSetXorLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 605 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ((void) sizeof ((
# 605 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsXor(pObj)
# 605 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ? 1 : 0), __extension__ ({ if (
# 605 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsXor(pObj)
# 605 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ; else __assert_fail (
# 605 "/app/abc/src/aig/gia/gia.h"
                                                                                  "Gia_ObjIsXor(pObj)"
# 605 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  , "/app/abc/src/aig/gia/gia.h", 605, __extension__ __PRETTY_FUNCTION__); }))
# 605 "/app/abc/src/aig/gia/gia.h"
                                                                                                              ; Gia_ObjSetLevel( p, pObj, 2+Abc_MaxInt(Gia_ObjLevel(p,Gia_ObjFanin0(pObj)),Gia_ObjLevel(p,Gia_ObjFanin1(pObj))) ); }
static inline void Gia_ObjSetMuxLevel( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 606 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ((void) sizeof ((
# 606 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsMux(p,pObj)
# 606 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ? 1 : 0), __extension__ ({ if (
# 606 "/app/abc/src/aig/gia/gia.h"
                                                                                  Gia_ObjIsMux(p,pObj)
# 606 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  ) ; else __assert_fail (
# 606 "/app/abc/src/aig/gia/gia.h"
                                                                                  "Gia_ObjIsMux(p,pObj)"
# 606 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                  , "/app/abc/src/aig/gia/gia.h", 606, __extension__ __PRETTY_FUNCTION__); }))
# 606 "/app/abc/src/aig/gia/gia.h"
                                                                                                                ; Gia_ObjSetLevel( p, pObj, 2+Abc_MaxInt( Abc_MaxInt(Gia_ObjLevel(p,Gia_ObjFanin0(pObj)),Gia_ObjLevel(p,Gia_ObjFanin1(pObj))), Gia_ObjLevel(p,Gia_ObjFanin2(p,pObj))) ); }
static inline void Gia_ObjSetGateLevel( Gia_Man_t * p, Gia_Obj_t * pObj ){ if ( !p->fGiaSimple && Gia_ObjIsBuf(pObj) ) Gia_ObjSetBufLevel(p, pObj); else if ( Gia_ObjIsMux(p,pObj) ) Gia_ObjSetMuxLevel(p, pObj); else if ( Gia_ObjIsXor(pObj) ) Gia_ObjSetXorLevel(p, pObj); else if ( Gia_ObjIsAnd(pObj) ) Gia_ObjSetAndLevel(p, pObj); }

static inline int Gia_ObjHasNumId( Gia_Man_t * p, int Id ) { return Vec_IntEntry(p->vTtNums, Id) > -(1000000000); }
static inline int Gia_ObjNumId( Gia_Man_t * p, int Id ) { return Vec_IntEntry(p->vTtNums, Id); }
static inline int Gia_ObjNum( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Vec_IntEntry(p->vTtNums, Gia_ObjId(p,pObj)); }
static inline void Gia_ObjSetNumId( Gia_Man_t * p, int Id, int n ) { Vec_IntWriteEntry(p->vTtNums, Id, n); }
static inline void Gia_ObjSetNum( Gia_Man_t * p, Gia_Obj_t * pObj, int n ) { Vec_IntWriteEntry(p->vTtNums, Gia_ObjId(p,pObj), n); }
static inline void Gia_ObjResetNumId( Gia_Man_t * p, int Id ) { Vec_IntWriteEntry(p->vTtNums, Id, -(1000000000)); }

static inline int Gia_ObjRefNumId( Gia_Man_t * p, int Id ) { return p->pRefs[Id]; }
static inline int Gia_ObjRefIncId( Gia_Man_t * p, int Id ) { return p->pRefs[Id]++; }
static inline int Gia_ObjRefDecId( Gia_Man_t * p, int Id ) { return --p->pRefs[Id]; }
static inline int Gia_ObjRefNum( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjRefNumId( p, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjRefInc( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjRefIncId( p, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjRefDec( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjRefDecId( p, Gia_ObjId(p, pObj) ); }
static inline void Gia_ObjRefFanin0Inc(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefInc(p, Gia_ObjFanin0(pObj)); }
static inline void Gia_ObjRefFanin1Inc(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefInc(p, Gia_ObjFanin1(pObj)); }
static inline void Gia_ObjRefFanin2Inc(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefInc(p, Gia_ObjFanin2(p, pObj)); }
static inline void Gia_ObjRefFanin0Dec(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefDec(p, Gia_ObjFanin0(pObj)); }
static inline void Gia_ObjRefFanin1Dec(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefDec(p, Gia_ObjFanin1(pObj)); }
static inline void Gia_ObjRefFanin2Dec(Gia_Man_t * p, Gia_Obj_t * pObj) { Gia_ObjRefDec(p, Gia_ObjFanin2(p, pObj)); }

static inline int Gia_ObjLutRefNumId( Gia_Man_t * p, int Id ) { 
# 629 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 629 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 629 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 629 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 629 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 629 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 629 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 629, __extension__ __PRETTY_FUNCTION__); }))
# 629 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return p->pLutRefs[Id]; }
static inline int Gia_ObjLutRefIncId( Gia_Man_t * p, int Id ) { 
# 630 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 630 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 630 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 630 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 630 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 630 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 630 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 630, __extension__ __PRETTY_FUNCTION__); }))
# 630 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return p->pLutRefs[Id]++; }
static inline int Gia_ObjLutRefDecId( Gia_Man_t * p, int Id ) { 
# 631 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 631 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 631 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 631 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 631 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 631 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 631 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 631, __extension__ __PRETTY_FUNCTION__); }))
# 631 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return --p->pLutRefs[Id]; }
static inline int Gia_ObjLutRefNum( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 632 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 632 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 632 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 632 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 632 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 632 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 632 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 632, __extension__ __PRETTY_FUNCTION__); }))
# 632 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return p->pLutRefs[Gia_ObjId(p, pObj)]; }
static inline int Gia_ObjLutRefInc( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 633 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 633 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 633 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 633 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 633 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 633 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 633 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 633, __extension__ __PRETTY_FUNCTION__); }))
# 633 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return p->pLutRefs[Gia_ObjId(p, pObj)]++; }
static inline int Gia_ObjLutRefDec( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 634 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ((void) sizeof ((
# 634 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 634 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ? 1 : 0), __extension__ ({ if (
# 634 "/app/abc/src/aig/gia/gia.h"
                                                                                    p->pLutRefs
# 634 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    ) ; else __assert_fail (
# 634 "/app/abc/src/aig/gia/gia.h"
                                                                                    "p->pLutRefs"
# 634 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                    , "/app/abc/src/aig/gia/gia.h", 634, __extension__ __PRETTY_FUNCTION__); }))
# 634 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; return --p->pLutRefs[Gia_ObjId(p, pObj)]; }

static inline void Gia_ObjSetTravIdCurrent( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 636 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 636 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 636 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 636 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 636 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 636 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Gia_ObjId(p, pObj) < p->nTravIdsAlloc"
# 636 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 636, __extension__ __PRETTY_FUNCTION__); }))
# 636 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                              ; p->pTravIds[Gia_ObjId(p, pObj)] = p->nTravIds; }
static inline void Gia_ObjSetTravIdPrevious( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 637 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 637 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 637 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 637 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 637 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 637 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Gia_ObjId(p, pObj) < p->nTravIdsAlloc"
# 637 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 637, __extension__ __PRETTY_FUNCTION__); }))
# 637 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                              ; p->pTravIds[Gia_ObjId(p, pObj)] = p->nTravIds - 1; }
static inline int Gia_ObjIsTravIdCurrent( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 638 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 638 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 638 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 638 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 638 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 638 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Gia_ObjId(p, pObj) < p->nTravIdsAlloc"
# 638 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 638, __extension__ __PRETTY_FUNCTION__); }))
# 638 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                              ; return (p->pTravIds[Gia_ObjId(p, pObj)] == p->nTravIds); }
static inline int Gia_ObjIsTravIdPrevious( Gia_Man_t * p, Gia_Obj_t * pObj ) { 
# 639 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 639 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 639 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 639 "/app/abc/src/aig/gia/gia.h"
                                                                                               Gia_ObjId(p, pObj) < p->nTravIdsAlloc
# 639 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 639 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Gia_ObjId(p, pObj) < p->nTravIdsAlloc"
# 639 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 639, __extension__ __PRETTY_FUNCTION__); }))
# 639 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                              ; return (p->pTravIds[Gia_ObjId(p, pObj)] == p->nTravIds - 1); }
static inline int Gia_ObjUpdateTravIdCurrent( Gia_Man_t * p, Gia_Obj_t * pObj ) { if ( Gia_ObjIsTravIdCurrent(p, pObj) ) return 1; Gia_ObjSetTravIdCurrent(p, pObj); return 0; }
static inline int Gia_ObjUpdateTravIdPrevious( Gia_Man_t * p, Gia_Obj_t * pObj ) { if ( Gia_ObjIsTravIdPrevious(p, pObj) ) return 1; Gia_ObjSetTravIdPrevious(p, pObj); return 0; }
static inline void Gia_ObjSetTravIdCurrentId( Gia_Man_t * p, int Id ) { 
# 642 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 642 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 642 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 642 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 642 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 642 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Id < p->nTravIdsAlloc"
# 642 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 642, __extension__ __PRETTY_FUNCTION__); }))
# 642 "/app/abc/src/aig/gia/gia.h"
                                                                                                                              ; p->pTravIds[Id] = p->nTravIds; }
static inline void Gia_ObjSetTravIdPreviousId( Gia_Man_t * p, int Id ) { 
# 643 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 643 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 643 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 643 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 643 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 643 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Id < p->nTravIdsAlloc"
# 643 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 643, __extension__ __PRETTY_FUNCTION__); }))
# 643 "/app/abc/src/aig/gia/gia.h"
                                                                                                                              ; p->pTravIds[Id] = p->nTravIds - 1; }
static inline int Gia_ObjIsTravIdCurrentId( Gia_Man_t * p, int Id ) { 
# 644 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 644 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 644 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 644 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 644 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 644 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Id < p->nTravIdsAlloc"
# 644 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 644, __extension__ __PRETTY_FUNCTION__); }))
# 644 "/app/abc/src/aig/gia/gia.h"
                                                                                                                              ; return (p->pTravIds[Id] == p->nTravIds); }
static inline int Gia_ObjIsTravIdPreviousId( Gia_Man_t * p, int Id ) { 
# 645 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 645 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 645 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ? 1 : 0), __extension__ ({ if (
# 645 "/app/abc/src/aig/gia/gia.h"
                                                                                               Id < p->nTravIdsAlloc
# 645 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ) ; else __assert_fail (
# 645 "/app/abc/src/aig/gia/gia.h"
                                                                                               "Id < p->nTravIdsAlloc"
# 645 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 645, __extension__ __PRETTY_FUNCTION__); }))
# 645 "/app/abc/src/aig/gia/gia.h"
                                                                                                                              ; return (p->pTravIds[Id] == p->nTravIds - 1); }
static inline int Gia_ObjUpdateTravIdCurrentId( Gia_Man_t * p, int Id ) { if ( Gia_ObjIsTravIdCurrentId(p, Id) ) return 1; Gia_ObjSetTravIdCurrentId(p, Id); return 0; }
static inline int Gia_ObjUpdateTravIdPreviousId( Gia_Man_t * p, int Id ) { if ( Gia_ObjIsTravIdPreviousId(p, Id) ) return 1; Gia_ObjSetTravIdPreviousId(p, Id); return 0; }

static inline void Gia_ManTimeClean( Gia_Man_t * p ) { int i; 
# 649 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                      ((void) sizeof ((
# 649 "/app/abc/src/aig/gia/gia.h"
                                                                                                      p->vTiming != 
# 649 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                      ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 649 "/app/abc/src/aig/gia/gia.h"
                                                                                                      p->vTiming != 
# 649 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                      ((void *)0)) ; else __assert_fail (
# 649 "/app/abc/src/aig/gia/gia.h"
                                                                                                      "p->vTiming != NULL"
# 649 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                      , "/app/abc/src/aig/gia/gia.h", 649, __extension__ __PRETTY_FUNCTION__); }))
# 649 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                  ; Vec_FltFill(p->vTiming, 3*Gia_ManObjNum(p), 0); for ( i = 0; i < Gia_ManObjNum(p); i++ ) Vec_FltWriteEntry( p->vTiming, 3*i+1, (float)((1000000000)) ); }
static inline void Gia_ManTimeStart( Gia_Man_t * p ) { 
# 650 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 650 "/app/abc/src/aig/gia/gia.h"
                                                                                               p->vTiming == 
# 650 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 650 "/app/abc/src/aig/gia/gia.h"
                                                                                               p->vTiming == 
# 650 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void *)0)) ; else __assert_fail (
# 650 "/app/abc/src/aig/gia/gia.h"
                                                                                               "p->vTiming == NULL"
# 650 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 650, __extension__ __PRETTY_FUNCTION__); }))
# 650 "/app/abc/src/aig/gia/gia.h"
                                                                                                                           ; p->vTiming = Vec_FltAlloc(0); Gia_ManTimeClean( p ); }
static inline void Gia_ManTimeStop( Gia_Man_t * p ) { 
# 651 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void) sizeof ((
# 651 "/app/abc/src/aig/gia/gia.h"
                                                                                               p->vTiming != 
# 651 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 651 "/app/abc/src/aig/gia/gia.h"
                                                                                               p->vTiming != 
# 651 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               ((void *)0)) ; else __assert_fail (
# 651 "/app/abc/src/aig/gia/gia.h"
                                                                                               "p->vTiming != NULL"
# 651 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                               , "/app/abc/src/aig/gia/gia.h", 651, __extension__ __PRETTY_FUNCTION__); }))
# 651 "/app/abc/src/aig/gia/gia.h"
                                                                                                                           ; Vec_FltFreeP(&p->vTiming); }
static inline float Gia_ObjTimeArrival( Gia_Man_t * p, int Id ) { return Vec_FltEntry(p->vTiming, 3*Id+0); }
static inline float Gia_ObjTimeRequired( Gia_Man_t * p, int Id ) { return Vec_FltEntry(p->vTiming, 3*Id+1); }
static inline float Gia_ObjTimeSlack( Gia_Man_t * p, int Id ) { return Vec_FltEntry(p->vTiming, 3*Id+2); }
static inline float Gia_ObjTimeArrivalObj( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjTimeArrival( p, Gia_ObjId(p, pObj) ); }
static inline float Gia_ObjTimeRequiredObj( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjTimeRequired( p, Gia_ObjId(p, pObj) ); }
static inline float Gia_ObjTimeSlackObj( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjTimeSlack( p, Gia_ObjId(p, pObj) ); }
static inline void Gia_ObjSetTimeArrival( Gia_Man_t * p, int Id, float t ) { Vec_FltWriteEntry( p->vTiming, 3*Id+0, t ); }
static inline void Gia_ObjSetTimeRequired( Gia_Man_t * p, int Id, float t ) { Vec_FltWriteEntry( p->vTiming, 3*Id+1, t ); }
static inline void Gia_ObjSetTimeSlack( Gia_Man_t * p, int Id, float t ) { Vec_FltWriteEntry( p->vTiming, 3*Id+2, t ); }
static inline void Gia_ObjSetTimeArrivalObj( Gia_Man_t * p, Gia_Obj_t * pObj, float t ) { Gia_ObjSetTimeArrival( p, Gia_ObjId(p, pObj), t ); }
static inline void Gia_ObjSetTimeRequiredObj( Gia_Man_t * p, Gia_Obj_t * pObj, float t ) { Gia_ObjSetTimeRequired( p, Gia_ObjId(p, pObj), t ); }
static inline void Gia_ObjSetTimeSlackObj( Gia_Man_t * p, Gia_Obj_t * pObj, float t ) { Gia_ObjSetTimeSlack( p, Gia_ObjId(p, pObj), t ); }

static inline int Gia_ObjSimWords( Gia_Man_t * p ) { return Vec_WrdSize( p->vSimsPi ) / Gia_ManPiNum( p ); }
static inline word * Gia_ObjSimPi( Gia_Man_t * p, int PiId ) { return Vec_WrdEntryP( p->vSimsPi, PiId * Gia_ObjSimWords(p) ); }
static inline word * Gia_ObjSim( Gia_Man_t * p, int Id ) { return Vec_WrdEntryP( p->vSims, Id * Gia_ObjSimWords(p) ); }
static inline word * Gia_ObjSimObj( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjSim( p, Gia_ObjId(p, pObj) ); }


extern void Gia_ObjAddFanout( Gia_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pFanout );
static inline Gia_Obj_t * Gia_ManAppendObj( Gia_Man_t * p )
{
    if ( p->nObjs == p->nObjsAlloc )
    {
        int nObjNew = Abc_MinInt( 2 * p->nObjsAlloc, (1 << 29) );
        if ( p->nObjs == (1 << 29) )
            printf( "Hard limit on the number of nodes (2^29) is reached. Quitting...\n" ), exit(1);
        
# 679 "/app/abc/src/aig/gia/gia.h" 3 4
       ((void) sizeof ((
# 679 "/app/abc/src/aig/gia/gia.h"
       p->nObjs < nObjNew
# 679 "/app/abc/src/aig/gia/gia.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 679 "/app/abc/src/aig/gia/gia.h"
       p->nObjs < nObjNew
# 679 "/app/abc/src/aig/gia/gia.h" 3 4
       ) ; else __assert_fail (
# 679 "/app/abc/src/aig/gia/gia.h"
       "p->nObjs < nObjNew"
# 679 "/app/abc/src/aig/gia/gia.h" 3 4
       , "/app/abc/src/aig/gia/gia.h", 679, __extension__ __PRETTY_FUNCTION__); }))
# 679 "/app/abc/src/aig/gia/gia.h"
                                   ;
        if ( p->fVerbose )
            printf("Extending GIA object storage: %d -> %d.\n", p->nObjsAlloc, nObjNew );
        
# 682 "/app/abc/src/aig/gia/gia.h" 3 4
       ((void) sizeof ((
# 682 "/app/abc/src/aig/gia/gia.h"
       p->nObjsAlloc > 0
# 682 "/app/abc/src/aig/gia/gia.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 682 "/app/abc/src/aig/gia/gia.h"
       p->nObjsAlloc > 0
# 682 "/app/abc/src/aig/gia/gia.h" 3 4
       ) ; else __assert_fail (
# 682 "/app/abc/src/aig/gia/gia.h"
       "p->nObjsAlloc > 0"
# 682 "/app/abc/src/aig/gia/gia.h" 3 4
       , "/app/abc/src/aig/gia/gia.h", 682, __extension__ __PRETTY_FUNCTION__); }))
# 682 "/app/abc/src/aig/gia/gia.h"
                                  ;
        p->pObjs = ((p->pObjs) ? ((Gia_Obj_t *) realloc((char *)(p->pObjs), sizeof(Gia_Obj_t) * (size_t)(nObjNew))) : ((Gia_Obj_t *) malloc(sizeof(Gia_Obj_t) * (size_t)(nObjNew))));
        memset( p->pObjs + p->nObjsAlloc, 0, sizeof(Gia_Obj_t) * (nObjNew - p->nObjsAlloc) );
        if ( p->pMuxes )
        {
            p->pMuxes = ((p->pMuxes) ? ((unsigned *) realloc((char *)(p->pMuxes), sizeof(unsigned) * (size_t)(nObjNew))) : ((unsigned *) malloc(sizeof(unsigned) * (size_t)(nObjNew))));
            memset( p->pMuxes + p->nObjsAlloc, 0, sizeof(unsigned) * (nObjNew - p->nObjsAlloc) );
        }
        p->nObjsAlloc = nObjNew;
    }
    if ( Vec_IntSize(&p->vHTable) ) Vec_IntPush( &p->vHash, 0 );
    return Gia_ManObj( p, p->nObjs++ );
}
static inline int Gia_ManAppendCi( Gia_Man_t * p )
{
    Gia_Obj_t * pObj = Gia_ManAppendObj( p );
    pObj->fTerm = 1;
    pObj->iDiff0 = 0x1FFFFFFF;
    pObj->iDiff1 = Vec_IntSize( p->vCis );
    Vec_IntPush( p->vCis, Gia_ObjId(p, pObj) );
    return Gia_ObjId( p, pObj ) << 1;
}

extern void Gia_ManQuantSetSuppAnd( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManBuiltInSimPerform( Gia_Man_t * p, int iObj );

static inline int Gia_ManAppendAnd( Gia_Man_t * p, int iLit0, int iLit1 )
{
    Gia_Obj_t * pObj = Gia_ManAppendObj( p );
    
# 711 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 711 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 711 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 711 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 711 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 711 "/app/abc/src/aig/gia/gia.h"
   "iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)"
# 711 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 711, __extension__ __PRETTY_FUNCTION__); }))
# 711 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 712 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 712 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 712 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 712 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 712 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 712 "/app/abc/src/aig/gia/gia.h"
   "iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)"
# 712 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 712, __extension__ __PRETTY_FUNCTION__); }))
# 712 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 713 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 713 "/app/abc/src/aig/gia/gia.h"
   p->fGiaSimple || Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 713 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 713 "/app/abc/src/aig/gia/gia.h"
   p->fGiaSimple || Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 713 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 713 "/app/abc/src/aig/gia/gia.h"
   "p->fGiaSimple || Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)"
# 713 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 713, __extension__ __PRETTY_FUNCTION__); }))
# 713 "/app/abc/src/aig/gia/gia.h"
                                                                      ;
    if ( iLit0 < iLit1 )
    {
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit1));
    }
    else
    {
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit1));
    }
    if ( p->pFanData )
    {
        Gia_ObjAddFanout( p, Gia_ObjFanin0(pObj), pObj );
        Gia_ObjAddFanout( p, Gia_ObjFanin1(pObj), pObj );
    }
    if ( p->fSweeper )
    {
        Gia_Obj_t * pFan0 = Gia_ObjFanin0(pObj);
        Gia_Obj_t * pFan1 = Gia_ObjFanin1(pObj);
        if ( pFan0->fMark0 ) pFan0->fMark1 = 1; else pFan0->fMark0 = 1;
        if ( pFan1->fMark0 ) pFan1->fMark1 = 1; else pFan1->fMark0 = 1;
        pObj->fPhase = (Gia_ObjPhase(pFan0) ^ Gia_ObjFaninC0(pObj)) & (Gia_ObjPhase(pFan1) ^ Gia_ObjFaninC1(pObj));
    }
    if ( p->fBuiltInSim )
    {
        Gia_Obj_t * pFan0 = Gia_ObjFanin0(pObj);
        Gia_Obj_t * pFan1 = Gia_ObjFanin1(pObj);
        pObj->fPhase = (Gia_ObjPhase(pFan0) ^ Gia_ObjFaninC0(pObj)) & (Gia_ObjPhase(pFan1) ^ Gia_ObjFaninC1(pObj));
        Gia_ManBuiltInSimPerform( p, Gia_ObjId( p, pObj ) );
    }
    if ( p->vSuppWords )
        Gia_ManQuantSetSuppAnd( p, pObj );
    return Gia_ObjId( p, pObj ) << 1;
}
static inline int Gia_ManAppendXorReal( Gia_Man_t * p, int iLit0, int iLit1 )
{
    Gia_Obj_t * pObj = Gia_ManAppendObj( p );
    
# 755 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 755 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 755 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 755 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 755 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 755 "/app/abc/src/aig/gia/gia.h"
   "iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)"
# 755 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 755, __extension__ __PRETTY_FUNCTION__); }))
# 755 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 756 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 756 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 756 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 756 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 756 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 756 "/app/abc/src/aig/gia/gia.h"
   "iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)"
# 756 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 756, __extension__ __PRETTY_FUNCTION__); }))
# 756 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 757 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 757 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 757 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 757 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 757 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 757 "/app/abc/src/aig/gia/gia.h"
   "Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)"
# 757 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 757, __extension__ __PRETTY_FUNCTION__); }))
# 757 "/app/abc/src/aig/gia/gia.h"
                                                     ;


    if ( Abc_Lit2Var(iLit0) > Abc_Lit2Var(iLit1) )
    {
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit1));
    }
    else
    {
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit1));
    }
    p->nXors++;
    return Gia_ObjId( p, pObj ) << 1;
}
static inline int Gia_ManAppendMuxReal( Gia_Man_t * p, int iLitC, int iLit1, int iLit0 )
{
    Gia_Obj_t * pObj = Gia_ManAppendObj( p );
    
# 780 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 780 "/app/abc/src/aig/gia/gia.h"
   p->pMuxes != 
# 780 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 780 "/app/abc/src/aig/gia/gia.h"
   p->pMuxes != 
# 780 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void *)0)) ; else __assert_fail (
# 780 "/app/abc/src/aig/gia/gia.h"
   "p->pMuxes != NULL"
# 780 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 780, __extension__ __PRETTY_FUNCTION__); }))
# 780 "/app/abc/src/aig/gia/gia.h"
                              ;
    
# 781 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 781 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 781 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 781 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 781 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 781 "/app/abc/src/aig/gia/gia.h"
   "iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)"
# 781 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 781, __extension__ __PRETTY_FUNCTION__); }))
# 781 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 782 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 782 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 782 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 782 "/app/abc/src/aig/gia/gia.h"
   iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)
# 782 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 782 "/app/abc/src/aig/gia/gia.h"
   "iLit1 >= 0 && Abc_Lit2Var(iLit1) < Gia_ManObjNum(p)"
# 782 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 782, __extension__ __PRETTY_FUNCTION__); }))
# 782 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 783 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 783 "/app/abc/src/aig/gia/gia.h"
   iLitC >= 0 && Abc_Lit2Var(iLitC) < Gia_ManObjNum(p)
# 783 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 783 "/app/abc/src/aig/gia/gia.h"
   iLitC >= 0 && Abc_Lit2Var(iLitC) < Gia_ManObjNum(p)
# 783 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 783 "/app/abc/src/aig/gia/gia.h"
   "iLitC >= 0 && Abc_Lit2Var(iLitC) < Gia_ManObjNum(p)"
# 783 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 783, __extension__ __PRETTY_FUNCTION__); }))
# 783 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 784 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 784 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 784 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 784 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)
# 784 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 784 "/app/abc/src/aig/gia/gia.h"
   "Abc_Lit2Var(iLit0) != Abc_Lit2Var(iLit1)"
# 784 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 784, __extension__ __PRETTY_FUNCTION__); }))
# 784 "/app/abc/src/aig/gia/gia.h"
                                                     ;
    
# 785 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 785 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit0)
# 785 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 785 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit0)
# 785 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 785 "/app/abc/src/aig/gia/gia.h"
   "Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit0)"
# 785 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 785, __extension__ __PRETTY_FUNCTION__); }))
# 785 "/app/abc/src/aig/gia/gia.h"
                                                     ;
    
# 786 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 786 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit1)
# 786 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 786 "/app/abc/src/aig/gia/gia.h"
   Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit1)
# 786 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 786 "/app/abc/src/aig/gia/gia.h"
   "Abc_Lit2Var(iLitC) != Abc_Lit2Var(iLit1)"
# 786 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 786, __extension__ __PRETTY_FUNCTION__); }))
# 786 "/app/abc/src/aig/gia/gia.h"
                                                     ;
    
# 787 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 787 "/app/abc/src/aig/gia/gia.h"
   !Vec_IntSize(&p->vHTable) || !Abc_LitIsCompl(iLit1)
# 787 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 787 "/app/abc/src/aig/gia/gia.h"
   !Vec_IntSize(&p->vHTable) || !Abc_LitIsCompl(iLit1)
# 787 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 787 "/app/abc/src/aig/gia/gia.h"
   "!Vec_IntSize(&p->vHTable) || !Abc_LitIsCompl(iLit1)"
# 787 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 787, __extension__ __PRETTY_FUNCTION__); }))
# 787 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    if ( Abc_Lit2Var(iLit0) < Abc_Lit2Var(iLit1) )
    {
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit1));
        p->pMuxes[Gia_ObjId(p, pObj)] = iLitC;
    }
    else
    {
        pObj->iDiff1 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0));
        pObj->fCompl1 = (unsigned)(Abc_LitIsCompl(iLit0));
        pObj->iDiff0 = (unsigned)(Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit1));
        pObj->fCompl0 = (unsigned)(Abc_LitIsCompl(iLit1));
        p->pMuxes[Gia_ObjId(p, pObj)] = Abc_LitNot(iLitC);
    }
    p->nMuxes++;
    return Gia_ObjId( p, pObj ) << 1;
}
static inline int Gia_ManAppendBuf( Gia_Man_t * p, int iLit )
{
    Gia_Obj_t * pObj = Gia_ManAppendObj( p );
    
# 810 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 810 "/app/abc/src/aig/gia/gia.h"
   iLit >= 0 && Abc_Lit2Var(iLit) < Gia_ManObjNum(p)
# 810 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 810 "/app/abc/src/aig/gia/gia.h"
   iLit >= 0 && Abc_Lit2Var(iLit) < Gia_ManObjNum(p)
# 810 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 810 "/app/abc/src/aig/gia/gia.h"
   "iLit >= 0 && Abc_Lit2Var(iLit) < Gia_ManObjNum(p)"
# 810 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 810, __extension__ __PRETTY_FUNCTION__); }))
# 810 "/app/abc/src/aig/gia/gia.h"
                                                              ;
    pObj->iDiff0 = pObj->iDiff1 = Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit);
    pObj->fCompl0 = pObj->fCompl1 = Abc_LitIsCompl(iLit);
    p->nBufs++;
    return Gia_ObjId( p, pObj ) << 1;
}
static inline int Gia_ManAppendCo( Gia_Man_t * p, int iLit0 )
{
    Gia_Obj_t * pObj;
    
# 819 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 819 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 819 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 819 "/app/abc/src/aig/gia/gia.h"
   iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)
# 819 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 819 "/app/abc/src/aig/gia/gia.h"
   "iLit0 >= 0 && Abc_Lit2Var(iLit0) < Gia_ManObjNum(p)"
# 819 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 819, __extension__ __PRETTY_FUNCTION__); }))
# 819 "/app/abc/src/aig/gia/gia.h"
                                                                ;
    
# 820 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 820 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjIsCo(Gia_ManObj(p, Abc_Lit2Var(iLit0)))
# 820 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 820 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjIsCo(Gia_ManObj(p, Abc_Lit2Var(iLit0)))
# 820 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 820 "/app/abc/src/aig/gia/gia.h"
   "!Gia_ObjIsCo(Gia_ManObj(p, Abc_Lit2Var(iLit0)))"
# 820 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 820, __extension__ __PRETTY_FUNCTION__); }))
# 820 "/app/abc/src/aig/gia/gia.h"
                                                            ;
    pObj = Gia_ManAppendObj( p );
    pObj->fTerm = 1;
    pObj->iDiff0 = Gia_ObjId(p, pObj) - Abc_Lit2Var(iLit0);
    pObj->fCompl0 = Abc_LitIsCompl(iLit0);
    pObj->iDiff1 = Vec_IntSize( p->vCos );
    Vec_IntPush( p->vCos, Gia_ObjId(p, pObj) );
    if ( p->pFanData )
        Gia_ObjAddFanout( p, Gia_ObjFanin0(pObj), pObj );
    return Gia_ObjId( p, pObj ) << 1;
}
static inline int Gia_ManAppendOr( Gia_Man_t * p, int iLit0, int iLit1 )
{
    return Abc_LitNot(Gia_ManAppendAnd( p, Abc_LitNot(iLit0), Abc_LitNot(iLit1) ));
}
static inline int Gia_ManAppendMux( Gia_Man_t * p, int iCtrl, int iData1, int iData0 )
{
    int iTemp0 = Gia_ManAppendAnd( p, Abc_LitNot(iCtrl), iData0 );
    int iTemp1 = Gia_ManAppendAnd( p, iCtrl, iData1 );
    return Abc_LitNotCond( Gia_ManAppendAnd( p, Abc_LitNot(iTemp0), Abc_LitNot(iTemp1) ), 1 );
}
static inline int Gia_ManAppendMaj( Gia_Man_t * p, int iData0, int iData1, int iData2 )
{
    int iTemp0 = Gia_ManAppendOr( p, iData1, iData2 );
    int iTemp1 = Gia_ManAppendAnd( p, iData0, iTemp0 );
    int iTemp2 = Gia_ManAppendAnd( p, iData1, iData2 );
    return Gia_ManAppendOr( p, iTemp1, iTemp2 );
}
static inline int Gia_ManAppendXor( Gia_Man_t * p, int iLit0, int iLit1 )
{
    return Gia_ManAppendMux( p, iLit0, Abc_LitNot(iLit1), iLit1 );
}

static inline int Gia_ManAppendAnd2( Gia_Man_t * p, int iLit0, int iLit1 )
{
    if ( !p->fGiaSimple )
    {
        if ( iLit0 < 2 )
            return iLit0 ? iLit1 : 0;
        if ( iLit1 < 2 )
            return iLit1 ? iLit0 : 0;
        if ( iLit0 == iLit1 )
            return iLit1;
        if ( iLit0 == Abc_LitNot(iLit1) )
            return 0;
    }
    return Gia_ManAppendAnd( p, iLit0, iLit1 );
}
static inline int Gia_ManAppendOr2( Gia_Man_t * p, int iLit0, int iLit1 )
{
    return Abc_LitNot(Gia_ManAppendAnd2( p, Abc_LitNot(iLit0), Abc_LitNot(iLit1) ));
}
static inline int Gia_ManAppendMux2( Gia_Man_t * p, int iCtrl, int iData1, int iData0 )
{
    int iTemp0 = Gia_ManAppendAnd2( p, Abc_LitNot(iCtrl), iData0 );
    int iTemp1 = Gia_ManAppendAnd2( p, iCtrl, iData1 );
    return Abc_LitNotCond( Gia_ManAppendAnd2( p, Abc_LitNot(iTemp0), Abc_LitNot(iTemp1) ), 1 );
}
static inline int Gia_ManAppendMaj2( Gia_Man_t * p, int iData0, int iData1, int iData2 )
{
    int iTemp0 = Gia_ManAppendOr2( p, iData1, iData2 );
    int iTemp1 = Gia_ManAppendAnd2( p, iData0, iTemp0 );
    int iTemp2 = Gia_ManAppendAnd2( p, iData1, iData2 );
    return Gia_ManAppendOr2( p, iTemp1, iTemp2 );
}
static inline int Gia_ManAppendXor2( Gia_Man_t * p, int iLit0, int iLit1 )
{
    return Gia_ManAppendMux2( p, iLit0, Abc_LitNot(iLit1), iLit1 );
}

static inline int Gia_ManAppendXorReal2( Gia_Man_t * p, int iLit0, int iLit1 )
{
    if ( !p->fGiaSimple )
    {
        if ( iLit0 < 2 )
            return iLit0 ? Abc_LitNot(iLit1) : iLit1;
        if ( iLit1 < 2 )
            return iLit1 ? Abc_LitNot(iLit0) : iLit0;
        if ( iLit0 == iLit1 )
            return 0;
        if ( iLit0 == Abc_LitNot(iLit1) )
            return 1;
    }
    return Gia_ManAppendXorReal( p, iLit0, iLit1 );
}

static inline void Gia_ManPatchCoDriver( Gia_Man_t * p, int iCoIndex, int iLit0 )
{
    Gia_Obj_t * pObjCo = Gia_ManCo( p, iCoIndex );
    
# 909 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 909 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjId(p, pObjCo) > Abc_Lit2Var(iLit0)
# 909 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 909 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjId(p, pObjCo) > Abc_Lit2Var(iLit0)
# 909 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 909 "/app/abc/src/aig/gia/gia.h"
   "Gia_ObjId(p, pObjCo) > Abc_Lit2Var(iLit0)"
# 909 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 909, __extension__ __PRETTY_FUNCTION__); }))
# 909 "/app/abc/src/aig/gia/gia.h"
                                                      ;
    pObjCo->iDiff0 = Gia_ObjId(p, pObjCo) - Abc_Lit2Var(iLit0);
    pObjCo->fCompl0 = Abc_LitIsCompl(iLit0);
}





static inline int Gia_XsimNotCond( int Value, int fCompl )
{
    if ( Value == 3 )
        return 3;
    if ( Value == 1 + fCompl )
        return 1;
    return 2;
}
static inline int Gia_XsimAndCond( int Value0, int fCompl0, int Value1, int fCompl1 )
{
    if ( Value0 == 1 + fCompl0 || Value1 == 1 + fCompl1 )
        return 1;
    if ( Value0 == 3 || Value1 == 3 )
        return 3;
    return 2;
}


static inline void Gia_ObjTerSimSetC( Gia_Obj_t * pObj ) { pObj->fMark0 = 0; pObj->fMark1 = 0; }
static inline void Gia_ObjTerSimSet0( Gia_Obj_t * pObj ) { pObj->fMark0 = 1; pObj->fMark1 = 0; }
static inline void Gia_ObjTerSimSet1( Gia_Obj_t * pObj ) { pObj->fMark0 = 0; pObj->fMark1 = 1; }
static inline void Gia_ObjTerSimSetX( Gia_Obj_t * pObj ) { pObj->fMark0 = 1; pObj->fMark1 = 1; }

static inline int Gia_ObjTerSimGetC( Gia_Obj_t * pObj ) { return !pObj->fMark0 && !pObj->fMark1; }
static inline int Gia_ObjTerSimGet0( Gia_Obj_t * pObj ) { return pObj->fMark0 && !pObj->fMark1; }
static inline int Gia_ObjTerSimGet1( Gia_Obj_t * pObj ) { return !pObj->fMark0 && pObj->fMark1; }
static inline int Gia_ObjTerSimGetX( Gia_Obj_t * pObj ) { return pObj->fMark0 && pObj->fMark1; }

static inline int Gia_ObjTerSimGet0Fanin0( Gia_Obj_t * pObj ) { return (Gia_ObjTerSimGet1(Gia_ObjFanin0(pObj)) && Gia_ObjFaninC0(pObj)) || (Gia_ObjTerSimGet0(Gia_ObjFanin0(pObj)) && !Gia_ObjFaninC0(pObj)); }
static inline int Gia_ObjTerSimGet1Fanin0( Gia_Obj_t * pObj ) { return (Gia_ObjTerSimGet0(Gia_ObjFanin0(pObj)) && Gia_ObjFaninC0(pObj)) || (Gia_ObjTerSimGet1(Gia_ObjFanin0(pObj)) && !Gia_ObjFaninC0(pObj)); }

static inline int Gia_ObjTerSimGet0Fanin1( Gia_Obj_t * pObj ) { return (Gia_ObjTerSimGet1(Gia_ObjFanin1(pObj)) && Gia_ObjFaninC1(pObj)) || (Gia_ObjTerSimGet0(Gia_ObjFanin1(pObj)) && !Gia_ObjFaninC1(pObj)); }
static inline int Gia_ObjTerSimGet1Fanin1( Gia_Obj_t * pObj ) { return (Gia_ObjTerSimGet0(Gia_ObjFanin1(pObj)) && Gia_ObjFaninC1(pObj)) || (Gia_ObjTerSimGet1(Gia_ObjFanin1(pObj)) && !Gia_ObjFaninC1(pObj)); }

static inline void Gia_ObjTerSimAnd( Gia_Obj_t * pObj )
{
    
# 954 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 954 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsAnd(pObj)
# 954 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 954 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsAnd(pObj)
# 954 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 954 "/app/abc/src/aig/gia/gia.h"
   "Gia_ObjIsAnd(pObj)"
# 954 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 954, __extension__ __PRETTY_FUNCTION__); }))
# 954 "/app/abc/src/aig/gia/gia.h"
                               ;
    
# 955 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 955 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )
# 955 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 955 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )
# 955 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 955 "/app/abc/src/aig/gia/gia.h"
   "!Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )"
# 955 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 955, __extension__ __PRETTY_FUNCTION__); }))
# 955 "/app/abc/src/aig/gia/gia.h"
                                                      ;
    
# 956 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 956 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin1(pObj) )
# 956 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 956 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin1(pObj) )
# 956 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 956 "/app/abc/src/aig/gia/gia.h"
   "!Gia_ObjTerSimGetC( Gia_ObjFanin1(pObj) )"
# 956 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 956, __extension__ __PRETTY_FUNCTION__); }))
# 956 "/app/abc/src/aig/gia/gia.h"
                                                      ;
    if ( Gia_ObjTerSimGet0Fanin0(pObj) || Gia_ObjTerSimGet0Fanin1(pObj) )
        Gia_ObjTerSimSet0( pObj );
    else if ( Gia_ObjTerSimGet1Fanin0(pObj) && Gia_ObjTerSimGet1Fanin1(pObj) )
        Gia_ObjTerSimSet1( pObj );
    else
        Gia_ObjTerSimSetX( pObj );
}
static inline void Gia_ObjTerSimCo( Gia_Obj_t * pObj )
{
    
# 966 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 966 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsCo(pObj)
# 966 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 966 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsCo(pObj)
# 966 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 966 "/app/abc/src/aig/gia/gia.h"
   "Gia_ObjIsCo(pObj)"
# 966 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 966, __extension__ __PRETTY_FUNCTION__); }))
# 966 "/app/abc/src/aig/gia/gia.h"
                              ;
    
# 967 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 967 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )
# 967 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 967 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )
# 967 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 967 "/app/abc/src/aig/gia/gia.h"
   "!Gia_ObjTerSimGetC( Gia_ObjFanin0(pObj) )"
# 967 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 967, __extension__ __PRETTY_FUNCTION__); }))
# 967 "/app/abc/src/aig/gia/gia.h"
                                                      ;
    if ( Gia_ObjTerSimGet0Fanin0(pObj) )
        Gia_ObjTerSimSet0( pObj );
    else if ( Gia_ObjTerSimGet1Fanin0(pObj) )
        Gia_ObjTerSimSet1( pObj );
    else
        Gia_ObjTerSimSetX( pObj );
}
static inline void Gia_ObjTerSimRo( Gia_Man_t * p, Gia_Obj_t * pObj )
{
    Gia_Obj_t * pTemp = Gia_ObjRoToRi(p, pObj);
    
# 978 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 978 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsRo(p, pObj)
# 978 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 978 "/app/abc/src/aig/gia/gia.h"
   Gia_ObjIsRo(p, pObj)
# 978 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 978 "/app/abc/src/aig/gia/gia.h"
   "Gia_ObjIsRo(p, pObj)"
# 978 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 978, __extension__ __PRETTY_FUNCTION__); }))
# 978 "/app/abc/src/aig/gia/gia.h"
                                 ;
    
# 979 "/app/abc/src/aig/gia/gia.h" 3 4
   ((void) sizeof ((
# 979 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( pTemp )
# 979 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 979 "/app/abc/src/aig/gia/gia.h"
   !Gia_ObjTerSimGetC( pTemp )
# 979 "/app/abc/src/aig/gia/gia.h" 3 4
   ) ; else __assert_fail (
# 979 "/app/abc/src/aig/gia/gia.h"
   "!Gia_ObjTerSimGetC( pTemp )"
# 979 "/app/abc/src/aig/gia/gia.h" 3 4
   , "/app/abc/src/aig/gia/gia.h", 979, __extension__ __PRETTY_FUNCTION__); }))
# 979 "/app/abc/src/aig/gia/gia.h"
                                        ;
    pObj->fMark0 = pTemp->fMark0;
    pObj->fMark1 = pTemp->fMark1;
}

static inline void Gia_ObjTerSimPrint( Gia_Obj_t * pObj )
{
    if ( Gia_ObjTerSimGet0(pObj) )
        printf( "0" );
    else if ( Gia_ObjTerSimGet1(pObj) )
        printf( "1" );
    else if ( Gia_ObjTerSimGetX(pObj) )
        printf( "X" );
}

static inline int Gia_AigerReadInt( unsigned char * pPos )
{
    int i, Value = 0;
    for ( i = 0; i < 4; i++ )
        Value = (Value << 8) | *pPos++;
    return Value;
}
static inline void Gia_AigerWriteInt( unsigned char * pPos, int Value )
{
    int i;
    for ( i = 3; i >= 0; i-- )
        *pPos++ = (Value >> (8*i)) & 255;
}
static inline unsigned Gia_AigerReadUnsigned( unsigned char ** ppPos )
{
    unsigned x = 0, i = 0;
    unsigned char ch;
    while ((ch = *(*ppPos)++) & 0x80)
        x |= (ch & 0x7f) << (7 * i++);
    return x | (ch << (7 * i));
}
static inline void Gia_AigerWriteUnsigned( Vec_Str_t * vStr, unsigned x )
{
    unsigned char ch;
    while (x & ~0x7f)
    {
        ch = (x & 0x7f) | 0x80;
        Vec_StrPush( vStr, ch );
        x >>= 7;
    }
    ch = x;
    Vec_StrPush( vStr, ch );
}
static inline void Gia_AigerWriteUnsignedFile( FILE * pFile, unsigned x )
{
    unsigned char ch;
    while (x & ~0x7f)
    {
        ch = (x & 0x7f) | 0x80;
        fputc( ch, pFile );
        x >>= 7;
    }
    ch = x;
    fputc( ch, pFile );
}
static inline int Gia_AigerWriteUnsignedBuffer( unsigned char * pBuffer, int Pos, unsigned x )
{
    unsigned char ch;
    while (x & ~0x7f)
    {
        ch = (x & 0x7f) | 0x80;
        pBuffer[Pos++] = ch;
        x >>= 7;
    }
    ch = x;
    pBuffer[Pos++] = ch;
    return Pos;
}

static inline Gia_Obj_t * Gia_ObjReprObj( Gia_Man_t * p, int Id ) { return p->pReprs[Id].iRepr == 0x0FFFFFFF ? 
# 1053 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                       ((void *)0) 
# 1053 "/app/abc/src/aig/gia/gia.h"
                                                                                                                            : Gia_ManObj( p, p->pReprs[Id].iRepr ); }
static inline int Gia_ObjRepr( Gia_Man_t * p, int Id ) { return p->pReprs[Id].iRepr; }
static inline void Gia_ObjSetRepr( Gia_Man_t * p, int Id, int Num ) { 
# 1055 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1055 "/app/abc/src/aig/gia/gia.h"
                                                                              Num == 0x0FFFFFFF || Num < Id
# 1055 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1055 "/app/abc/src/aig/gia/gia.h"
                                                                              Num == 0x0FFFFFFF || Num < Id
# 1055 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1055 "/app/abc/src/aig/gia/gia.h"
                                                                              "Num == GIA_VOID || Num < Id"
# 1055 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1055, __extension__ __PRETTY_FUNCTION__); }))
# 1055 "/app/abc/src/aig/gia/gia.h"
                                                                                                                   ; p->pReprs[Id].iRepr = Num; }
static inline void Gia_ObjSetReprRev( Gia_Man_t * p, int Id, int Num ){ 
# 1056 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1056 "/app/abc/src/aig/gia/gia.h"
                                                                              Num == 0x0FFFFFFF || Num > Id
# 1056 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1056 "/app/abc/src/aig/gia/gia.h"
                                                                              Num == 0x0FFFFFFF || Num > Id
# 1056 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1056 "/app/abc/src/aig/gia/gia.h"
                                                                              "Num == GIA_VOID || Num > Id"
# 1056 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1056, __extension__ __PRETTY_FUNCTION__); }))
# 1056 "/app/abc/src/aig/gia/gia.h"
                                                                                                                   ; p->pReprs[Id].iRepr = Num; }
static inline void Gia_ObjUnsetRepr( Gia_Man_t * p, int Id ) { p->pReprs[Id].iRepr = 0x0FFFFFFF; }
static inline int Gia_ObjHasRepr( Gia_Man_t * p, int Id ) { return p->pReprs[Id].iRepr != 0x0FFFFFFF; }
static inline int Gia_ObjReprSelf( Gia_Man_t * p, int Id ) { return Gia_ObjHasRepr(p, Id) ? Gia_ObjRepr(p, Id) : Id; }
static inline int Gia_ObjSibl( Gia_Man_t * p, int Id ) { return p->pSibls ? p->pSibls[Id] : 0; }
static inline Gia_Obj_t * Gia_ObjSiblObj( Gia_Man_t * p, int Id ) { return (p->pSibls && p->pSibls[Id]) ? Gia_ManObj(p, p->pSibls[Id]) : 
# 1061 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                                                                   ((void *)0)
# 1061 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                                       ; }

static inline int Gia_ObjProved( Gia_Man_t * p, int Id ) { return p->pReprs[Id].fProved; }
static inline void Gia_ObjSetProved( Gia_Man_t * p, int Id ) { p->pReprs[Id].fProved = 1; }
static inline void Gia_ObjUnsetProved( Gia_Man_t * p, int Id ) { p->pReprs[Id].fProved = 0; }

static inline int Gia_ObjFailed( Gia_Man_t * p, int Id ) { return p->pReprs[Id].fFailed; }
static inline void Gia_ObjSetFailed( Gia_Man_t * p, int Id ) { p->pReprs[Id].fFailed = 1; }

static inline int Gia_ObjColor( Gia_Man_t * p, int Id, int c ) { return c? p->pReprs[Id].fColorB : p->pReprs[Id].fColorA; }
static inline int Gia_ObjColors( Gia_Man_t * p, int Id ) { return p->pReprs[Id].fColorB * 2 + p->pReprs[Id].fColorA; }
static inline void Gia_ObjSetColor( Gia_Man_t * p, int Id, int c ) { if (c) p->pReprs[Id].fColorB = 1; else p->pReprs[Id].fColorA = 1; }
static inline void Gia_ObjSetColors( Gia_Man_t * p, int Id ) { p->pReprs[Id].fColorB = p->pReprs[Id].fColorA = 1; }
static inline int Gia_ObjVisitColor( Gia_Man_t * p, int Id, int c ) { int x; if (c) { x = p->pReprs[Id].fColorB; p->pReprs[Id].fColorB = 1; } else { x = p->pReprs[Id].fColorA; p->pReprs[Id].fColorA = 1; } return x; }
static inline int Gia_ObjDiffColors( Gia_Man_t * p, int i, int j ) { return (p->pReprs[i].fColorA ^ p->pReprs[j].fColorA) && (p->pReprs[i].fColorB ^ p->pReprs[j].fColorB); }
static inline int Gia_ObjDiffColors2( Gia_Man_t * p, int i, int j ) { return (p->pReprs[i].fColorA ^ p->pReprs[j].fColorA) || (p->pReprs[i].fColorB ^ p->pReprs[j].fColorB); }

static inline Gia_Obj_t * Gia_ObjNextObj( Gia_Man_t * p, int Id ) { return p->pNexts[Id] == 0 ? 
# 1078 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                          ((void *)0) 
# 1078 "/app/abc/src/aig/gia/gia.h"
                                                                                                               : Gia_ManObj( p, p->pNexts[Id] );}
static inline int Gia_ObjNext( Gia_Man_t * p, int Id ) { return p->pNexts[Id]; }
static inline void Gia_ObjSetNext( Gia_Man_t * p, int Id, int Num ) { p->pNexts[Id] = Num; }

static inline int Gia_ObjIsConst( Gia_Man_t * p, int Id ) { return Gia_ObjRepr(p, Id) == 0; }
static inline int Gia_ObjIsHead( Gia_Man_t * p, int Id ) { return Gia_ObjRepr(p, Id) == 0x0FFFFFFF && Gia_ObjNext(p, Id) > 0; }
static inline int Gia_ObjIsNone( Gia_Man_t * p, int Id ) { return Gia_ObjRepr(p, Id) == 0x0FFFFFFF && Gia_ObjNext(p, Id) <= 0; }
static inline int Gia_ObjIsTail( Gia_Man_t * p, int Id ) { return (Gia_ObjRepr(p, Id) > 0 && Gia_ObjRepr(p, Id) != 0x0FFFFFFF) && Gia_ObjNext(p, Id) <= 0; }
static inline int Gia_ObjIsClass( Gia_Man_t * p, int Id ) { return (Gia_ObjRepr(p, Id) > 0 && Gia_ObjRepr(p, Id) != 0x0FFFFFFF) || Gia_ObjNext(p, Id) > 0; }
static inline int Gia_ObjHasSameRepr( Gia_Man_t * p, int i, int k ) { 
# 1087 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1087 "/app/abc/src/aig/gia/gia.h"
                                                                              k
# 1087 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1087 "/app/abc/src/aig/gia/gia.h"
                                                                              k
# 1087 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1087 "/app/abc/src/aig/gia/gia.h"
                                                                              "k"
# 1087 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1087, __extension__ __PRETTY_FUNCTION__); }))
# 1087 "/app/abc/src/aig/gia/gia.h"
                                                                                         ; return i? (Gia_ObjRepr(p, i) == Gia_ObjRepr(p, k) && Gia_ObjRepr(p, i) != 0x0FFFFFFF) : Gia_ObjRepr(p, k) == 0; }
static inline int Gia_ObjIsFailedPair( Gia_Man_t * p, int i, int k ) { 
# 1088 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1088 "/app/abc/src/aig/gia/gia.h"
                                                                              k
# 1088 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1088 "/app/abc/src/aig/gia/gia.h"
                                                                              k
# 1088 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1088 "/app/abc/src/aig/gia/gia.h"
                                                                              "k"
# 1088 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1088, __extension__ __PRETTY_FUNCTION__); }))
# 1088 "/app/abc/src/aig/gia/gia.h"
                                                                                         ; return i? (Gia_ObjFailed(p, i) || Gia_ObjFailed(p, k)) : Gia_ObjFailed(p, k); }
static inline int Gia_ClassIsPair( Gia_Man_t * p, int i ) { 
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                              Gia_ObjIsHead(p, i)
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                              Gia_ObjIsHead(p, i)
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                              "Gia_ObjIsHead(p, i)"
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1089, __extension__ __PRETTY_FUNCTION__); }))
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                                                           ; 
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                             ((void) sizeof ((
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                                                             Gia_ObjNext(p, i)
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                             ) ? 1 : 0), __extension__ ({ if (
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                                                             Gia_ObjNext(p, i)
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                             ) ; else __assert_fail (
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                                                             "Gia_ObjNext(p, i)"
# 1089 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                             , "/app/abc/src/aig/gia/gia.h", 1089, __extension__ __PRETTY_FUNCTION__); }))
# 1089 "/app/abc/src/aig/gia/gia.h"
                                                                                                                                        ; return Gia_ObjNext(p, Gia_ObjNext(p, i)) <= 0; }
static inline void Gia_ClassUndoPair( Gia_Man_t * p, int i ) { 
# 1090 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ((void) sizeof ((
# 1090 "/app/abc/src/aig/gia/gia.h"
                                                                              Gia_ClassIsPair(p,i)
# 1090 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 1090 "/app/abc/src/aig/gia/gia.h"
                                                                              Gia_ClassIsPair(p,i)
# 1090 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              ) ; else __assert_fail (
# 1090 "/app/abc/src/aig/gia/gia.h"
                                                                              "Gia_ClassIsPair(p,i)"
# 1090 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                              , "/app/abc/src/aig/gia/gia.h", 1090, __extension__ __PRETTY_FUNCTION__); }))
# 1090 "/app/abc/src/aig/gia/gia.h"
                                                                                                            ; Gia_ObjSetRepr(p, Gia_ObjNext(p, i), 0x0FFFFFFF); Gia_ObjSetNext(p, i, 0); }
# 1108 "/app/abc/src/aig/gia/gia.h"
static inline int Gia_ObjFoffsetId( Gia_Man_t * p, int Id ) { return Vec_IntEntry( p->vFanout, Id ); }
static inline int Gia_ObjFoffset( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjFoffsetId( p, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjFanoutNumId( Gia_Man_t * p, int Id ) { return Vec_IntEntry( p->vFanoutNums, Id ); }
static inline int Gia_ObjFanoutNum( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ObjFanoutNumId( p, Gia_ObjId(p, pObj) ); }
static inline int Gia_ObjFanoutId( Gia_Man_t * p, int Id, int i ) { return Vec_IntEntry( p->vFanout, Gia_ObjFoffsetId(p, Id) + i ); }
static inline Gia_Obj_t * Gia_ObjFanout0( Gia_Man_t * p, Gia_Obj_t * pObj ) { return Gia_ManObj( p, Gia_ObjFanoutId(p, Gia_ObjId(p, pObj), 0) ); }
static inline Gia_Obj_t * Gia_ObjFanout( Gia_Man_t * p, Gia_Obj_t * pObj, int i ) { return Gia_ManObj( p, Gia_ObjFanoutId(p, Gia_ObjId(p, pObj), i) ); }
static inline void Gia_ObjSetFanout( Gia_Man_t * p, Gia_Obj_t * pObj, int i, Gia_Obj_t * pFan ) { Vec_IntWriteEntry( p->vFanout, Gia_ObjFoffset(p, pObj) + i, Gia_ObjId(p, pFan) ); }
static inline void Gia_ObjSetFanoutInt( Gia_Man_t * p, Gia_Obj_t * pObj, int i, int x ) { Vec_IntWriteEntry( p->vFanout, Gia_ObjFoffset(p, pObj) + i, x ); }
# 1125 "/app/abc/src/aig/gia/gia.h"
static inline int Gia_ManHasMapping( Gia_Man_t * p ) { return p->vMapping != 
# 1125 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                   ((void *)0)
# 1125 "/app/abc/src/aig/gia/gia.h"
                                                                                                       ; }
static inline int Gia_ObjIsLut( Gia_Man_t * p, int Id ) { return Vec_IntEntry(p->vMapping, Id) != 0; }
static inline int Gia_ObjLutSize( Gia_Man_t * p, int Id ) { return Vec_IntEntry(p->vMapping, Vec_IntEntry(p->vMapping, Id)); }
static inline int * Gia_ObjLutFanins( Gia_Man_t * p, int Id ) { return Vec_IntEntryP(p->vMapping, Vec_IntEntry(p->vMapping, Id)) + 1; }
static inline int Gia_ObjLutFanin( Gia_Man_t * p, int Id, int i ) { return Gia_ObjLutFanins(p, Id)[i]; }
static inline int Gia_ObjLutMuxId( Gia_Man_t * p, int Id ) { return Gia_ObjLutFanins(p, Id)[Gia_ObjLutSize(p, Id)]; }
static inline int Gia_ObjLutIsMux( Gia_Man_t * p, int Id ) { return (int)(Gia_ObjLutMuxId(p, Id) < 0); }

static inline int Gia_ManHasMapping2( Gia_Man_t * p ) { return p->vMapping2 != 
# 1133 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                    ((void *)0)
# 1133 "/app/abc/src/aig/gia/gia.h"
                                                                                                        ; }
static inline int Gia_ObjIsLut2( Gia_Man_t * p, int Id ) { return Vec_IntSize(Vec_WecEntry(p->vMapping2, Id)) != 0; }
static inline int Gia_ObjLutSize2( Gia_Man_t * p, int Id ) { return Vec_IntSize(Vec_WecEntry(p->vMapping2, Id)); }
static inline Vec_Int_t * Gia_ObjLutFanins2( Gia_Man_t * p, int Id ) { return Vec_WecEntry(p->vMapping2, Id); }
static inline int Gia_ObjLutFanin2( Gia_Man_t * p, int Id, int i ) { return Vec_IntEntry(Vec_WecEntry(p->vMapping2, Id), i); }
static inline int Gia_ObjLutFanoutNum2( Gia_Man_t * p, int Id ) { return Vec_IntSize(Vec_WecEntry(p->vFanouts2, Id)); }
static inline int Gia_ObjLutFanout2( Gia_Man_t * p, int Id, int i ) { return Vec_IntEntry(Vec_WecEntry(p->vFanouts2, Id), i); }

static inline int Gia_ManHasCellMapping( Gia_Man_t * p ) { return p->vCellMapping != 
# 1141 "/app/abc/src/aig/gia/gia.h" 3 4
                                                                                                       ((void *)0)
# 1141 "/app/abc/src/aig/gia/gia.h"
                                                                                                           ; }
static inline int Gia_ObjIsCell( Gia_Man_t * p, int iLit ) { return Vec_IntEntry(p->vCellMapping, iLit) != 0; }
static inline int Gia_ObjIsCellInv( Gia_Man_t * p, int iLit ) { return Vec_IntEntry(p->vCellMapping, iLit) == -1; }
static inline int Gia_ObjIsCellBuf( Gia_Man_t * p, int iLit ) { return Vec_IntEntry(p->vCellMapping, iLit) == -2; }
static inline int Gia_ObjCellSize( Gia_Man_t * p, int iLit ) { return Vec_IntEntry(p->vCellMapping, Vec_IntEntry(p->vCellMapping, iLit)); }
static inline int * Gia_ObjCellFanins( Gia_Man_t * p, int iLit ) { return Vec_IntEntryP(p->vCellMapping, Vec_IntEntry(p->vCellMapping, iLit))+1; }
static inline int Gia_ObjCellFanin( Gia_Man_t * p, int iLit, int i ){ return Gia_ObjCellFanins(p, iLit)[i]; }
static inline int Gia_ObjCellId( Gia_Man_t * p, int iLit ) { return Gia_ObjCellFanins(p, iLit)[Gia_ObjCellSize(p, iLit)]; }
# 1268 "/app/abc/src/aig/gia/gia.h"
extern int Gia_FileSize( char * pFileName );
extern Gia_Man_t * Gia_AigerReadFromMemory( char * pContents, int nFileSize, int fGiaSimple, int fSkipStrash, int fCheck );
extern Gia_Man_t * Gia_AigerRead( char * pFileName, int fGiaSimple, int fSkipStrash, int fCheck );
extern void Gia_AigerWrite( Gia_Man_t * p, char * pFileName, int fWriteSymbols, int fCompact, int fWriteNewLine );
extern void Gia_AigerWriteS( Gia_Man_t * p, char * pFileName, int fWriteSymbols, int fCompact, int fWriteNewLine, int fSkipComment );
extern void Gia_DumpAiger( Gia_Man_t * p, char * pFilePrefix, int iFileNum, int nFileNumDigits );
extern Vec_Str_t * Gia_AigerWriteIntoMemoryStr( Gia_Man_t * p );
extern Vec_Str_t * Gia_AigerWriteIntoMemoryStrPart( Gia_Man_t * p, Vec_Int_t * vCis, Vec_Int_t * vAnds, Vec_Int_t * vCos, int nRegs );
extern void Gia_AigerWriteSimple( Gia_Man_t * pInit, char * pFileName );

extern Gia_Man_t * Gia_ManBalance( Gia_Man_t * p, int fSimpleAnd, int fStrict, int fVerbose );
extern Gia_Man_t * Gia_ManAreaBalance( Gia_Man_t * p, int fSimpleAnd, int nNewNodesMax, int fVerbose, int fVeryVerbose );
extern Gia_Man_t * Gia_ManAigSyn2( Gia_Man_t * p, int fOldAlgo, int fCoarsen, int fCutMin, int nRelaxRatio, int fDelayMin, int fVerbose, int fVeryVerbose );
extern Gia_Man_t * Gia_ManAigSyn3( Gia_Man_t * p, int fVerbose, int fVeryVerbose );
extern Gia_Man_t * Gia_ManAigSyn4( Gia_Man_t * p, int fVerbose, int fVeryVerbose );

extern unsigned * Gia_ManConvertAigToTruth( Gia_Man_t * p, Gia_Obj_t * pRoot, Vec_Int_t * vLeaves, Vec_Int_t * vTruth, Vec_Int_t * vVisited );
extern Gia_Man_t * Gia_ManPerformBidec( Gia_Man_t * p, int fVerbose );

extern int Gia_ManVerifyCex( Gia_Man_t * pAig, Abc_Cex_t * p, int fDualOut );
extern int Gia_ManFindFailedPoCex( Gia_Man_t * pAig, Abc_Cex_t * p, int nOutputs );
extern int Gia_ManSetFailedPoCex( Gia_Man_t * pAig, Abc_Cex_t * p );
extern void Gia_ManCounterExampleValueStart( Gia_Man_t * pGia, Abc_Cex_t * pCex );
extern void Gia_ManCounterExampleValueStop( Gia_Man_t * pGia );
extern int Gia_ManCounterExampleValueLookup( Gia_Man_t * pGia, int Id, int iFrame );
extern Abc_Cex_t * Gia_ManCexExtendToIncludeCurrentStates( Gia_Man_t * p, Abc_Cex_t * pCex );
extern Abc_Cex_t * Gia_ManCexExtendToIncludeAllObjects( Gia_Man_t * p, Abc_Cex_t * pCex );

extern Vec_Int_t * Cbs_ManSolveMiter( Gia_Man_t * pGia, int nConfs, Vec_Str_t ** pvStatus, int fVerbose );

typedef struct Cbs_Man_t_ Cbs_Man_t;
extern Cbs_Man_t * Cbs_ManAlloc( Gia_Man_t * pGia );
extern void Cbs_ManStop( Cbs_Man_t * p );
extern int Cbs_ManSolve( Cbs_Man_t * p, Gia_Obj_t * pObj );
extern int Cbs_ManSolve2( Cbs_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pObj2 );
extern Vec_Int_t * Cbs_ManSolveMiterNc( Gia_Man_t * pGia, int nConfs, Vec_Str_t ** pvStatus, int f0Proved, int fVerbose );
extern void Cbs_ManSetConflictNum( Cbs_Man_t * p, int Num );
extern Vec_Int_t * Cbs_ReadModel( Cbs_Man_t * p );

extern Vec_Int_t * Tas_ManSolveMiterNc( Gia_Man_t * pGia, int nConfs, Vec_Str_t ** pvStatus, int fVerbose );

extern void Gia_ManPrintFanio( Gia_Man_t * pGia, int nNodes );
extern Gia_Man_t * Gia_ManDupCof( Gia_Man_t * p, int iVar );
extern Gia_Man_t * Gia_ManDupCofAllInt( Gia_Man_t * p, Vec_Int_t * vSigs, int fVerbose );
extern Gia_Man_t * Gia_ManDupCofAll( Gia_Man_t * p, int nFanLim, int fVerbose );

extern int Gia_ResubVarNum( Vec_Int_t * vResub );
extern word Gia_ResubToTruth6( Vec_Int_t * vResub );
extern int Gia_ManEvalSolutionOne( Gia_Man_t * p, Vec_Wrd_t * vSims, Vec_Wrd_t * vIsfs, Vec_Int_t * vCands, Vec_Int_t * vSet, int nWords, int fVerbose );
extern Vec_Int_t * Gia_ManDeriveSolutionOne( Gia_Man_t * p, Vec_Wrd_t * vSims, Vec_Wrd_t * vIsfs, Vec_Int_t * vCands, Vec_Int_t * vSet, int nWords, int Type );

extern void Gia_ManCollectCis( Gia_Man_t * p, int * pNodes, int nNodes, Vec_Int_t * vSupp );
extern void Gia_ManCollectAnds_rec( Gia_Man_t * p, int iObj, Vec_Int_t * vNodes );
extern void Gia_ManCollectAnds( Gia_Man_t * p, int * pNodes, int nNodes, Vec_Int_t * vNodes, Vec_Int_t * vLeaves );
extern Vec_Int_t * Gia_ManCollectAndsAll( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManCollectNodesCis( Gia_Man_t * p, int * pNodes, int nNodes );
extern int Gia_ManSuppSize( Gia_Man_t * p, int * pNodes, int nNodes );
extern int Gia_ManConeSize( Gia_Man_t * p, int * pNodes, int nNodes );
extern Vec_Vec_t * Gia_ManLevelize( Gia_Man_t * p );
extern Vec_Wec_t * Gia_ManLevelizeR( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManOrderReverse( Gia_Man_t * p );
extern void Gia_ManCollectTfi( Gia_Man_t * p, Vec_Int_t * vRoots, Vec_Int_t * vNodes );
extern void Gia_ManCollectTfo( Gia_Man_t * p, Vec_Int_t * vRoots, Vec_Int_t * vNodes );

extern void Gia_ManDupRemapLiterals( Vec_Int_t * vLits, Gia_Man_t * p );
extern void Gia_ManDupRemapEquiv( Gia_Man_t * pNew, Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupOrderDfs( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupOrderDfsChoices( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupOrderDfsReverse( Gia_Man_t * p, int fRevFans, int fRevOuts );
extern Gia_Man_t * Gia_ManDupOutputGroup( Gia_Man_t * p, int iOutStart, int iOutStop );
extern Gia_Man_t * Gia_ManDupOutputVec( Gia_Man_t * p, Vec_Int_t * vOutPres );
extern Gia_Man_t * Gia_ManDupSelectedOutputs( Gia_Man_t * p, Vec_Int_t * vOutsLeft );
extern Gia_Man_t * Gia_ManDupOrderAiger( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupLastPis( Gia_Man_t * p, int nLastPis );
extern Gia_Man_t * Gia_ManDupFlip( Gia_Man_t * p, int * pInitState );
extern Gia_Man_t * Gia_ManDupCycled( Gia_Man_t * pAig, Abc_Cex_t * pCex, int nFrames );
extern Gia_Man_t * Gia_ManDup( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupNoBuf( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupMap( Gia_Man_t * p, Vec_Int_t * vMap );
extern Gia_Man_t * Gia_ManDup2( Gia_Man_t * p1, Gia_Man_t * p2 );
extern Gia_Man_t * Gia_ManDupWithAttributes( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupRemovePis( Gia_Man_t * p, int nRemPis );
extern Gia_Man_t * Gia_ManDupZero( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupPerm( Gia_Man_t * p, Vec_Int_t * vPiPerm );
extern Gia_Man_t * Gia_ManDupPermFlop( Gia_Man_t * p, Vec_Int_t * vFfPerm );
extern Gia_Man_t * Gia_ManDupPermFlopGap( Gia_Man_t * p, Vec_Int_t * vFfPerm );
extern void Gia_ManDupAppend( Gia_Man_t * p, Gia_Man_t * pTwo );
extern void Gia_ManDupAppendShare( Gia_Man_t * p, Gia_Man_t * pTwo );
extern Gia_Man_t * Gia_ManDupAppendNew( Gia_Man_t * pOne, Gia_Man_t * pTwo );
extern Gia_Man_t * Gia_ManDupAppendCones( Gia_Man_t * p, Gia_Man_t ** ppCones, int nCones, int fOnlyRegs );
extern Gia_Man_t * Gia_ManDupSelf( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupFlopClass( Gia_Man_t * p, int iClass );
extern Gia_Man_t * Gia_ManDupMarked( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupTimes( Gia_Man_t * p, int nTimes );
extern Gia_Man_t * Gia_ManDupDfs( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupDfsOnePo( Gia_Man_t * p, int iPo );
extern Gia_Man_t * Gia_ManDupDfsRehash( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupCofactorVar( Gia_Man_t * p, int iVar, int Value );
extern Gia_Man_t * Gia_ManDupCofactorObj( Gia_Man_t * p, int iObj, int Value );
extern Gia_Man_t * Gia_ManDupMux( int iVar, Gia_Man_t * pCof1, Gia_Man_t * pCof0 );
extern Gia_Man_t * Gia_ManDupBlock( Gia_Man_t * p, int nBlock );
extern Gia_Man_t * Gia_ManDupExist( Gia_Man_t * p, int iVar );
extern Gia_Man_t * Gia_ManDupUniv( Gia_Man_t * p, int iVar );
extern Gia_Man_t * Gia_ManDupDfsSkip( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupDfsCone( Gia_Man_t * p, Gia_Obj_t * pObj );
extern Gia_Man_t * Gia_ManDupConeSupp( Gia_Man_t * p, int iLit, Vec_Int_t * vCiIds );
extern int Gia_ManDupConeBack( Gia_Man_t * p, Gia_Man_t * pNew, Vec_Int_t * vCiIds );
extern int Gia_ManDupConeBackObjs( Gia_Man_t * p, Gia_Man_t * pNew, Vec_Int_t * vObjs );
extern Gia_Man_t * Gia_ManDupDfsNode( Gia_Man_t * p, Gia_Obj_t * pObj );
extern Gia_Man_t * Gia_ManDupDfsLitArray( Gia_Man_t * p, Vec_Int_t * vLits );
extern Gia_Man_t * Gia_ManDupTrimmed( Gia_Man_t * p, int fTrimCis, int fTrimCos, int fDualOut, int OutValue );
extern Gia_Man_t * Gia_ManDupOntop( Gia_Man_t * p, Gia_Man_t * p2 );
extern Gia_Man_t * Gia_ManDupWithNewPo( Gia_Man_t * p1, Gia_Man_t * p2 );
extern Gia_Man_t * Gia_ManDupDfsCiMap( Gia_Man_t * p, int * pCi2Lit, Vec_Int_t * vLits );
extern Gia_Man_t * Gia_ManPermuteInputs( Gia_Man_t * p, int nPpis, int nExtra );
extern Gia_Man_t * Gia_ManDupDfsClasses( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupTopAnd( Gia_Man_t * p, int fVerbose );
extern Gia_Man_t * Gia_ManMiter( Gia_Man_t * pAig0, Gia_Man_t * pAig1, int nInsDup, int fDualOut, int fSeq, int fImplic, int fVerbose );
extern Gia_Man_t * Gia_ManMiterInverse( Gia_Man_t * pBot, Gia_Man_t * pTop, int fDualOut, int fVerbose );
extern Gia_Man_t * Gia_ManDupAndOr( Gia_Man_t * p, int nOuts, int fUseOr, int fCompl );
extern Gia_Man_t * Gia_ManDupZeroUndc( Gia_Man_t * p, char * pInit, int nNewPis, int fGiaSimple, int fVerbose );
extern Gia_Man_t * Gia_ManMiter2( Gia_Man_t * p, char * pInit, int fVerbose );
extern Gia_Man_t * Gia_ManTransformMiter( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManTransformMiter2( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManTransformToDual( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManTransformTwoWord2DualOutput( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManChoiceMiter( Vec_Ptr_t * vGias );
extern Gia_Man_t * Gia_ManDupWithConstraints( Gia_Man_t * p, Vec_Int_t * vPoTypes );
extern Gia_Man_t * Gia_ManDupCones( Gia_Man_t * p, int * pPos, int nPos, int fTrimPis );
extern Gia_Man_t * Gia_ManDupAndCones( Gia_Man_t * p, int * pAnds, int nAnds, int fTrimPis );
extern Gia_Man_t * Gia_ManDupAndConesLimit( Gia_Man_t * p, int * pAnds, int nAnds, int Level );
extern Gia_Man_t * Gia_ManDupAndConesLimit2( Gia_Man_t * p, int * pAnds, int nAnds, int Level );
extern Gia_Man_t * Gia_ManDupOneHot( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupLevelized( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupFromVecs( Gia_Man_t * p, Vec_Int_t * vCis, Vec_Int_t * vAnds, Vec_Int_t * vCos, int nRegs );
extern Gia_Man_t * Gia_ManDupSliced( Gia_Man_t * p, int nSuppMax );
extern Gia_Man_t * Gia_ManDupDemiter( Gia_Man_t * p, int fVerbose );
extern Gia_Man_t * Gia_ManDemiterToDual( Gia_Man_t * p );
extern int Gia_ManDemiterDual( Gia_Man_t * p, Gia_Man_t ** pp0, Gia_Man_t ** pp1 );
extern int Gia_ManDemiterTwoWords( Gia_Man_t * p, Gia_Man_t ** pp0, Gia_Man_t ** pp1 );
extern void Gia_ManProdAdderGen( int nArgA, int nArgB, int Seed, int fSigned, int fCla );

extern void Gia_ManEdgeFromArray( Gia_Man_t * p, Vec_Int_t * vArray );
extern Vec_Int_t * Gia_ManEdgeToArray( Gia_Man_t * p );
extern void Gia_ManConvertPackingToEdges( Gia_Man_t * p );
extern int Gia_ObjCheckEdge( Gia_Man_t * p, int iObj, int iNext );
extern int Gia_ManEvalEdgeDelay( Gia_Man_t * p );
extern int Gia_ManEvalEdgeCount( Gia_Man_t * p );
extern int Gia_ManComputeEdgeDelay( Gia_Man_t * p, int fUseTwo );
extern int Gia_ManComputeEdgeDelay2( Gia_Man_t * p );
extern void Gia_ManUpdateMapping( Gia_Man_t * p, Vec_Int_t * vNodes, Vec_Wec_t * vWin );
extern int Gia_ManEvalWindow( Gia_Man_t * p, Vec_Int_t * vLeaves, Vec_Int_t * vNodes, Vec_Wec_t * vWin, Vec_Int_t * vTemp, int fUseTwo );

extern void Gia_ManDetectSeqSignals( Gia_Man_t * p, int fSetReset, int fVerbose );
extern Gia_Man_t * Gia_ManUnrollAndCofactor( Gia_Man_t * p, int nFrames, int nFanMax, int fVerbose );
extern Gia_Man_t * Gia_ManRemoveEnables( Gia_Man_t * p );

extern void Gia_ManOrigIdsInit( Gia_Man_t * p );
extern void Gia_ManOrigIdsStart( Gia_Man_t * p );
extern void Gia_ManOrigIdsRemap( Gia_Man_t * p, Gia_Man_t * pNew );
extern Gia_Man_t * Gia_ManOrigIdsReduce( Gia_Man_t * p, Vec_Int_t * vPairs );
extern Gia_Man_t * Gia_ManComputeGiaEquivs( Gia_Man_t * pGia, int nConfs, int fVerbose );
extern void Gia_ManEquivFixOutputPairs( Gia_Man_t * p );
extern int Gia_ManCheckTopoOrder( Gia_Man_t * p );
extern int * Gia_ManDeriveNexts( Gia_Man_t * p );
extern void Gia_ManDeriveReprs( Gia_Man_t * p );
extern int Gia_ManEquivCountLits( Gia_Man_t * p );
extern int Gia_ManEquivCountLitsAll( Gia_Man_t * p );
extern int Gia_ManEquivCountClasses( Gia_Man_t * p );
extern void Gia_ManEquivPrintOne( Gia_Man_t * p, int i, int Counter );
extern void Gia_ManEquivPrintClasses( Gia_Man_t * p, int fVerbose, float Mem );
extern Gia_Man_t * Gia_ManEquivReduce( Gia_Man_t * p, int fUseAll, int fDualOut, int fSkipPhase, int fVerbose );
extern Gia_Man_t * Gia_ManEquivReduceAndRemap( Gia_Man_t * p, int fSeq, int fMiterPairs );
extern int Gia_ManEquivSetColors( Gia_Man_t * p, int fVerbose );
extern Gia_Man_t * Gia_ManSpecReduce( Gia_Man_t * p, int fDualOut, int fSynthesis, int fReduce, int fSkipSome, int fVerbose );
extern Gia_Man_t * Gia_ManSpecReduceInit( Gia_Man_t * p, Abc_Cex_t * pInit, int nFrames, int fDualOut );
extern Gia_Man_t * Gia_ManSpecReduceInitFrames( Gia_Man_t * p, Abc_Cex_t * pInit, int nFramesMax, int * pnFrames, int fDualOut, int nMinOutputs );
extern void Gia_ManEquivTransform( Gia_Man_t * p, int fVerbose );
extern void Gia_ManEquivImprove( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManEquivToChoices( Gia_Man_t * p, int nSnapshots );
extern int Gia_ManCountChoiceNodes( Gia_Man_t * p );
extern int Gia_ManCountChoices( Gia_Man_t * p );
extern int Gia_ManFilterEquivsForSpeculation( Gia_Man_t * pGia, char * pName1, char * pName2, int fLatchA, int fLatchB );
extern int Gia_ManFilterEquivsUsingParts( Gia_Man_t * pGia, char * pName1, char * pName2 );
extern void Gia_ManFilterEquivsUsingLatches( Gia_Man_t * pGia, int fFlopsOnly, int fFlopsWith, int fUseRiDrivers );

extern void Gia_ManQuantSetSuppStart( Gia_Man_t * p );
extern void Gia_ManQuantSetSuppZero( Gia_Man_t * p );
extern void Gia_ManQuantSetSuppCi( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManQuantUpdateCiSupp( Gia_Man_t * p, int iObj );
extern int Gia_ManQuantExist( Gia_Man_t * p, int iLit, int(*pFuncCiToKeep)(void *, int), void * pData );

extern void Gia_ObjAddFanout( Gia_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pFanout );
extern void Gia_ObjRemoveFanout( Gia_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pFanout );
extern void Gia_ManFanoutStart( Gia_Man_t * p );
extern void Gia_ManFanoutStop( Gia_Man_t * p );
extern void Gia_ManStaticFanoutStart( Gia_Man_t * p );
extern void Gia_ManStaticFanoutStop( Gia_Man_t * p );
extern void Gia_ManStaticMappingFanoutStart( Gia_Man_t * p, Vec_Int_t ** pvIndex );

extern void For_ManExperiment( Gia_Man_t * pGia, int nIters, int fClustered, int fVerbose );

extern Gia_Man_t * Gia_ManUnrollDup( Gia_Man_t * p, Vec_Int_t * vLimit );
extern Vec_Ptr_t * Gia_ManUnrollAbs( Gia_Man_t * p, int nFrames );
extern void * Gia_ManUnrollStart( Gia_Man_t * pAig, Gia_ParFra_t * pPars );
extern void * Gia_ManUnrollAdd( void * pMan, int fMax );
extern void Gia_ManUnrollStop( void * pMan );
extern int Gia_ManUnrollLastLit( void * pMan );
extern void Gia_ManFraSetDefaultParams( Gia_ParFra_t * p );
extern Gia_Man_t * Gia_ManFrames( Gia_Man_t * pAig, Gia_ParFra_t * pPars );
extern Gia_Man_t * Gia_ManFramesInitSpecial( Gia_Man_t * pAig, int nFrames, int fVerbose );

extern Gia_Man_t * Gia_ManFront( Gia_Man_t * p );
extern void Gia_ManFrontTest( Gia_Man_t * p );

extern Gia_Man_t * Gia_ManPerformFx( Gia_Man_t * p, int nNewNodesMax, int LitCountMax, int fReverse, int fVerbose, int fVeryVerbose );

extern void Gia_ManHashAlloc( Gia_Man_t * p );
extern void Gia_ManHashStart( Gia_Man_t * p );
extern void Gia_ManHashStop( Gia_Man_t * p );
extern int Gia_ManHashXorReal( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManHashMuxReal( Gia_Man_t * p, int iLitC, int iLit1, int iLit0 );
extern int Gia_ManHashAnd( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManHashOr( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManHashXor( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManHashMux( Gia_Man_t * p, int iCtrl, int iData1, int iData0 );
extern int Gia_ManHashMaj( Gia_Man_t * p, int iData0, int iData1, int iData2 );
extern int Gia_ManHashAndTry( Gia_Man_t * p, int iLit0, int iLit1 );
extern Gia_Man_t * Gia_ManRehash( Gia_Man_t * p, int fAddStrash );
extern void Gia_ManHashProfile( Gia_Man_t * p );
extern int Gia_ManHashLookupInt( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManHashLookup( Gia_Man_t * p, Gia_Obj_t * p0, Gia_Obj_t * p1 );
extern int Gia_ManHashAndMulti( Gia_Man_t * p, Vec_Int_t * vLits );
extern int Gia_ManHashAndMulti2( Gia_Man_t * p, Vec_Int_t * vLits );
extern int Gia_ManHashDualMiter( Gia_Man_t * p, Vec_Int_t * vOuts );

extern void Gia_ManPrintMappingStats( Gia_Man_t * p, char * pDumpFile );
extern void Gia_ManPrintPackingStats( Gia_Man_t * p );
extern void Gia_ManPrintLutStats( Gia_Man_t * p );
extern int Gia_ManLutFaninCount( Gia_Man_t * p );
extern int Gia_ManLutSizeMax( Gia_Man_t * p );
extern int Gia_ManLutNum( Gia_Man_t * p );
extern int Gia_ManLutLevel( Gia_Man_t * p, int ** ppLevels );
extern void Gia_ManLutParams( Gia_Man_t * p, int * pnCurLuts, int * pnCurEdges, int * pnCurLevels );
extern void Gia_ManSetRefsMapped( Gia_Man_t * p );
extern void Gia_ManSetLutRefs( Gia_Man_t * p );
extern void Gia_ManSetIfParsDefault( void * pIfPars );
extern void Gia_ManMappingVerify( Gia_Man_t * p );
extern void Gia_ManTransferMapping( Gia_Man_t * p, Gia_Man_t * pGia );
extern void Gia_ManTransferPacking( Gia_Man_t * p, Gia_Man_t * pGia );
extern void Gia_ManTransferTiming( Gia_Man_t * p, Gia_Man_t * pGia );
extern Gia_Man_t * Gia_ManPerformMapping( Gia_Man_t * p, void * pIfPars );
extern Gia_Man_t * Gia_ManPerformSopBalance( Gia_Man_t * p, int nCutNum, int nRelaxRatio, int fVerbose );
extern Gia_Man_t * Gia_ManPerformDsdBalance( Gia_Man_t * p, int nLutSize, int nCutNum, int nRelaxRatio, int fVerbose );
extern Gia_Man_t * Gia_ManDupHashMapping( Gia_Man_t * p );

extern void Jf_ManSetDefaultPars( Jf_Par_t * pPars );
extern Gia_Man_t * Jf_ManPerformMapping( Gia_Man_t * pGia, Jf_Par_t * pPars );
extern Gia_Man_t * Jf_ManDeriveCnf( Gia_Man_t * p, int fCnfObjIds );

extern Gia_Man_t * Gia_ManIsoCanonicize( Gia_Man_t * p, int fVerbose );
extern Gia_Man_t * Gia_ManIsoReduce( Gia_Man_t * p, Vec_Ptr_t ** pvPosEquivs, Vec_Ptr_t ** pvPiPerms, int fEstimate, int fDualOut, int fVerbose, int fVeryVerbose );
extern Gia_Man_t * Gia_ManIsoReduce2( Gia_Man_t * p, Vec_Ptr_t ** pvPosEquivs, Vec_Ptr_t ** pvPiPerms, int fEstimate, int fBetterQual, int fDualOut, int fVerbose, int fVeryVerbose );

extern void Lf_ManSetDefaultPars( Jf_Par_t * pPars );
extern Gia_Man_t * Lf_ManPerformMapping( Gia_Man_t * pGia, Jf_Par_t * pPars );
extern Gia_Man_t * Gia_ManPerformLfMapping( Gia_Man_t * p, Jf_Par_t * pPars, int fNormalized );

extern void Gia_ManTestDistance( Gia_Man_t * p );
extern void Gia_ManSolveProblem( Gia_Man_t * pGia, Emb_Par_t * pPars );

extern Gia_Man_t * Gia_ManStart( int nObjsMax );
extern void Gia_ManStop( Gia_Man_t * p );
extern void Gia_ManStopP( Gia_Man_t ** p );
extern double Gia_ManMemory( Gia_Man_t * p );
extern void Gia_ManPrintStats( Gia_Man_t * p, Gps_Par_t * pPars );
extern void Gia_ManPrintStatsShort( Gia_Man_t * p );
extern void Gia_ManPrintMiterStatus( Gia_Man_t * p );
extern void Gia_ManPrintStatsMiter( Gia_Man_t * p, int fVerbose );
extern void Gia_ManSetRegNum( Gia_Man_t * p, int nRegs );
extern void Gia_ManReportImprovement( Gia_Man_t * p, Gia_Man_t * pNew );
extern void Gia_ManPrintNpnClasses( Gia_Man_t * p );
extern void Gia_ManDumpVerilog( Gia_Man_t * p, char * pFileName, Vec_Int_t * vObjs, int fVerBufs, int fInter, int fInterComb, int fAssign, int fReverse );
extern void Gia_ManDumpVerilogNand( Gia_Man_t * p, char * pFileName );

extern Gia_MmFixed_t * Gia_MmFixedStart( int nEntrySize, int nEntriesMax );
extern void Gia_MmFixedStop( Gia_MmFixed_t * p, int fVerbose );
extern char * Gia_MmFixedEntryFetch( Gia_MmFixed_t * p );
extern void Gia_MmFixedEntryRecycle( Gia_MmFixed_t * p, char * pEntry );
extern void Gia_MmFixedRestart( Gia_MmFixed_t * p );
extern int Gia_MmFixedReadMemUsage( Gia_MmFixed_t * p );
extern int Gia_MmFixedReadMaxEntriesUsed( Gia_MmFixed_t * p );
extern Gia_MmFlex_t * Gia_MmFlexStart();
extern void Gia_MmFlexStop( Gia_MmFlex_t * p, int fVerbose );
extern char * Gia_MmFlexEntryFetch( Gia_MmFlex_t * p, int nBytes );
extern void Gia_MmFlexRestart( Gia_MmFlex_t * p );
extern int Gia_MmFlexReadMemUsage( Gia_MmFlex_t * p );
extern Gia_MmStep_t * Gia_MmStepStart( int nSteps );
extern void Gia_MmStepStop( Gia_MmStep_t * p, int fVerbose );
extern char * Gia_MmStepEntryFetch( Gia_MmStep_t * p, int nBytes );
extern void Gia_MmStepEntryRecycle( Gia_MmStep_t * p, char * pEntry, int nBytes );
extern int Gia_MmStepReadMemUsage( Gia_MmStep_t * p );

extern void Mf_ManSetDefaultPars( Jf_Par_t * pPars );
extern Gia_Man_t * Mf_ManPerformMapping( Gia_Man_t * pGia, Jf_Par_t * pPars );
extern void * Mf_ManGenerateCnf( Gia_Man_t * pGia, int nLutSize, int fCnfObjIds, int fAddOrCla, int fMapping, int fVerbose );

extern Gia_Man_t * Gia_ManReadMiniAig( char * pFileName, int fGiaSimple );
extern void Gia_ManWriteMiniAig( Gia_Man_t * pGia, char * pFileName );
extern Gia_Man_t * Gia_ManReadMiniLut( char * pFileName );
extern void Gia_ManWriteMiniLut( Gia_Man_t * pGia, char * pFileName );

extern word * Gia_ManCountFraction( Gia_Man_t * p, Vec_Wrd_t * vSimI, Vec_Int_t * vSupp, int Thresh, int fVerbose, int * pCare );
extern Vec_Int_t * Gia_ManCollectSuppNew( Gia_Man_t * p, int iOut, int nOuts );

extern void Gia_ManCountMuxXor( Gia_Man_t * p, int * pnMuxes, int * pnXors );
extern void Gia_ManPrintMuxStats( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupMuxes( Gia_Man_t * p, int Limit );
extern Gia_Man_t * Gia_ManDupNoMuxes( Gia_Man_t * p, int fSkipBufs );

extern void Gia_SatVerifyPattern( Gia_Man_t * p, Gia_Obj_t * pRoot, Vec_Int_t * vCex, Vec_Int_t * vVisit );

extern Gia_Man_t * Gia_ManRetimeForward( Gia_Man_t * p, int nMaxIters, int fVerbose );

extern int Sat_ManTest( Gia_Man_t * pGia, Gia_Obj_t * pObj, int nConfsMax );

extern int Gia_ManSeqMarkUsed( Gia_Man_t * p );
extern int Gia_ManCombMarkUsed( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManCleanup( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManCleanupOutputs( Gia_Man_t * p, int nOutputs );
extern Gia_Man_t * Gia_ManSeqCleanup( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManSeqStructSweep( Gia_Man_t * p, int fConst, int fEquiv, int fVerbose );

extern void Gia_ManShow( Gia_Man_t * pMan, Vec_Int_t * vBold, int fAdders, int fFadds, int fPath );

extern Gia_Man_t * Gia_ManMapShrink4( Gia_Man_t * p, int fKeepLevel, int fVerbose );
extern Gia_Man_t * Gia_ManMapShrink6( Gia_Man_t * p, int nFanoutMax, int fKeepLevel, int fVerbose );

extern Gia_Man_t * Gia_ManExtractWindow( Gia_Man_t * p, int LevelMax, int nTimeWindow, int fVerbose );
extern Gia_Man_t * Gia_ManPerformSopBalanceWin( Gia_Man_t * p, int LevelMax, int nTimeWindow, int nCutNum, int nRelaxRatio, int fVerbose );
extern Gia_Man_t * Gia_ManPerformDsdBalanceWin( Gia_Man_t * p, int LevelMax, int nTimeWindow, int nLutSize, int nCutNum, int nRelaxRatio, int fVerbose );

extern int * Gia_SortFloats( float * pArray, int * pPerm, int nSize );

extern void Gia_ManSimSetDefaultParams( Gia_ParSim_t * p );
extern int Gia_ManSimSimulate( Gia_Man_t * pAig, Gia_ParSim_t * pPars );
extern unsigned * Gia_SimDataExt( Gia_ManSim_t * p, int i );
extern unsigned * Gia_SimDataCiExt( Gia_ManSim_t * p, int i );
extern unsigned * Gia_SimDataCoExt( Gia_ManSim_t * p, int i );
extern void Gia_ManSimInfoInit( Gia_ManSim_t * p );
extern void Gia_ManSimInfoTransfer( Gia_ManSim_t * p );
extern void Gia_ManSimulateRound( Gia_ManSim_t * p );
extern void Gia_ManBuiltInSimStart( Gia_Man_t * p, int nWords, int nObjs );
extern void Gia_ManBuiltInSimPerform( Gia_Man_t * p, int iObj );
extern int Gia_ManBuiltInSimCheckOver( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManBuiltInSimCheckEqual( Gia_Man_t * p, int iLit0, int iLit1 );
extern void Gia_ManBuiltInSimResimulateCone( Gia_Man_t * p, int iLit0, int iLit1 );
extern void Gia_ManBuiltInSimResimulate( Gia_Man_t * p );
extern int Gia_ManBuiltInSimAddPat( Gia_Man_t * p, Vec_Int_t * vPat );
extern void Gia_ManIncrSimStart( Gia_Man_t * p, int nWords, int nObjs );
extern void Gia_ManIncrSimSet( Gia_Man_t * p, Vec_Int_t * vObjLits );
extern int Gia_ManIncrSimCheckOver( Gia_Man_t * p, int iLit0, int iLit1 );
extern int Gia_ManIncrSimCheckEqual( Gia_Man_t * p, int iLit0, int iLit1 );

extern Vec_Wrd_t * Gia_ManSimPatSim( Gia_Man_t * p );
extern Vec_Wrd_t * Gia_ManSimPatSimOut( Gia_Man_t * pGia, Vec_Wrd_t * vSimsPi, int fOuts );
extern void Gia_ManSim2ArrayOne( Vec_Wrd_t * vSimsPi, Vec_Int_t * vRes );
extern Vec_Wec_t * Gia_ManSim2Array( Vec_Ptr_t * vSims );
extern Vec_Wrd_t * Gia_ManArray2SimOne( Vec_Int_t * vRes );
extern Vec_Ptr_t * Gia_ManArray2Sim( Vec_Wec_t * vRes );
extern void Gia_ManPtrWrdDumpBin( char * pFileName, Vec_Ptr_t * p, int fVerbose );
extern Vec_Ptr_t * Gia_ManPtrWrdReadBin( char * pFileName, int fVerbose );
extern Vec_Str_t * Gia_ManComputeRange( Gia_Man_t * p );

extern float Gia_ManDelayTraceLut( Gia_Man_t * p );
extern float Gia_ManDelayTraceLutPrint( Gia_Man_t * p, int fVerbose );
extern Gia_Man_t * Gia_ManSpeedup( Gia_Man_t * p, int Percentage, int Degree, int fVerbose, int fVeryVerbose );

extern void Gia_ManComputeOneWinStart( Gia_Man_t * p, int nAnds, int fReverse );
extern int Gia_ManComputeOneWin( Gia_Man_t * p, int iPivot, Vec_Int_t ** pvRoots, Vec_Int_t ** pvNodes, Vec_Int_t ** pvLeaves, Vec_Int_t ** pvAnds );

extern void Gia_ManStgPrint( FILE * pFile, Vec_Int_t * vLines, int nIns, int nOuts, int nStates );
extern Gia_Man_t * Gia_ManStgRead( char * pFileName, int kHot, int fVerbose );

typedef struct Gia_ManMin_t_ Gia_ManMin_t;
extern Gia_ManMin_t * Gia_ManSuppStart( Gia_Man_t * pGia );
extern void Gia_ManSuppStop( Gia_ManMin_t * p );
extern int Gia_ManSupportAnd( Gia_ManMin_t * p, int iLit0, int iLit1 );
typedef struct Gia_Man2Min_t_ Gia_Man2Min_t;
extern Gia_Man2Min_t * Gia_Man2SuppStart( Gia_Man_t * pGia );
extern void Gia_Man2SuppStop( Gia_Man2Min_t * p );
extern int Gia_Man2SupportAnd( Gia_Man2Min_t * p, int iLit0, int iLit1 );

extern Gia_Man_t * Gia_ManFraigSweepSimple( Gia_Man_t * p, void * pPars );
extern Gia_Man_t * Gia_ManSweepWithBoxes( Gia_Man_t * p, void * pParsC, void * pParsS, int fConst, int fEquiv, int fVerbose, int fVerbEquivs );
extern void Gia_ManCheckIntegrityWithBoxes( Gia_Man_t * p );

extern Gia_Man_t * Gia_SweeperStart( Gia_Man_t * p );
extern void Gia_SweeperStop( Gia_Man_t * p );
extern int Gia_SweeperIsRunning( Gia_Man_t * p );
extern void Gia_SweeperPrintStats( Gia_Man_t * p );
extern void Gia_SweeperSetConflictLimit( Gia_Man_t * p, int nConfMax );
extern void Gia_SweeperSetRuntimeLimit( Gia_Man_t * p, int nSeconds );
extern Vec_Int_t * Gia_SweeperGetCex( Gia_Man_t * p );
extern int Gia_SweeperProbeCreate( Gia_Man_t * p, int iLit );
extern int Gia_SweeperProbeDelete( Gia_Man_t * p, int ProbeId );
extern int Gia_SweeperProbeUpdate( Gia_Man_t * p, int ProbeId, int iLitNew );
extern int Gia_SweeperProbeLit( Gia_Man_t * p, int ProbeId );
extern Vec_Int_t * Gia_SweeperCollectValidProbeIds( Gia_Man_t * p );
extern int Gia_SweeperCondPop( Gia_Man_t * p );
extern void Gia_SweeperCondPush( Gia_Man_t * p, int ProbeId );
extern Vec_Int_t * Gia_SweeperCondVector( Gia_Man_t * p );
extern int Gia_SweeperCondCheckUnsat( Gia_Man_t * p );
extern int Gia_SweeperCheckEquiv( Gia_Man_t * p, int ProbeId1, int ProbeId2 );
extern Gia_Man_t * Gia_SweeperExtractUserLogic( Gia_Man_t * p, Vec_Int_t * vProbeIds, Vec_Ptr_t * vInNames, Vec_Ptr_t * vOutNames );
extern void Gia_SweeperLogicDump( Gia_Man_t * p, Vec_Int_t * vProbeIds, int fDumpConds, char * pFileName );
extern Gia_Man_t * Gia_SweeperCleanup( Gia_Man_t * p, char * pCommLime );
extern Vec_Int_t * Gia_SweeperGraft( Gia_Man_t * pDst, Vec_Int_t * vProbes, Gia_Man_t * pSrc );
extern int Gia_SweeperFraig( Gia_Man_t * p, Vec_Int_t * vProbeIds, char * pCommLime, int nWords, int nConfs, int fVerify, int fVerbose );
extern int Gia_SweeperRun( Gia_Man_t * p, Vec_Int_t * vProbeIds, char * pCommLime, int fVerbose );

extern float Gia_ManEvaluateSwitching( Gia_Man_t * p );
extern float Gia_ManComputeSwitching( Gia_Man_t * p, int nFrames, int nPref, int fProbOne );
extern Vec_Int_t * Gia_ManComputeSwitchProbs( Gia_Man_t * pGia, int nFrames, int nPref, int fProbOne );
extern Vec_Int_t * Gia_ManComputeSwitchProbs2( Gia_Man_t * pGia, int nFrames, int nPref, int fProbOne, int nRandPiFactor );
extern Vec_Flt_t * Gia_ManPrintOutputProb( Gia_Man_t * p );

extern int Gia_ManBoxNum( Gia_Man_t * p );
extern int Gia_ManRegBoxNum( Gia_Man_t * p );
extern int Gia_ManNonRegBoxNum( Gia_Man_t * p );
extern int Gia_ManBlackBoxNum( Gia_Man_t * p );
extern int Gia_ManBoxCiNum( Gia_Man_t * p );
extern int Gia_ManBoxCoNum( Gia_Man_t * p );
extern int Gia_ManClockDomainNum( Gia_Man_t * p );
extern int Gia_ManIsSeqWithBoxes( Gia_Man_t * p );
extern int Gia_ManIsNormalized( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManOrderWithBoxes( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupNormalize( Gia_Man_t * p, int fHashMapping );
extern Gia_Man_t * Gia_ManDupUnnormalize( Gia_Man_t * p );
extern Gia_Man_t * Gia_ManDupUnshuffleInputs( Gia_Man_t * p );
extern int Gia_ManLevelWithBoxes( Gia_Man_t * p );
extern int Gia_ManLutLevelWithBoxes( Gia_Man_t * p );
extern void * Gia_ManUpdateTimMan( Gia_Man_t * p, Vec_Int_t * vBoxPres );
extern void * Gia_ManUpdateTimMan2( Gia_Man_t * p, Vec_Int_t * vBoxesLeft, int nTermsDiff );
extern Gia_Man_t * Gia_ManUpdateExtraAig( void * pTime, Gia_Man_t * pAig, Vec_Int_t * vBoxPres );
extern Gia_Man_t * Gia_ManUpdateExtraAig2( void * pTime, Gia_Man_t * pAig, Vec_Int_t * vBoxesLeft );
extern Gia_Man_t * Gia_ManDupCollapse( Gia_Man_t * p, Gia_Man_t * pBoxes, Vec_Int_t * vBoxPres, int fSeq );
extern int Gia_ManVerifyWithBoxes( Gia_Man_t * pGia, int nBTLimit, int nTimeLim, int fSeq, int fDumpFiles, int fVerbose, char * pFileSpec );

extern word Gia_LutComputeTruth6( Gia_Man_t * p, int iObj, Vec_Wrd_t * vTruths );
extern word Gia_ObjComputeTruthTable6Lut( Gia_Man_t * p, int iObj, Vec_Wrd_t * vTemp );
extern word Gia_ObjComputeTruthTable6( Gia_Man_t * p, Gia_Obj_t * pObj, Vec_Int_t * vSupp, Vec_Wrd_t * vTruths );
extern word Gia_ObjComputeTruth6Cis( Gia_Man_t * p, int iLit, Vec_Int_t * vSupp, Vec_Wrd_t * vTemp );
extern void Gia_ObjCollectInternal( Gia_Man_t * p, Gia_Obj_t * pObj );
extern word * Gia_ObjComputeTruthTable( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ObjComputeTruthTableStart( Gia_Man_t * p, int nVarsMax );
extern void Gia_ObjComputeTruthTableStop( Gia_Man_t * p );
extern word * Gia_ObjComputeTruthTableCut( Gia_Man_t * p, Gia_Obj_t * pObj, Vec_Int_t * vLeaves );

extern Gia_Man_t * Gia_ManReduceConst( Gia_Man_t * pAig, int fVerbose );

extern unsigned Gia_ManRandom( int fReset );
extern word Gia_ManRandomW( int fReset );
extern void Gia_ManRandomInfo( Vec_Ptr_t * vInfo, int iInputStart, int iWordStart, int iWordStop );
extern char * Gia_TimeStamp();
extern char * Gia_FileNameGenericAppend( char * pBase, char * pSuffix );
extern Vec_Ptr_t * Gia_GetFakeNames( int nNames, int fCaps );
extern void Gia_ManIncrementTravId( Gia_Man_t * p );
extern void Gia_ManCleanMark01( Gia_Man_t * p );
extern void Gia_ManSetMark0( Gia_Man_t * p );
extern void Gia_ManCleanMark0( Gia_Man_t * p );
extern void Gia_ManCheckMark0( Gia_Man_t * p );
extern void Gia_ManSetMark1( Gia_Man_t * p );
extern void Gia_ManCleanMark1( Gia_Man_t * p );
extern void Gia_ManCheckMark1( Gia_Man_t * p );
extern void Gia_ManCleanValue( Gia_Man_t * p );
extern void Gia_ManCleanLevels( Gia_Man_t * p, int Size );
extern void Gia_ManCleanTruth( Gia_Man_t * p );
extern void Gia_ManFillValue( Gia_Man_t * p );
extern void Gia_ObjSetPhase( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManSetPhase( Gia_Man_t * p );
extern void Gia_ManSetPhasePattern( Gia_Man_t * p, Vec_Int_t * vCiValues );
extern void Gia_ManSetPhase1( Gia_Man_t * p );
extern void Gia_ManCleanPhase( Gia_Man_t * p );
extern int Gia_ManCheckCoPhase( Gia_Man_t * p );
extern int Gia_ManLevelNum( Gia_Man_t * p );
extern int Gia_ManLevelRNum( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManGetCiLevels( Gia_Man_t * p );
extern int Gia_ManSetLevels( Gia_Man_t * p, Vec_Int_t * vCiLevels );
extern Vec_Int_t * Gia_ManReverseLevel( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManRequiredLevel( Gia_Man_t * p );
extern void Gia_ManCreateValueRefs( Gia_Man_t * p );
extern void Gia_ManCreateRefs( Gia_Man_t * p );
extern void Gia_ManCreateLitRefs( Gia_Man_t * p );
extern int * Gia_ManCreateMuxRefs( Gia_Man_t * p );
extern int Gia_ManCrossCut( Gia_Man_t * p, int fReverse );
extern Vec_Int_t * Gia_ManCollectPoIds( Gia_Man_t * p );
extern int Gia_ObjIsMuxType( Gia_Obj_t * pNode );
extern int Gia_ObjRecognizeExor( Gia_Obj_t * pObj, Gia_Obj_t ** ppFan0, Gia_Obj_t ** ppFan1 );
extern Gia_Obj_t * Gia_ObjRecognizeMux( Gia_Obj_t * pNode, Gia_Obj_t ** ppNodeT, Gia_Obj_t ** ppNodeE );
extern int Gia_ObjRecognizeMuxLits( Gia_Man_t * p, Gia_Obj_t * pNode, int * iLitT, int * iLitE );
extern int Gia_NodeMffcSize( Gia_Man_t * p, Gia_Obj_t * pNode );
extern int Gia_NodeMffcSizeMark( Gia_Man_t * p, Gia_Obj_t * pNode );
extern int Gia_NodeMffcSizeSupp( Gia_Man_t * p, Gia_Obj_t * pNode, Vec_Int_t * vSupp );
extern int Gia_NodeMffcMapping( Gia_Man_t * p );
extern int Gia_ManHasDangling( Gia_Man_t * p );
extern int Gia_ManMarkDangling( Gia_Man_t * p );
extern Vec_Int_t * Gia_ManGetDangling( Gia_Man_t * p );
extern void Gia_ObjPrint( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManPrint( Gia_Man_t * p );
extern void Gia_ManPrintCo( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManPrintCone( Gia_Man_t * p, Gia_Obj_t * pObj, int * pLeaves, int nLeaves, Vec_Int_t * vNodes );
extern void Gia_ManPrintConeMulti( Gia_Man_t * p, Vec_Int_t * vObjs, Vec_Int_t * vLeaves, Vec_Int_t * vNodes );
extern void Gia_ManPrintCone2( Gia_Man_t * p, Gia_Obj_t * pObj );
extern void Gia_ManInvertConstraints( Gia_Man_t * pAig );
extern void Gia_ManInvertPos( Gia_Man_t * pAig );
extern int Gia_ManCompare( Gia_Man_t * p1, Gia_Man_t * p2 );
extern void Gia_ManMarkFanoutDrivers( Gia_Man_t * p );
extern void Gia_ManSwapPos( Gia_Man_t * p, int i );
extern Vec_Int_t * Gia_ManSaveValue( Gia_Man_t * p );
extern void Gia_ManLoadValue( Gia_Man_t * p, Vec_Int_t * vValues );
extern Vec_Int_t * Gia_ManFirstFanouts( Gia_Man_t * p );
extern int Gia_ManCheckSuppOverlap( Gia_Man_t * p, int iNode1, int iNode2 );
extern int Gia_ManCountPisWithFanout( Gia_Man_t * p );
extern int Gia_ManCountPosWithNonZeroDrivers( Gia_Man_t * p );
extern void Gia_ManUpdateCopy( Vec_Int_t * vCopy, Gia_Man_t * p );
extern Vec_Int_t * Gia_ManComputeDistance( Gia_Man_t * p, int iObj, Vec_Int_t * vObjs, int fVerbose );


extern Gia_Man_t * Gia_ManTtopt( Gia_Man_t * p, int nIns, int nOuts, int nRounds );
extern Gia_Man_t * Gia_ManTtoptCare( Gia_Man_t * p, int nIns, int nOuts, int nRounds, char * pFileName, int nRarity );


extern Gia_Man_t * Gia_ManTransductionBdd( Gia_Man_t * pGia, int nType, int fMspf, int nRandom, int nSortType, int nPiShuffle, int nParameter, int fLevel, Gia_Man_t * pExdc, int fNewLine, int nVerbose );
extern Gia_Man_t * Gia_ManTransductionTt( Gia_Man_t * pGia, int nType, int fMspf, int nRandom, int nSortType, int nPiShuffle, int nParameter, int fLevel, Gia_Man_t * pExdc, int fNewLine, int nVerbose );


typedef struct Tas_Man_t_ Tas_Man_t;
extern Tas_Man_t * Tas_ManAlloc( Gia_Man_t * pAig, int nBTLimit );
extern void Tas_ManStop( Tas_Man_t * p );
extern Vec_Int_t * Tas_ReadModel( Tas_Man_t * p );
extern void Tas_ManSatPrintStats( Tas_Man_t * p );
extern int Tas_ManSolve( Tas_Man_t * p, Gia_Obj_t * pObj, Gia_Obj_t * pObj2 );
extern int Tas_ManSolveArray( Tas_Man_t * p, Vec_Ptr_t * vObjs );


typedef struct Bnd_Man_t_ Bnd_Man_t;

extern Bnd_Man_t* Bnd_ManStart( Gia_Man_t *pSpec, Gia_Man_t *pImpl, int fVerbose );
extern void Bnd_ManStop();


extern int Bnd_ManGetNInternal();
extern int Bnd_ManGetNExtra();


extern void Bnd_ManMap( int iLit, int id, int spec );
extern void Bnd_ManMerge( int id1, int id2, int phaseDiff );
extern void Bnd_ManFinalizeMappings();
extern void Bnd_ManPrintMappings();
extern Gia_Man_t* Bnd_ManStackGias( Gia_Man_t *pSpec, Gia_Man_t *pImpl );
extern int Bnd_ManCheckCoMerged( Gia_Man_t *p );


extern int Bnd_ManCheckBound( Gia_Man_t *p, int fVerbose );
extern void Bnd_ManFindBound( Gia_Man_t *p, Gia_Man_t *pImpl );
extern Gia_Man_t* Bnd_ManGenSpecOut( Gia_Man_t *p );
extern Gia_Man_t* Bnd_ManGenImplOut( Gia_Man_t *p );
extern Gia_Man_t* Bnd_ManGenPatched( Gia_Man_t *pOut, Gia_Man_t *pSpec, Gia_Man_t *pPatch );
extern Gia_Man_t* Bnd_ManGenPatched1( Gia_Man_t *pOut, Gia_Man_t *pSpec );
extern Gia_Man_t* Bnd_ManGenPatched2( Gia_Man_t *pImpl, Gia_Man_t *pPatch, int fSkiptStrash, int fVerbose );
extern void Bnd_ManSetEqOut( int eq );
extern void Bnd_ManSetEqRes( int eq );
extern void Bnd_ManPrintStats();


extern Gia_Man_t* Bnd_ManCutBoundary( Gia_Man_t *p, Vec_Int_t* vEI, Vec_Int_t* vEO, Vec_Bit_t* vEI_phase, Vec_Bit_t* vEO_phase );


# 36 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/misc/st/st.h" 1
# 20 "/app/abc/src/misc/st/st.h"

# 41 "/app/abc/src/misc/st/st.h"
typedef int (* st__compare_func_type)(const char*, const char*);
typedef int (* st__hash_func_type)(const char*, int);

typedef struct st__table_entry st__table_entry;
struct st__table_entry {
    char *key;
    char *record;
    st__table_entry *next;
};

typedef struct st__table st__table;
struct st__table {
    st__compare_func_type compare;
    st__hash_func_type hash;
    int num_bins;
    int num_entries;
    int max_density;
    int reorder_flag;
    double grow_factor;
    st__table_entry **bins;
};

typedef struct st__generator st__generator;
struct st__generator {
    st__table *table;
    st__table_entry *entry;
    int index;
};




enum st__retval { st__CONTINUE, st__STOP, st__DELETE};

typedef enum st__retval (* st__PFSR)(char *, char *, char *);
typedef int (* st__PFI)();

extern st__table * st__init_table_with_params ( st__compare_func_type compare, st__hash_func_type hash, int size, int density, double grow_factor, int reorder_flag);
extern st__table * st__init_table ( st__compare_func_type, st__hash_func_type);
extern void st__free_table ( st__table *);
extern int st__lookup ( st__table *, const char *, char **);
extern int st__lookup_int ( st__table *, char *, int *);
extern int st__insert ( st__table *, const char *, char *);
extern int st__add_direct ( st__table *, char *, char *);
extern int st__find_or_add ( st__table *, char *, char ***);
extern int st__find ( st__table *, char *, char ***);
extern st__table * st__copy ( st__table *);
extern int st__delete ( st__table *, const char **, char **);
extern int st__delete_int ( st__table *, long *, char **);
extern int st__foreach ( st__table *, st__PFSR, char *);
extern int st__strhash (const char *, int);
extern int st__numhash (const char *, int);
extern int st__ptrhash (const char *, int);
extern int st__numcmp (const char *, const char *);
extern int st__ptrcmp (const char *, const char *);
extern st__generator * st__init_gen ( st__table *);
extern int st__gen ( st__generator *, const char **, char **);
extern int st__gen_int ( st__generator *, const char **, long *);
extern void st__free_gen ( st__generator *);
# 117 "/app/abc/src/misc/st/st.h"

# 37 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/misc/st/stmm.h" 1
# 19 "/app/abc/src/misc/st/stmm.h"

# 39 "/app/abc/src/misc/st/stmm.h"
typedef int (*stmm_compare_func_type)(const char*, const char*);
typedef int (*stmm_hash_func_type)(const char*, int);

typedef struct stmm_table_entry stmm_table_entry;
typedef struct stmm_table stmm_table;
typedef struct stmm_generator stmm_generator;

struct stmm_table_entry
{
    char *key;
    char *record;
    stmm_table_entry *next;
};

struct stmm_table
{
    stmm_compare_func_type compare;
    stmm_hash_func_type hash;
    int num_bins;
    int num_entries;
    int max_density;
    int reorder_flag;
    double grow_factor;
    stmm_table_entry **bins;


    void * pMemMan;
};

struct stmm_generator
{
    stmm_table *table;
    stmm_table_entry *entry;
    int index;
};




enum stmm_retval
{ STMM_CONTINUE, STMM_STOP, STMM_DELETE };

typedef enum stmm_retval (*STMM_PFSR) (char *, char *, char *);

extern stmm_table *stmm_init_table_with_params
(stmm_compare_func_type compare, stmm_hash_func_type hash, int size, int density, double grow_factor, int reorder_flag);
extern stmm_table *stmm_init_table (stmm_compare_func_type, stmm_hash_func_type);
extern void stmm_free_table (stmm_table *);
extern int stmm_lookup (stmm_table *, char *, char **);
extern int stmm_lookup_int (stmm_table *, char *, int *);
extern int stmm_insert (stmm_table *, char *, char *);
extern int stmm_add_direct (stmm_table *, char *, char *);
extern int stmm_find_or_add (stmm_table *, char *, char ***);
extern int stmm_find (stmm_table *, char *, char ***);
extern stmm_table *stmm_copy (stmm_table *);
extern int stmm_delete (stmm_table *, char **, char **);
extern int stmm_delete_int (stmm_table *, long *, char **);
extern int stmm_foreach (stmm_table *, STMM_PFSR, char *);
extern int stmm_strhash (const char *, int);
extern int stmm_numhash (const char *, int);
extern int stmm_ptrhash (const char *, int);
extern int stmm_numcmp (const char *, const char *);
extern int stmm_ptrcmp (const char *, const char *);
extern stmm_generator *stmm_init_gen (stmm_table *);
extern int stmm_gen (stmm_generator *, char **, char **);
extern int stmm_gen_int (stmm_generator *, char **, long *);
extern void stmm_free_gen (stmm_generator *);

extern void stmm_clean (stmm_table *);
# 143 "/app/abc/src/misc/st/stmm.h"

# 38 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/misc/nm/nm.h" 1
# 56 "/app/abc/src/misc/nm/nm.h"







typedef struct Nm_Man_t_ Nm_Man_t;
# 74 "/app/abc/src/misc/nm/nm.h"
extern Nm_Man_t * Nm_ManCreate( int nSize );
extern void Nm_ManFree( Nm_Man_t * p );
extern int Nm_ManNumEntries( Nm_Man_t * p );
extern char * Nm_ManStoreIdName( Nm_Man_t * p, int ObjId, int Type, char * pName, char * pSuffix );
extern void Nm_ManDeleteIdName( Nm_Man_t * p, int ObjId );
extern char * Nm_ManCreateUniqueName( Nm_Man_t * p, int ObjId );
extern char * Nm_ManFindNameById( Nm_Man_t * p, int ObjId );
extern int Nm_ManFindIdByName( Nm_Man_t * p, char * pName, int Type );
extern int Nm_ManFindIdByNameTwoTypes( Nm_Man_t * p, char * pName, int Type1, int Type2 );
extern Vec_Int_t * Nm_ManReturnNameIds( Nm_Man_t * p );




# 39 "/app/abc/src/base/abc/abc.h" 2
# 1 "/app/abc/src/misc/mem/mem.h" 1
# 26 "/app/abc/src/misc/mem/mem.h"







typedef struct Mem_Fixed_t_ Mem_Fixed_t;
typedef struct Mem_Flex_t_ Mem_Flex_t;
typedef struct Mem_Step_t_ Mem_Step_t;







extern Mem_Fixed_t * Mem_FixedStart( int nEntrySize );
extern void Mem_FixedStop( Mem_Fixed_t * p, int fVerbose );
extern char * Mem_FixedEntryFetch( Mem_Fixed_t * p );
extern void Mem_FixedEntryRecycle( Mem_Fixed_t * p, char * pEntry );
extern void Mem_FixedRestart( Mem_Fixed_t * p );
extern int Mem_FixedReadMemUsage( Mem_Fixed_t * p );
extern int Mem_FixedReadMaxEntriesUsed( Mem_Fixed_t * p );

extern Mem_Flex_t * Mem_FlexStart();
extern void Mem_FlexStop( Mem_Flex_t * p, int fVerbose );
extern void Mem_FlexStop2( Mem_Flex_t * p );
extern char * Mem_FlexEntryFetch( Mem_Flex_t * p, int nBytes );
extern void Mem_FlexRestart( Mem_Flex_t * p );
extern int Mem_FlexReadMemUsage( Mem_Flex_t * p );

extern Mem_Step_t * Mem_StepStart( int nSteps );
extern void Mem_StepStop( Mem_Step_t * p, int fVerbose );
extern char * Mem_StepEntryFetch( Mem_Step_t * p, int nBytes );
extern void Mem_StepEntryRecycle( Mem_Step_t * p, char * pEntry, int nBytes );
extern int Mem_StepReadMemUsage( Mem_Step_t * p );




# 40 "/app/abc/src/base/abc/abc.h" 2

# 1 "/app/abc/src/misc/extra/extra.h" 1
# 44 "/app/abc/src/misc/extra/extra.h"
# 1 "/usr/include/assert.h" 1 3 4
# 45 "/app/abc/src/misc/extra/extra.h" 2




# 71 "/app/abc/src/misc/extra/extra.h"
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;







typedef struct Extra_BitMat_t_ Extra_BitMat_t;
extern Extra_BitMat_t * Extra_BitMatrixStart( int nSize );
extern void Extra_BitMatrixClean( Extra_BitMat_t * p );
extern void Extra_BitMatrixStop( Extra_BitMat_t * p );
extern void Extra_BitMatrixPrint( Extra_BitMat_t * p );
extern int Extra_BitMatrixReadSize( Extra_BitMat_t * p );
extern void Extra_BitMatrixInsert1( Extra_BitMat_t * p, int i, int k );
extern int Extra_BitMatrixLookup1( Extra_BitMat_t * p, int i, int k );
extern void Extra_BitMatrixDelete1( Extra_BitMat_t * p, int i, int k );
extern void Extra_BitMatrixInsert2( Extra_BitMat_t * p, int i, int k );
extern int Extra_BitMatrixLookup2( Extra_BitMat_t * p, int i, int k );
extern void Extra_BitMatrixDelete2( Extra_BitMat_t * p, int i, int k );
extern void Extra_BitMatrixOr( Extra_BitMat_t * p, int i, unsigned * pInfo );
extern void Extra_BitMatrixOrTwo( Extra_BitMat_t * p, int i, int j );
extern int Extra_BitMatrixCountOnesUpper( Extra_BitMat_t * p );
extern int Extra_BitMatrixIsDisjoint( Extra_BitMat_t * p1, Extra_BitMat_t * p2 );
extern int Extra_BitMatrixIsClique( Extra_BitMat_t * p );



extern char * Extra_FileGetSimilarName( char * pFileNameWrong, char * pS1, char * pS2, char * pS3, char * pS4, char * pS5 );
extern char * Extra_FileNameExtension( char * FileName );
extern char * Extra_FileNameAppend( char * pBase, char * pSuffix );
extern char * Extra_FileNameGeneric( char * FileName );
extern char * Extra_FileNameGenericAppend( char * pBase, char * pSuffix );
extern void Extra_FileNameCorrectPath( char * FileName );
extern char * Extra_FileNameWithoutPath( char * FileName );
extern char * Extra_FilePathWithoutName( char * FileName );
extern char * Extra_FileInTheSameDir( char * pPathFile, char * pFileName );
extern char * Extra_FileDesignName( char * pFileName );
extern int Extra_FileCheck( char * pFileName );
extern int Extra_FileSize( char * pFileName );
extern char * Extra_FileRead( FILE * pFile );
extern char * Extra_FileRead2( FILE * pFile, FILE * pFile2 );
extern char * Extra_FileReadContents( char * pFileName );
extern char * Extra_FileReadContents2( char * pFileName, char * pFileName2 );
extern int Extra_FileIsType( char * pFileName, char * pS1, char * pS2, char * pS3 );
extern char * Extra_TimeStamp();
extern char * Extra_StringAppend( char * pStrGiven, char * pStrAdd );
extern void Extra_StringClean( char * pStrGiven, char * pCharKeep );
extern unsigned Extra_ReadBinary( char * Buffer );
extern void Extra_PrintBinary( FILE * pFile, unsigned Sign[], int nBits );
extern void Extra_PrintBinary2( FILE * pFile, unsigned Sign[], int nBits );
extern int Extra_ReadHex( unsigned Sign[], char * pString, int nDigits );
extern int Extra_ReadHexadecimal( unsigned Sign[], char * pString, int nVars );
extern void Extra_PrintHexadecimal( FILE * pFile, unsigned Sign[], int nVars );
extern void Extra_PrintHexadecimalString( char * pString, unsigned Sign[], int nVars );
extern void Extra_PrintHex( FILE * pFile, unsigned * pTruth, int nVars );
extern void Extra_PrintHex2( FILE * pFile, unsigned * pTruth, int nVars );
extern void Extra_PrintHexReverse( FILE * pFile, unsigned * pTruth, int nVars );
extern void Extra_PrintSymbols( FILE * pFile, char Char, int nTimes, int fPrintNewLine );



typedef struct Extra_FileReader_t_ Extra_FileReader_t;
extern Extra_FileReader_t * Extra_FileReaderAlloc( char * pFileName,
    char * pCharsComment, char * pCharsStop, char * pCharsClean );
extern void Extra_FileReaderFree( Extra_FileReader_t * p );
extern char * Extra_FileReaderGetFileName( Extra_FileReader_t * p );
extern int Extra_FileReaderGetFileSize( Extra_FileReader_t * p );
extern int Extra_FileReaderGetCurPosition( Extra_FileReader_t * p );
extern void * Extra_FileReaderGetTokens( Extra_FileReader_t * p );
extern int Extra_FileReaderGetLineNumber( Extra_FileReader_t * p, int iToken );



typedef struct Extra_MmFixed_t_ Extra_MmFixed_t;
typedef struct Extra_MmFlex_t_ Extra_MmFlex_t;
typedef struct Extra_MmStep_t_ Extra_MmStep_t;


extern Extra_MmFixed_t * Extra_MmFixedStart( int nEntrySize );
extern void Extra_MmFixedStop( Extra_MmFixed_t * p );
extern char * Extra_MmFixedEntryFetch( Extra_MmFixed_t * p );
extern void Extra_MmFixedEntryRecycle( Extra_MmFixed_t * p, char * pEntry );
extern void Extra_MmFixedRestart( Extra_MmFixed_t * p );
extern int Extra_MmFixedReadMemUsage( Extra_MmFixed_t * p );
extern int Extra_MmFixedReadMaxEntriesUsed( Extra_MmFixed_t * p );

extern Extra_MmFlex_t * Extra_MmFlexStart();
extern void Extra_MmFlexStop( Extra_MmFlex_t * p );
extern void Extra_MmFlexPrint( Extra_MmFlex_t * p );
extern char * Extra_MmFlexEntryFetch( Extra_MmFlex_t * p, int nBytes );
extern int Extra_MmFlexReadMemUsage( Extra_MmFlex_t * p );

extern Extra_MmStep_t * Extra_MmStepStart( int nSteps );
extern void Extra_MmStepStop( Extra_MmStep_t * p );
extern char * Extra_MmStepEntryFetch( Extra_MmStep_t * p, int nBytes );
extern void Extra_MmStepEntryRecycle( Extra_MmStep_t * p, char * pEntry, int nBytes );
extern int Extra_MmStepReadMemUsage( Extra_MmStep_t * p );




extern int Extra_Base2LogDouble( double Num );

extern double Extra_Power2( int Num );
extern int Extra_Power3( int Num );

extern int Extra_NumCombinations( int k, int n );
extern int * Extra_DeriveRadixCode( int Number, int Radix, int nDigits );

extern int Extra_CountOnes( unsigned char * pBytes, int nBytes );

extern int Extra_Factorial( int n );

extern char ** Extra_Permutations( int n );

unsigned Extra_TruthPermute( unsigned Truth, char * pPerms, int nVars, int fReverse );
unsigned Extra_TruthPolarize( unsigned uTruth, int Polarity, int nVars );

extern unsigned Extra_TruthCanonN( unsigned uTruth, int nVars );
extern unsigned Extra_TruthCanonNN( unsigned uTruth, int nVars );
extern unsigned Extra_TruthCanonP( unsigned uTruth, int nVars );
extern unsigned Extra_TruthCanonNP( unsigned uTruth, int nVars );
extern unsigned Extra_TruthCanonNPN( unsigned uTruth, int nVars );

extern void Extra_Truth4VarNPN( unsigned short ** puCanons, char ** puPhases, char ** puPerms, unsigned char ** puMap );
extern void Extra_Truth4VarN( unsigned short ** puCanons, char *** puPhases, char ** ppCounters, int nPhasesMax );

extern unsigned short Extra_TruthPerm4One( unsigned uTruth, int Phase );
extern unsigned Extra_TruthPerm5One( unsigned uTruth, int Phase );
extern void Extra_TruthPerm6One( unsigned * uTruth, int Phase, unsigned * uTruthRes );
extern void Extra_TruthExpand( int nVars, int nWords, unsigned * puTruth, unsigned uPhase, unsigned * puTruthR );

extern void ** Extra_ArrayAlloc( int nCols, int nRows, int Size );
extern unsigned short ** Extra_TruthPerm43();
extern unsigned ** Extra_TruthPerm53();
extern unsigned ** Extra_TruthPerm54();

extern void Extra_BubbleSort( int Order[], int Costs[], int nSize, int fIncreasing );

extern int * Extra_GreyCodeSchedule( int n );
extern int * Extra_PermSchedule( int n );
extern word Extra_Truth6MinimumExact( word t, int * pComp, int * pPerm );
extern word Extra_Truth6MinimumHeuristic( word t );




extern int Extra_TruthCanonFastN( int nVarsMax, int nVarsReal, unsigned * pt, unsigned ** pptRes, char ** ppfRes );



typedef struct Sdm_Man_t_ Sdm_Man_t;
extern int Sdm_ManCanRead();
extern Sdm_Man_t * Sdm_ManRead();
extern void Sdm_ManQuit();
extern int Sdm_ManComputeFunc( Sdm_Man_t * p, int iDsdLit0, int iDsdLit1, int * pCut, int uMask, int fXor );
extern void Sdm_ManPrintDsdStats( Sdm_Man_t * p, int fVerbose );
extern int Sdm_ManReadDsdVarNum( Sdm_Man_t * p, int iDsd );
extern int Sdm_ManReadDsdAndNum( Sdm_Man_t * p, int iDsd );
extern int Sdm_ManReadDsdClauseNum( Sdm_Man_t * p, int iDsd );
extern word Sdm_ManReadDsdTruth( Sdm_Man_t * p, int iDsd );
extern char * Sdm_ManReadDsdStr( Sdm_Man_t * p, int iDsd );
extern void Sdm_ManReadCnfCosts( Sdm_Man_t * p, int * pCosts, int nCosts );



typedef struct ProgressBarStruct ProgressBar;

extern ProgressBar * Extra_ProgressBarStart( FILE * pFile, int nItemsTotal );
extern void Extra_ProgressBarStop( ProgressBar * p );
extern void Extra_ProgressBarUpdate_int( ProgressBar * p, int nItemsCur, char * pString );

static inline void Extra_ProgressBarUpdate( ProgressBar * p, int nItemsCur, char * pString )
{ if ( p && nItemsCur < *((int*)p) ) return; Extra_ProgressBarUpdate_int(p, nItemsCur, pString); }



static inline int Extra_BitWordNum( int nBits ) { return nBits/(8*sizeof(unsigned)) + ((nBits%(8*sizeof(unsigned))) > 0); }
static inline int Extra_TruthWordNum( int nVars ) { return nVars <= 5 ? 1 : (1 << (nVars - 5)); }

static inline void Extra_TruthSetBit( unsigned * p, int Bit ) { p[Bit>>5] |= (unsigned)(1<<(Bit & 31)); }
static inline void Extra_TruthXorBit( unsigned * p, int Bit ) { p[Bit>>5] ^= (unsigned)(1<<(Bit & 31)); }
static inline int Extra_TruthHasBit( unsigned * p, int Bit ) { return (p[Bit>>5] & (unsigned)(1<<(Bit & 31))) > 0; }

static inline int Extra_WordCountOnes( unsigned uWord )
{
    uWord = (uWord & 0x55555555) + ((uWord>>1) & 0x55555555);
    uWord = (uWord & 0x33333333) + ((uWord>>2) & 0x33333333);
    uWord = (uWord & 0x0F0F0F0F) + ((uWord>>4) & 0x0F0F0F0F);
    uWord = (uWord & 0x00FF00FF) + ((uWord>>8) & 0x00FF00FF);
    return (uWord & 0x0000FFFF) + (uWord>>16);
}
static inline int Extra_TruthCountOnes( unsigned * pIn, int nVars )
{
    int w, Counter = 0;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        Counter += Extra_WordCountOnes(pIn[w]);
    return Counter;
}
static inline int Extra_TruthIsEqual( unsigned * pIn0, unsigned * pIn1, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn0[w] != pIn1[w] )
            return 0;
    return 1;
}
static inline int Extra_TruthIsConst0( unsigned * pIn, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn[w] )
            return 0;
    return 1;
}
static inline int Extra_TruthIsConst1( unsigned * pIn, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn[w] != ~(unsigned)0 )
            return 0;
    return 1;
}
static inline int Extra_TruthIsImply( unsigned * pIn1, unsigned * pIn2, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        if ( pIn1[w] & ~pIn2[w] )
            return 0;
    return 1;
}
static inline void Extra_TruthCopy( unsigned * pOut, unsigned * pIn, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = pIn[w];
}
static inline void Extra_TruthClear( unsigned * pOut, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = 0;
}
static inline void Extra_TruthFill( unsigned * pOut, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = ~(unsigned)0;
}
static inline void Extra_TruthNot( unsigned * pOut, unsigned * pIn, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = ~pIn[w];
}
static inline void Extra_TruthAnd( unsigned * pOut, unsigned * pIn0, unsigned * pIn1, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = pIn0[w] & pIn1[w];
}
static inline void Extra_TruthOr( unsigned * pOut, unsigned * pIn0, unsigned * pIn1, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = pIn0[w] | pIn1[w];
}
static inline void Extra_TruthSharp( unsigned * pOut, unsigned * pIn0, unsigned * pIn1, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = pIn0[w] & ~pIn1[w];
}
static inline void Extra_TruthNand( unsigned * pOut, unsigned * pIn0, unsigned * pIn1, int nVars )
{
    int w;
    for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
        pOut[w] = ~(pIn0[w] & pIn1[w]);
}
static inline void Extra_TruthAndPhase( unsigned * pOut, unsigned * pIn0, unsigned * pIn1, int nVars, int fCompl0, int fCompl1 )
{
    int w;
    if ( fCompl0 && fCompl1 )
    {
        for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
            pOut[w] = ~(pIn0[w] | pIn1[w]);
    }
    else if ( fCompl0 && !fCompl1 )
    {
        for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
            pOut[w] = ~pIn0[w] & pIn1[w];
    }
    else if ( !fCompl0 && fCompl1 )
    {
        for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
            pOut[w] = pIn0[w] & ~pIn1[w];
    }
    else
    {
        for ( w = Extra_TruthWordNum(nVars)-1; w >= 0; w-- )
            pOut[w] = pIn0[w] & pIn1[w];
    }
}

extern unsigned ** Extra_TruthElementary( int nVars );
extern void Extra_TruthSwapAdjacentVars( unsigned * pOut, unsigned * pIn, int nVars, int Start );
extern void Extra_TruthStretch( unsigned * pOut, unsigned * pIn, int nVars, int nVarsAll, unsigned Phase );
extern void Extra_TruthShrink( unsigned * pOut, unsigned * pIn, int nVars, int nVarsAll, unsigned Phase );
extern int Extra_TruthVarInSupport( unsigned * pTruth, int nVars, int iVar );
extern int Extra_TruthSupportSize( unsigned * pTruth, int nVars );
extern int Extra_TruthSupport( unsigned * pTruth, int nVars );
extern void Extra_TruthCofactor0( unsigned * pTruth, int nVars, int iVar );
extern void Extra_TruthCofactor1( unsigned * pTruth, int nVars, int iVar );
extern void Extra_TruthExist( unsigned * pTruth, int nVars, int iVar );
extern void Extra_TruthForall( unsigned * pTruth, int nVars, int iVar );
extern void Extra_TruthMux( unsigned * pOut, unsigned * pCof0, unsigned * pCof1, int nVars, int iVar );
extern void Extra_TruthChangePhase( unsigned * pTruth, int nVars, int iVar );
extern int Extra_TruthMinCofSuppOverlap( unsigned * pTruth, int nVars, int * pVarMin );
extern void Extra_TruthCountOnesInCofs( unsigned * pTruth, int nVars, short * pStore );
extern unsigned Extra_TruthHash( unsigned * pIn, int nWords );
extern unsigned Extra_TruthSemiCanonicize( unsigned * pInOut, unsigned * pAux, int nVars, char * pCanonPerm, short * pStore );



extern abctime Extra_CpuTime();
extern double Extra_CpuTimeDouble();
extern int Extra_GetSoftDataLimit();
extern void Extra_UtilGetoptReset();
extern int Extra_UtilGetopt( int argc, char *argv[], const char *optstring );
extern char * Extra_UtilPrintTime( long t );
extern char * Extra_UtilStrsav( const char *s );
extern char * Extra_UtilTildeExpand( char *fname );
extern char * Extra_UtilFileSearch( char *file, char *path, char *mode );
extern void (*Extra_UtilMMoutOfMemory)( long size );

extern const char * globalUtilOptarg;
extern int globalUtilOptind;






# 42 "/app/abc/src/base/abc/abc.h" 2








typedef enum
{
    ABC_NTK_NONE = 0,
    ABC_NTK_NETLIST,
    ABC_NTK_LOGIC,
    ABC_NTK_STRASH,
    ABC_NTK_OTHER
} Abc_NtkType_t;


typedef enum
{
    ABC_FUNC_NONE = 0,
    ABC_FUNC_SOP,
    ABC_FUNC_BDD,
    ABC_FUNC_AIG,
    ABC_FUNC_MAP,
    ABC_FUNC_BLIFMV,
    ABC_FUNC_BLACKBOX,
    ABC_FUNC_OTHER
} Abc_NtkFunc_t;
# 84 "/app/abc/src/base/abc/abc.h"
typedef enum
{
    ABC_OBJ_NONE = 0,
    ABC_OBJ_CONST1,
    ABC_OBJ_PI,
    ABC_OBJ_PO,
    ABC_OBJ_BI,
    ABC_OBJ_BO,
    ABC_OBJ_NET,
    ABC_OBJ_NODE,
    ABC_OBJ_LATCH,
    ABC_OBJ_WHITEBOX,
    ABC_OBJ_BLACKBOX,
    ABC_OBJ_NUMBER
} Abc_ObjType_t;


typedef enum
{
    ABC_INIT_NONE = 0,
    ABC_INIT_ZERO,
    ABC_INIT_ONE,
    ABC_INIT_DC,
    ABC_INIT_OTHER
} Abc_InitType_t;





typedef struct Abc_Des_t_ Abc_Des_t;
typedef struct Abc_Ntk_t_ Abc_Ntk_t;
typedef struct Abc_Obj_t_ Abc_Obj_t;
typedef struct Abc_Aig_t_ Abc_Aig_t;
typedef struct Abc_ManTime_t_ Abc_ManTime_t;
typedef struct Abc_ManCut_t_ Abc_ManCut_t;
typedef struct Abc_Time_t_ Abc_Time_t;

struct Abc_Time_t_
{
    float Rise;
    float Fall;
};

struct Abc_Obj_t_
{
    Abc_Ntk_t *pNtk;
    Abc_Obj_t *pNext;
    int Id;
    unsigned Type : 4;
    unsigned fMarkA : 1;
    unsigned fMarkB : 1;
    unsigned fMarkC : 1;
    unsigned fPhase : 1;
    unsigned fExor : 1;
    unsigned fPersist : 1;
    unsigned fCompl0 : 1;
    unsigned fCompl1 : 1;
    unsigned Level : 20;
    Vec_Int_t vFanins;
    Vec_Int_t vFanouts;
    union
    {
        void *pData;
        int iData;
    };
    union
    {
        void *pTemp;
        Abc_Obj_t *pCopy;
        int iTemp;
        float dTemp;
    };
};

struct Abc_Ntk_t_
{

    Abc_NtkType_t ntkType;
    Abc_NtkFunc_t ntkFunc;
    char *pName;
    char *pSpec;
    Nm_Man_t *pManName;

    Vec_Ptr_t *vObjs;
    Vec_Ptr_t *vPis;
    Vec_Ptr_t *vPos;
    Vec_Ptr_t *vCis;
    Vec_Ptr_t *vCos;
    Vec_Ptr_t *vPios;
    Vec_Ptr_t *vBoxes;
    Vec_Ptr_t *vLtlProperties;

    int nObjCounts[ABC_OBJ_NUMBER];
    int nObjs;
    int nConstrs;
    int nBarBufs;
    int nBarBufs2;

    Abc_Ntk_t *pNetBackup;
    int iStep;

    Abc_Des_t *pDesign;
    Abc_Ntk_t *pAltView;
    int fHieVisited;
    int fHiePath;
    int Id;
    double dTemp;

    int nTravIds;
    Vec_Int_t vTravIds;
    Mem_Fixed_t *pMmObj;
    Mem_Step_t *pMmStep;
    void *pManFunc;
    Abc_ManTime_t *pManTime;
    void *pManCut;
    float AndGateDelay;
    int LevelMax;
    Vec_Int_t *vLevelsR;
    Vec_Ptr_t *vSupps;
    int *pModel;
    Abc_Cex_t *pSeqModel;
    Vec_Ptr_t *vSeqModelVec;
    Abc_Ntk_t *pExdc;
    void *pExcare;
    void *pData;
    Abc_Ntk_t *pCopy;
    void *pBSMan;
    void *pSCLib;
    Vec_Int_t *vGates;
    Vec_Int_t *vPhases;
    char *pWLoadUsed;
    float *pLutTimes;
    Vec_Ptr_t *vOnehots;
    Vec_Int_t *vObjPerm;
    Vec_Int_t *vTopo;
    Vec_Ptr_t *vAttrs;
    Vec_Int_t *vNameIds;
    Vec_Int_t *vFins;
    Vec_Int_t *vOrigNodeIds;
};

struct Abc_Des_t_
{
    char *pName;
    void *pManFunc;
    Vec_Ptr_t *vTops;
    Vec_Ptr_t *vModules;
    st__table *tModules;
    Abc_Des_t *pLibrary;
    void *pGenlib;
};






static inline unsigned Abc_InfoRandomWord() { return ((((unsigned)rand()) << 24) ^ (((unsigned)rand()) << 12) ^ ((unsigned)rand())); }
static inline void Abc_InfoRandom(unsigned *p, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] = Abc_InfoRandomWord();
}
static inline void Abc_InfoClear(unsigned *p, int nWords) { memset(p, 0, sizeof(unsigned) * nWords); }
static inline void Abc_InfoFill(unsigned *p, int nWords) { memset(p, 0xff, sizeof(unsigned) * nWords); }
static inline void Abc_InfoNot(unsigned *p, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] = ~p[i];
}
static inline int Abc_InfoIsZero(unsigned *p, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        if (p[i])
            return 0;
    return 1;
}
static inline int Abc_InfoIsOne(unsigned *p, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        if (~p[i])
            return 0;
    return 1;
}
static inline void Abc_InfoCopy(unsigned *p, unsigned *q, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] = q[i];
}
static inline void Abc_InfoAnd(unsigned *p, unsigned *q, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] &= q[i];
}
static inline void Abc_InfoOr(unsigned *p, unsigned *q, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] |= q[i];
}
static inline void Abc_InfoXor(unsigned *p, unsigned *q, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        p[i] ^= q[i];
}
static inline int Abc_InfoIsOrOne(unsigned *p, unsigned *q, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        if (~(p[i] | q[i]))
            return 0;
    return 1;
}
static inline int Abc_InfoIsOrOne3(unsigned *p, unsigned *q, unsigned *r, int nWords)
{
    int i;
    for (i = nWords - 1; i >= 0; i--)
        if (~(p[i] | q[i] | r[i]))
            return 0;
    return 1;
}


static inline int Abc_NtkIsNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsLogic(Abc_Ntk_t *pNtk) { return pNtk->ntkType == ABC_NTK_LOGIC; }
static inline int Abc_NtkIsStrash(Abc_Ntk_t *pNtk) { return pNtk->ntkType == ABC_NTK_STRASH; }

static inline int Abc_NtkHasSop(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_SOP; }
static inline int Abc_NtkHasBdd(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BDD; }
static inline int Abc_NtkHasAig(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_AIG; }
static inline int Abc_NtkHasMapping(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_MAP; }
static inline int Abc_NtkHasBlifMv(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BLIFMV; }
static inline int Abc_NtkHasBlackbox(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BLACKBOX; }

static inline int Abc_NtkIsSopNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_SOP && pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsBddNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BDD && pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsAigNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_AIG && pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsMappedNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_MAP && pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsBlifMvNetlist(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BLIFMV && pNtk->ntkType == ABC_NTK_NETLIST; }
static inline int Abc_NtkIsSopLogic(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_SOP && pNtk->ntkType == ABC_NTK_LOGIC; }
static inline int Abc_NtkIsBddLogic(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_BDD && pNtk->ntkType == ABC_NTK_LOGIC; }
static inline int Abc_NtkIsAigLogic(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_AIG && pNtk->ntkType == ABC_NTK_LOGIC; }
static inline int Abc_NtkIsMappedLogic(Abc_Ntk_t *pNtk) { return pNtk->ntkFunc == ABC_FUNC_MAP && pNtk->ntkType == ABC_NTK_LOGIC; }


static inline char *Abc_NtkName(Abc_Ntk_t *pNtk) { return pNtk->pName; }
static inline char *Abc_NtkSpec(Abc_Ntk_t *pNtk) { return pNtk->pSpec; }
static inline Abc_Ntk_t *Abc_NtkExdc(Abc_Ntk_t *pNtk) { return pNtk->pExdc; }
static inline Abc_Ntk_t *Abc_NtkBackup(Abc_Ntk_t *pNtk) { return pNtk->pNetBackup; }
static inline int Abc_NtkStep(Abc_Ntk_t *pNtk) { return pNtk->iStep; }


static inline void Abc_NtkSetName(Abc_Ntk_t *pNtk, char *pName) { pNtk->pName = pName; }
static inline void Abc_NtkSetSpec(Abc_Ntk_t *pNtk, char *pName) { pNtk->pSpec = pName; }
static inline void Abc_NtkSetBackup(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNetBackup) { pNtk->pNetBackup = pNetBackup; }
static inline void Abc_NtkSetStep(Abc_Ntk_t *pNtk, int iStep) { pNtk->iStep = iStep; }


static inline int Abc_NtkObjNum(Abc_Ntk_t *pNtk) { return pNtk->nObjs; }
static inline int Abc_NtkObjNumMax(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vObjs); }
static inline int Abc_NtkPiNum(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vPis); }
static inline int Abc_NtkPoNum(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vPos); }
static inline int Abc_NtkCiNum(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vCis); }
static inline int Abc_NtkCoNum(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vCos); }
static inline int Abc_NtkBoxNum(Abc_Ntk_t *pNtk) { return Vec_PtrSize(pNtk->vBoxes); }
static inline int Abc_NtkBiNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_BI]; }
static inline int Abc_NtkBoNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_BO]; }
static inline int Abc_NtkNetNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_NET]; }
static inline int Abc_NtkNodeNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_NODE]; }
static inline int Abc_NtkLatchNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_LATCH]; }
static inline int Abc_NtkWhiteboxNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_WHITEBOX]; }
static inline int Abc_NtkBlackboxNum(Abc_Ntk_t *pNtk) { return pNtk->nObjCounts[ABC_OBJ_BLACKBOX]; }
static inline int Abc_NtkIsComb(Abc_Ntk_t *pNtk) { return Abc_NtkLatchNum(pNtk) == 0; }
static inline int Abc_NtkHasOnlyLatchBoxes(Abc_Ntk_t *pNtk) { return Abc_NtkLatchNum(pNtk) == Abc_NtkBoxNum(pNtk); }
static inline int Abc_NtkConstrNum(Abc_Ntk_t *pNtk) { return pNtk->nConstrs; }


extern Abc_Obj_t *Abc_NtkCreateObj(Abc_Ntk_t *pNtk, Abc_ObjType_t Type);
static inline Abc_Obj_t *Abc_NtkCreatePi(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_PI); }
static inline Abc_Obj_t *Abc_NtkCreatePo(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_PO); }
static inline Abc_Obj_t *Abc_NtkCreateBi(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_BI); }
static inline Abc_Obj_t *Abc_NtkCreateBo(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_BO); }
static inline Abc_Obj_t *Abc_NtkCreateNet(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_NET); }
static inline Abc_Obj_t *Abc_NtkCreateNode(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_NODE); }
static inline Abc_Obj_t *Abc_NtkCreateLatch(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_LATCH); }
static inline Abc_Obj_t *Abc_NtkCreateWhitebox(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_WHITEBOX); }
static inline Abc_Obj_t *Abc_NtkCreateBlackbox(Abc_Ntk_t *pNtk) { return Abc_NtkCreateObj(pNtk, ABC_OBJ_BLACKBOX); }


static inline Abc_Obj_t *Abc_NtkObj(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vObjs, i); }
static inline Abc_Obj_t *Abc_NtkPi(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vPis, i); }
static inline Abc_Obj_t *Abc_NtkPo(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vPos, i); }
static inline Abc_Obj_t *Abc_NtkCi(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vCis, i); }
static inline Abc_Obj_t *Abc_NtkCo(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vCos, i); }
static inline Abc_Obj_t *Abc_NtkBox(Abc_Ntk_t *pNtk, int i) { return (Abc_Obj_t *)Vec_PtrEntry(pNtk->vBoxes, i); }


static inline int Abc_ObjIsComplement(Abc_Obj_t *p) { return (int)((ABC_PTRUINT_T)p & (ABC_PTRUINT_T)01); }
static inline Abc_Obj_t *Abc_ObjRegular(Abc_Obj_t *p) { return (Abc_Obj_t *)((ABC_PTRUINT_T)p & ~(ABC_PTRUINT_T)01); }
static inline Abc_Obj_t *Abc_ObjNot(Abc_Obj_t *p) { return (Abc_Obj_t *)((ABC_PTRUINT_T)p ^ (ABC_PTRUINT_T)01); }
static inline Abc_Obj_t *Abc_ObjNotCond(Abc_Obj_t *p, int c) { return (Abc_Obj_t *)((ABC_PTRUINT_T)p ^ (ABC_PTRUINT_T)(c != 0)); }


static inline unsigned Abc_ObjType(Abc_Obj_t *pObj) { return pObj->Type; }
static inline unsigned Abc_ObjId(Abc_Obj_t *pObj) { return pObj->Id; }
static inline int Abc_ObjLevel(Abc_Obj_t *pObj) { return pObj->Level; }
static inline Vec_Int_t *Abc_ObjFaninVec(Abc_Obj_t *pObj) { return &pObj->vFanins; }
static inline Vec_Int_t *Abc_ObjFanoutVec(Abc_Obj_t *pObj) { return &pObj->vFanouts; }
static inline Abc_Obj_t *Abc_ObjCopy(Abc_Obj_t *pObj) { return pObj->pCopy; }
static inline Abc_Ntk_t *Abc_ObjNtk(Abc_Obj_t *pObj) { return pObj->pNtk; }
static inline Abc_Ntk_t *Abc_ObjModel(Abc_Obj_t *pObj)
{
    
# 404 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 404 "/app/abc/src/base/abc/abc.h"
   pObj->Type == ABC_OBJ_WHITEBOX
# 404 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 404 "/app/abc/src/base/abc/abc.h"
   pObj->Type == ABC_OBJ_WHITEBOX
# 404 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 404 "/app/abc/src/base/abc/abc.h"
   "pObj->Type == ABC_OBJ_WHITEBOX"
# 404 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 404, __extension__ __PRETTY_FUNCTION__); }))
# 404 "/app/abc/src/base/abc/abc.h"
                                         ;
    return (Abc_Ntk_t *)pObj->pData;
}
static inline void *Abc_ObjData(Abc_Obj_t *pObj) { return pObj->pData; }
static inline Abc_Obj_t *Abc_ObjEquiv(Abc_Obj_t *pObj) { return (Abc_Obj_t *)pObj->pData; }
static inline Abc_Obj_t *Abc_ObjCopyCond(Abc_Obj_t *pObj) { return Abc_ObjRegular(pObj)->pCopy ? Abc_ObjNotCond(Abc_ObjRegular(pObj)->pCopy, Abc_ObjIsComplement(pObj)) : 
# 409 "/app/abc/src/base/abc/abc.h" 3 4
                                                                                                                                                                         ((void *)0)
# 409 "/app/abc/src/base/abc/abc.h"
                                                                                                                                                                             ; }


static inline void Abc_ObjSetLevel(Abc_Obj_t *pObj, int Level) { pObj->Level = Level; }
static inline void Abc_ObjSetCopy(Abc_Obj_t *pObj, Abc_Obj_t *pCopy) { pObj->pCopy = pCopy; }
static inline void Abc_ObjSetData(Abc_Obj_t *pObj, void *pData) { pObj->pData = pData; }


static inline int Abc_ObjIsNone(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_NONE; }
static inline int Abc_ObjIsPi(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_PI; }
static inline int Abc_ObjIsPo(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_PO; }
static inline int Abc_ObjIsBi(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_BI; }
static inline int Abc_ObjIsBo(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_BO; }
static inline int Abc_ObjIsCi(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_PI || pObj->Type == ABC_OBJ_BO; }
static inline int Abc_ObjIsCo(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_PO || pObj->Type == ABC_OBJ_BI; }
static inline int Abc_ObjIsTerm(Abc_Obj_t *pObj) { return Abc_ObjIsCi(pObj) || Abc_ObjIsCo(pObj); }
static inline int Abc_ObjIsNet(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_NET; }
static inline int Abc_ObjIsNode(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_NODE; }
static inline int Abc_ObjIsLatch(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_LATCH; }
static inline int Abc_ObjIsBox(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_LATCH || pObj->Type == ABC_OBJ_WHITEBOX || pObj->Type == ABC_OBJ_BLACKBOX; }
static inline int Abc_ObjIsWhitebox(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_WHITEBOX; }
static inline int Abc_ObjIsBlackbox(Abc_Obj_t *pObj) { return pObj->Type == ABC_OBJ_BLACKBOX; }
static inline int Abc_ObjIsBarBuf(Abc_Obj_t *pObj) { return Abc_NtkHasMapping(pObj->pNtk) && Abc_ObjIsNode(pObj) && Vec_IntSize(&pObj->vFanins) == 1 && pObj->pData == 
# 431 "/app/abc/src/base/abc/abc.h" 3 4
                                                                                                                                                                      ((void *)0)
# 431 "/app/abc/src/base/abc/abc.h"
                                                                                                                                                                          ; }
static inline void Abc_ObjBlackboxToWhitebox(Abc_Obj_t *pObj)
{
    
# 434 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 434 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsBlackbox(pObj)
# 434 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 434 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsBlackbox(pObj)
# 434 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 434 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsBlackbox(pObj)"
# 434 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 434, __extension__ __PRETTY_FUNCTION__); }))
# 434 "/app/abc/src/base/abc/abc.h"
                                  ;
    pObj->Type = ABC_OBJ_WHITEBOX;
    pObj->pNtk->nObjCounts[ABC_OBJ_BLACKBOX]--;
    pObj->pNtk->nObjCounts[ABC_OBJ_WHITEBOX]++;
}


static inline int Abc_ObjFaninNum(Abc_Obj_t *pObj) { return pObj->vFanins.nSize; }
static inline int Abc_ObjFanoutNum(Abc_Obj_t *pObj) { return pObj->vFanouts.nSize; }
static inline int Abc_ObjFaninId(Abc_Obj_t *pObj, int i) { return pObj->vFanins.pArray[i]; }
static inline int Abc_ObjFaninId0(Abc_Obj_t *pObj) { return pObj->vFanins.pArray[0]; }
static inline int Abc_ObjFaninId1(Abc_Obj_t *pObj) { return pObj->vFanins.pArray[1]; }
static inline int Abc_ObjFanoutEdgeNum(Abc_Obj_t *pObj, Abc_Obj_t *pFanout)
{
    
# 448 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 448 "/app/abc/src/base/abc/abc.h"
   Abc_NtkHasAig(pObj->pNtk)
# 448 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 448 "/app/abc/src/base/abc/abc.h"
   Abc_NtkHasAig(pObj->pNtk)
# 448 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 448 "/app/abc/src/base/abc/abc.h"
   "Abc_NtkHasAig(pObj->pNtk)"
# 448 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 448, __extension__ __PRETTY_FUNCTION__); }))
# 448 "/app/abc/src/base/abc/abc.h"
                                    ;
    if (Abc_ObjFaninId0(pFanout) == pObj->Id)
        return 0;
    if (Abc_ObjFaninId1(pFanout) == pObj->Id)
        return 1;
    
# 453 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 453 "/app/abc/src/base/abc/abc.h"
   0
# 453 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 453 "/app/abc/src/base/abc/abc.h"
   0
# 453 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 453 "/app/abc/src/base/abc/abc.h"
   "0"
# 453 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 453, __extension__ __PRETTY_FUNCTION__); }))
# 453 "/app/abc/src/base/abc/abc.h"
            ;
    return -1;
}
static inline Abc_Obj_t *Abc_ObjFanout(Abc_Obj_t *pObj, int i) { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[pObj->vFanouts.pArray[i]]; }
static inline Abc_Obj_t *Abc_ObjFanout0(Abc_Obj_t *pObj) { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[pObj->vFanouts.pArray[0]]; }
static inline Abc_Obj_t *Abc_ObjFanin(Abc_Obj_t *pObj, int i) { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[pObj->vFanins.pArray[i]]; }
static inline Abc_Obj_t *Abc_ObjFanin0(Abc_Obj_t *pObj) { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[pObj->vFanins.pArray[0]]; }
static inline Abc_Obj_t *Abc_ObjFanin1(Abc_Obj_t *pObj) { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[pObj->vFanins.pArray[1]]; }
static inline Abc_Obj_t *Abc_ObjFanin0Ntk(Abc_Obj_t *pObj) { return (Abc_NtkIsNetlist(pObj->pNtk) ? Abc_ObjFanin0(pObj) : pObj); }
static inline Abc_Obj_t *Abc_ObjFanout0Ntk(Abc_Obj_t *pObj) { return (Abc_NtkIsNetlist(pObj->pNtk) ? Abc_ObjFanout0(pObj) : pObj); }
static inline int Abc_ObjFaninC0(Abc_Obj_t *pObj) { return pObj->fCompl0; }
static inline int Abc_ObjFaninC1(Abc_Obj_t *pObj) { return pObj->fCompl1; }
static inline int Abc_ObjFaninC(Abc_Obj_t *pObj, int i)
{
    
# 467 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 467 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 467 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 467 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 467 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 467 "/app/abc/src/base/abc/abc.h"
   "i >= 0 && i < 2"
# 467 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 467, __extension__ __PRETTY_FUNCTION__); }))
# 467 "/app/abc/src/base/abc/abc.h"
                          ;
    return i ? pObj->fCompl1 : pObj->fCompl0;
}
static inline void Abc_ObjSetFaninC(Abc_Obj_t *pObj, int i)
{
    
# 472 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 472 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 472 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 472 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 472 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 472 "/app/abc/src/base/abc/abc.h"
   "i >= 0 && i < 2"
# 472 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 472, __extension__ __PRETTY_FUNCTION__); }))
# 472 "/app/abc/src/base/abc/abc.h"
                          ;
    if (i)
        pObj->fCompl1 = 1;
    else
        pObj->fCompl0 = 1;
}
static inline void Abc_ObjXorFaninC(Abc_Obj_t *pObj, int i)
{
    
# 480 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 480 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 480 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 480 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < 2
# 480 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 480 "/app/abc/src/base/abc/abc.h"
   "i >= 0 && i < 2"
# 480 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 480, __extension__ __PRETTY_FUNCTION__); }))
# 480 "/app/abc/src/base/abc/abc.h"
                          ;
    if (i)
        pObj->fCompl1 ^= 1;
    else
        pObj->fCompl0 ^= 1;
}
static inline Abc_Obj_t *Abc_ObjChild(Abc_Obj_t *pObj, int i) { return Abc_ObjNotCond(Abc_ObjFanin(pObj, i), Abc_ObjFaninC(pObj, i)); }
static inline Abc_Obj_t *Abc_ObjChild0(Abc_Obj_t *pObj) { return Abc_ObjNotCond(Abc_ObjFanin0(pObj), Abc_ObjFaninC0(pObj)); }
static inline Abc_Obj_t *Abc_ObjChild1(Abc_Obj_t *pObj) { return Abc_ObjNotCond(Abc_ObjFanin1(pObj), Abc_ObjFaninC1(pObj)); }
static inline Abc_Obj_t *Abc_ObjChildCopy(Abc_Obj_t *pObj, int i) { return Abc_ObjNotCond(Abc_ObjFanin(pObj, i)->pCopy, Abc_ObjFaninC(pObj, i)); }
static inline Abc_Obj_t *Abc_ObjChild0Copy(Abc_Obj_t *pObj) { return Abc_ObjNotCond(Abc_ObjFanin0(pObj)->pCopy, Abc_ObjFaninC0(pObj)); }
static inline Abc_Obj_t *Abc_ObjChild1Copy(Abc_Obj_t *pObj) { return Abc_ObjNotCond(Abc_ObjFanin1(pObj)->pCopy, Abc_ObjFaninC1(pObj)); }
static inline Abc_Obj_t *Abc_ObjChild0Data(Abc_Obj_t *pObj) { return Abc_ObjNotCond((Abc_Obj_t *)Abc_ObjFanin0(pObj)->pData, Abc_ObjFaninC0(pObj)); }
static inline Abc_Obj_t *Abc_ObjChild1Data(Abc_Obj_t *pObj) { return Abc_ObjNotCond((Abc_Obj_t *)Abc_ObjFanin1(pObj)->pData, Abc_ObjFaninC1(pObj)); }
static inline Abc_Obj_t *Abc_ObjFromLit(Abc_Ntk_t *p, int iLit) { return Abc_ObjNotCond(Abc_NtkObj(p, Abc_Lit2Var(iLit)), Abc_LitIsCompl(iLit)); }
static inline int Abc_ObjToLit(Abc_Obj_t *p) { return Abc_Var2Lit(Abc_ObjId(Abc_ObjRegular(p)), Abc_ObjIsComplement(p)); }
static inline int Abc_ObjFaninPhase(Abc_Obj_t *p, int i)
{
    
# 498 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 498 "/app/abc/src/base/abc/abc.h"
   p->pNtk->vPhases
# 498 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 498 "/app/abc/src/base/abc/abc.h"
   p->pNtk->vPhases
# 498 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 498 "/app/abc/src/base/abc/abc.h"
   "p->pNtk->vPhases"
# 498 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 498, __extension__ __PRETTY_FUNCTION__); }))
# 498 "/app/abc/src/base/abc/abc.h"
                           ;
    
# 499 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 499 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < Abc_ObjFaninNum(p)
# 499 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 499 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < Abc_ObjFaninNum(p)
# 499 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 499 "/app/abc/src/base/abc/abc.h"
   "i >= 0 && i < Abc_ObjFaninNum(p)"
# 499 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 499, __extension__ __PRETTY_FUNCTION__); }))
# 499 "/app/abc/src/base/abc/abc.h"
                                           ;
    return (Vec_IntEntry(p->pNtk->vPhases, Abc_ObjId(p)) >> i) & 1;
}
static inline void Abc_ObjFaninFlipPhase(Abc_Obj_t *p, int i)
{
    
# 504 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 504 "/app/abc/src/base/abc/abc.h"
   p->pNtk->vPhases
# 504 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 504 "/app/abc/src/base/abc/abc.h"
   p->pNtk->vPhases
# 504 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 504 "/app/abc/src/base/abc/abc.h"
   "p->pNtk->vPhases"
# 504 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 504, __extension__ __PRETTY_FUNCTION__); }))
# 504 "/app/abc/src/base/abc/abc.h"
                           ;
    
# 505 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 505 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < Abc_ObjFaninNum(p)
# 505 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 505 "/app/abc/src/base/abc/abc.h"
   i >= 0 && i < Abc_ObjFaninNum(p)
# 505 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 505 "/app/abc/src/base/abc/abc.h"
   "i >= 0 && i < Abc_ObjFaninNum(p)"
# 505 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 505, __extension__ __PRETTY_FUNCTION__); }))
# 505 "/app/abc/src/base/abc/abc.h"
                                           ;
    *Vec_IntEntryP(p->pNtk->vPhases, Abc_ObjId(p)) ^= (1 << i);
}


static inline int Abc_AigNodeIsConst(Abc_Obj_t *pNode)
{
    
# 512 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 512 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(Abc_ObjRegular(pNode)->pNtk)
# 512 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 512 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(Abc_ObjRegular(pNode)->pNtk)
# 512 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 512 "/app/abc/src/base/abc/abc.h"
   "Abc_NtkIsStrash(Abc_ObjRegular(pNode)->pNtk)"
# 512 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 512, __extension__ __PRETTY_FUNCTION__); }))
# 512 "/app/abc/src/base/abc/abc.h"
                                                       ;
    return Abc_ObjRegular(pNode)->Type == ABC_OBJ_CONST1;
}
static inline int Abc_AigNodeIsAnd(Abc_Obj_t *pNode)
{
    
# 517 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 517 "/app/abc/src/base/abc/abc.h"
   !Abc_ObjIsComplement(pNode)
# 517 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 517 "/app/abc/src/base/abc/abc.h"
   !Abc_ObjIsComplement(pNode)
# 517 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 517 "/app/abc/src/base/abc/abc.h"
   "!Abc_ObjIsComplement(pNode)"
# 517 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 517, __extension__ __PRETTY_FUNCTION__); }))
# 517 "/app/abc/src/base/abc/abc.h"
                                      ;
    
# 518 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 518 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(pNode->pNtk)
# 518 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 518 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(pNode->pNtk)
# 518 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 518 "/app/abc/src/base/abc/abc.h"
   "Abc_NtkIsStrash(pNode->pNtk)"
# 518 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 518, __extension__ __PRETTY_FUNCTION__); }))
# 518 "/app/abc/src/base/abc/abc.h"
                                       ;
    return Abc_ObjFaninNum(pNode) == 2;
}
static inline int Abc_AigNodeIsChoice(Abc_Obj_t *pNode)
{
    
# 523 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 523 "/app/abc/src/base/abc/abc.h"
   !Abc_ObjIsComplement(pNode)
# 523 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 523 "/app/abc/src/base/abc/abc.h"
   !Abc_ObjIsComplement(pNode)
# 523 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 523 "/app/abc/src/base/abc/abc.h"
   "!Abc_ObjIsComplement(pNode)"
# 523 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 523, __extension__ __PRETTY_FUNCTION__); }))
# 523 "/app/abc/src/base/abc/abc.h"
                                      ;
    
# 524 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 524 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(pNode->pNtk)
# 524 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 524 "/app/abc/src/base/abc/abc.h"
   Abc_NtkIsStrash(pNode->pNtk)
# 524 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 524 "/app/abc/src/base/abc/abc.h"
   "Abc_NtkIsStrash(pNode->pNtk)"
# 524 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 524, __extension__ __PRETTY_FUNCTION__); }))
# 524 "/app/abc/src/base/abc/abc.h"
                                       ;
    return pNode->pData != 
# 525 "/app/abc/src/base/abc/abc.h" 3 4
                          ((void *)0) 
# 525 "/app/abc/src/base/abc/abc.h"
                               && Abc_ObjFanoutNum(pNode) > 0;
}


static inline int Abc_NodeIsPersistant(Abc_Obj_t *pNode)
{
    
# 531 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 531 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 531 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 531 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 531 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 531 "/app/abc/src/base/abc/abc.h"
   "Abc_AigNodeIsAnd(pNode)"
# 531 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 531, __extension__ __PRETTY_FUNCTION__); }))
# 531 "/app/abc/src/base/abc/abc.h"
                                  ;
    return pNode->fPersist;
}
static inline void Abc_NodeSetPersistant(Abc_Obj_t *pNode)
{
    
# 536 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 536 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 536 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 536 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 536 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 536 "/app/abc/src/base/abc/abc.h"
   "Abc_AigNodeIsAnd(pNode)"
# 536 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 536, __extension__ __PRETTY_FUNCTION__); }))
# 536 "/app/abc/src/base/abc/abc.h"
                                  ;
    pNode->fPersist = 1;
}
static inline void Abc_NodeClearPersistant(Abc_Obj_t *pNode)
{
    
# 541 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 541 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 541 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 541 "/app/abc/src/base/abc/abc.h"
   Abc_AigNodeIsAnd(pNode)
# 541 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 541 "/app/abc/src/base/abc/abc.h"
   "Abc_AigNodeIsAnd(pNode)"
# 541 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 541, __extension__ __PRETTY_FUNCTION__); }))
# 541 "/app/abc/src/base/abc/abc.h"
                                  ;
    pNode->fPersist = 0;
}


static inline void Abc_NtkIncrementTravId(Abc_Ntk_t *p)
{
    if (!p->vTravIds.pArray)
        Vec_IntFill(&p->vTravIds, Abc_NtkObjNumMax(p) + 500, 0);
    p->nTravIds++;
    
# 551 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 551 "/app/abc/src/base/abc/abc.h"
   p->nTravIds < (1 << 30)
# 551 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 551 "/app/abc/src/base/abc/abc.h"
   p->nTravIds < (1 << 30)
# 551 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 551 "/app/abc/src/base/abc/abc.h"
   "p->nTravIds < (1 << 30)"
# 551 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 551, __extension__ __PRETTY_FUNCTION__); }))
# 551 "/app/abc/src/base/abc/abc.h"
                                  ;
}
static inline int Abc_NodeTravId(Abc_Obj_t *p) { return Vec_IntGetEntry(&Abc_ObjNtk(p)->vTravIds, Abc_ObjId(p)); }
static inline void Abc_NodeSetTravId(Abc_Obj_t *p, int TravId) { Vec_IntSetEntry(&Abc_ObjNtk(p)->vTravIds, Abc_ObjId(p), TravId); }
static inline void Abc_NodeSetTravIdCurrent(Abc_Obj_t *p) { Abc_NodeSetTravId(p, Abc_ObjNtk(p)->nTravIds); }
static inline void Abc_NodeSetTravIdPrevious(Abc_Obj_t *p) { Abc_NodeSetTravId(p, Abc_ObjNtk(p)->nTravIds - 1); }
static inline int Abc_NodeIsTravIdCurrent(Abc_Obj_t *p) { return (Abc_NodeTravId(p) == Abc_ObjNtk(p)->nTravIds); }
static inline int Abc_NodeIsTravIdPrevious(Abc_Obj_t *p) { return (Abc_NodeTravId(p) == Abc_ObjNtk(p)->nTravIds - 1); }
static inline void Abc_NodeSetTravIdCurrentId(Abc_Ntk_t *p, int i) { Vec_IntSetEntry(&p->vTravIds, i, p->nTravIds); }
static inline int Abc_NodeIsTravIdCurrentId(Abc_Ntk_t *p, int i) { return (Vec_IntGetEntry(&p->vTravIds, i) == p->nTravIds); }


static inline void Abc_LatchSetInitNone(Abc_Obj_t *pLatch)
{
    
# 565 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 565 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 565 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 565 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 565 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 565 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 565 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 565, __extension__ __PRETTY_FUNCTION__); }))
# 565 "/app/abc/src/base/abc/abc.h"
                                 ;
    pLatch->pData = (void *)ABC_INIT_NONE;
}
static inline void Abc_LatchSetInit0(Abc_Obj_t *pLatch)
{
    
# 570 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 570 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 570 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 570 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 570 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 570 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 570 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 570, __extension__ __PRETTY_FUNCTION__); }))
# 570 "/app/abc/src/base/abc/abc.h"
                                 ;
    pLatch->pData = (void *)ABC_INIT_ZERO;
}
static inline void Abc_LatchSetInit1(Abc_Obj_t *pLatch)
{
    
# 575 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 575 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 575 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 575 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 575 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 575 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 575 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 575, __extension__ __PRETTY_FUNCTION__); }))
# 575 "/app/abc/src/base/abc/abc.h"
                                 ;
    pLatch->pData = (void *)ABC_INIT_ONE;
}
static inline void Abc_LatchSetInitDc(Abc_Obj_t *pLatch)
{
    
# 580 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 580 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 580 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 580 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 580 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 580 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 580 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 580, __extension__ __PRETTY_FUNCTION__); }))
# 580 "/app/abc/src/base/abc/abc.h"
                                 ;
    pLatch->pData = (void *)ABC_INIT_DC;
}
static inline int Abc_LatchIsInitNone(Abc_Obj_t *pLatch)
{
    
# 585 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 585 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 585 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 585 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 585 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 585 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 585 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 585, __extension__ __PRETTY_FUNCTION__); }))
# 585 "/app/abc/src/base/abc/abc.h"
                                 ;
    return pLatch->pData == (void *)ABC_INIT_NONE;
}
static inline int Abc_LatchIsInit0(Abc_Obj_t *pLatch)
{
    
# 590 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 590 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 590 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 590 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 590 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 590 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 590 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 590, __extension__ __PRETTY_FUNCTION__); }))
# 590 "/app/abc/src/base/abc/abc.h"
                                 ;
    return pLatch->pData == (void *)ABC_INIT_ZERO;
}
static inline int Abc_LatchIsInit1(Abc_Obj_t *pLatch)
{
    
# 595 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 595 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 595 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 595 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 595 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 595 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 595 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 595, __extension__ __PRETTY_FUNCTION__); }))
# 595 "/app/abc/src/base/abc/abc.h"
                                 ;
    return pLatch->pData == (void *)ABC_INIT_ONE;
}
static inline int Abc_LatchIsInitDc(Abc_Obj_t *pLatch)
{
    
# 600 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 600 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 600 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 600 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 600 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 600 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 600 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 600, __extension__ __PRETTY_FUNCTION__); }))
# 600 "/app/abc/src/base/abc/abc.h"
                                 ;
    return pLatch->pData == (void *)ABC_INIT_DC;
}
static inline int Abc_LatchInit(Abc_Obj_t *pLatch)
{
    
# 605 "/app/abc/src/base/abc/abc.h" 3 4
   ((void) sizeof ((
# 605 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 605 "/app/abc/src/base/abc/abc.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 605 "/app/abc/src/base/abc/abc.h"
   Abc_ObjIsLatch(pLatch)
# 605 "/app/abc/src/base/abc/abc.h" 3 4
   ) ; else __assert_fail (
# 605 "/app/abc/src/base/abc/abc.h"
   "Abc_ObjIsLatch(pLatch)"
# 605 "/app/abc/src/base/abc/abc.h" 3 4
   , "/app/abc/src/base/abc/abc.h", 605, __extension__ __PRETTY_FUNCTION__); }))
# 605 "/app/abc/src/base/abc/abc.h"
                                 ;
    return (int)(ABC_PTRINT_T)pLatch->pData;
}


static inline void *Abc_NtkGlobalBdd(Abc_Ntk_t *pNtk) { return Vec_PtrEntry(pNtk->vAttrs, VEC_ATTR_GLOBAL_BDD); }
static inline void *Abc_NtkGlobalBddMan(Abc_Ntk_t *pNtk) { return Vec_AttMan((Vec_Att_t *)Abc_NtkGlobalBdd(pNtk)); }
static inline void **Abc_NtkGlobalBddArray(Abc_Ntk_t *pNtk) { return Vec_AttArray((Vec_Att_t *)Abc_NtkGlobalBdd(pNtk)); }
static inline void *Abc_ObjGlobalBdd(Abc_Obj_t *pObj) { return Vec_AttEntry((Vec_Att_t *)Abc_NtkGlobalBdd(pObj->pNtk), pObj->Id); }
static inline void Abc_ObjSetGlobalBdd(Abc_Obj_t *pObj, void *bF) { Vec_AttWriteEntry((Vec_Att_t *)Abc_NtkGlobalBdd(pObj->pNtk), pObj->Id, bF); }


static inline void *Abc_NtkMvVar(Abc_Ntk_t *pNtk) { return Vec_PtrEntry(pNtk->vAttrs, VEC_ATTR_MVVAR); }
static inline void *Abc_NtkMvVarMan(Abc_Ntk_t *pNtk) { return Abc_NtkMvVar(pNtk) ? Vec_AttMan((Vec_Att_t *)Abc_NtkMvVar(pNtk)) : 
# 618 "/app/abc/src/base/abc/abc.h" 3 4
                                                                                                                                ((void *)0)
# 618 "/app/abc/src/base/abc/abc.h"
                                                                                                                                    ; }
static inline void *Abc_ObjMvVar(Abc_Obj_t *pObj) { return Abc_NtkMvVar(pObj->pNtk) ? Vec_AttEntry((Vec_Att_t *)Abc_NtkMvVar(pObj->pNtk), pObj->Id) : 
# 619 "/app/abc/src/base/abc/abc.h" 3 4
                                                                                                                                                     ((void *)0)
# 619 "/app/abc/src/base/abc/abc.h"
                                                                                                                                                         ; }
static inline int Abc_ObjMvVarNum(Abc_Obj_t *pObj) { return (Abc_NtkMvVar(pObj->pNtk) && Abc_ObjMvVar(pObj)) ? *((int *)Abc_ObjMvVar(pObj)) : 2; }
static inline void Abc_ObjSetMvVar(Abc_Obj_t *pObj, void *pV) { Vec_AttWriteEntry((Vec_Att_t *)Abc_NtkMvVar(pObj->pNtk), pObj->Id, pV); }
# 791 "/app/abc/src/base/abc/abc.h"
extern Abc_Aig_t *Abc_AigAlloc(Abc_Ntk_t *pNtk);
extern void Abc_AigFree(Abc_Aig_t *pMan);
extern int Abc_AigCleanup(Abc_Aig_t *pMan);
extern int Abc_AigCheck(Abc_Aig_t *pMan);
extern int Abc_AigLevel(Abc_Ntk_t *pNtk);
extern Abc_Obj_t *Abc_AigConst1(Abc_Ntk_t *pNtk);
extern Abc_Obj_t *Abc_AigAnd(Abc_Aig_t *pMan, Abc_Obj_t *p0, Abc_Obj_t *p1);
extern Abc_Obj_t *Abc_AigAndLookup(Abc_Aig_t *pMan, Abc_Obj_t *p0, Abc_Obj_t *p1);
extern Abc_Obj_t *Abc_AigXorLookup(Abc_Aig_t *pMan, Abc_Obj_t *p0, Abc_Obj_t *p1, int *pType);
extern Abc_Obj_t *Abc_AigMuxLookup(Abc_Aig_t *pMan, Abc_Obj_t *pC, Abc_Obj_t *pT, Abc_Obj_t *pE, int *pType);
extern Abc_Obj_t *Abc_AigOr(Abc_Aig_t *pMan, Abc_Obj_t *p0, Abc_Obj_t *p1);
extern Abc_Obj_t *Abc_AigXor(Abc_Aig_t *pMan, Abc_Obj_t *p0, Abc_Obj_t *p1);
extern Abc_Obj_t *Abc_AigMux(Abc_Aig_t *pMan, Abc_Obj_t *pC, Abc_Obj_t *p1, Abc_Obj_t *p0);
extern Abc_Obj_t *Abc_AigMiter(Abc_Aig_t *pMan, Vec_Ptr_t *vPairs, int fImplic);
extern int Abc_AigReplace(Abc_Aig_t *pMan, Abc_Obj_t *pOld, Abc_Obj_t *pNew, int fUpdateLevel);
extern void Abc_AigDeleteNode(Abc_Aig_t *pMan, Abc_Obj_t *pOld);
extern void Abc_AigRehash(Abc_Aig_t *pMan);
extern int Abc_AigNodeHasComplFanoutEdge(Abc_Obj_t *pNode);
extern int Abc_AigNodeHasComplFanoutEdgeTrav(Abc_Obj_t *pNode);
extern void Abc_AigPrintNode(Abc_Obj_t *pNode);
extern int Abc_AigNodeIsAcyclic(Abc_Obj_t *pNode, Abc_Obj_t *pRoot);
extern void Abc_AigCheckFaninOrder(Abc_Aig_t *pMan);
extern void Abc_AigSetNodePhases(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_AigUpdateStart(Abc_Aig_t *pMan, Vec_Ptr_t **pvUpdatedNets);
extern void Abc_AigUpdateStop(Abc_Aig_t *pMan);
extern void Abc_AigUpdateReset(Abc_Aig_t *pMan);

extern int Abc_NtkAttach(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkToBarBufs(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkFromBarBufs(Abc_Ntk_t *pNtkBase, Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkBarBufsToBuffers(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkBarBufsFromBuffers(Abc_Ntk_t *pNtkBase, Abc_Ntk_t *pNtk);

extern void Abc_NtkStartMvVars(Abc_Ntk_t *pNtk);
extern void Abc_NtkFreeMvVars(Abc_Ntk_t *pNtk);
extern void Abc_NtkSetMvVarValues(Abc_Obj_t *pObj, int nValues);
extern Abc_Ntk_t *Abc_NtkStrashBlifMv(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkInsertBlifMv(Abc_Ntk_t *pNtkBase, Abc_Ntk_t *pNtkLogic);
extern int Abc_NtkConvertToBlifMv(Abc_Ntk_t *pNtk);
extern char *Abc_NodeConvertSopToMvSop(int nVars, Vec_Int_t *vSop0, Vec_Int_t *vSop1);
extern int Abc_NodeEvalMvCost(int nVars, Vec_Int_t *vSop0, Vec_Int_t *vSop1);

extern Abc_Ntk_t *Abc_NtkBalance(Abc_Ntk_t *pNtk, int fDuplicate, int fSelective, int fUpdateLevel);

extern int Abc_NtkCheck(Abc_Ntk_t *pNtk);
extern int Abc_NtkCheckRead(Abc_Ntk_t *pNtk);
extern int Abc_NtkDoCheck(Abc_Ntk_t *pNtk);
extern int Abc_NtkCheckObj(Abc_Ntk_t *pNtk, Abc_Obj_t *pObj);
extern int Abc_NtkCompareSignals(Abc_Ntk_t *pNtk1, Abc_Ntk_t *pNtk2, int fOnlyPis, int fComb);
extern int Abc_NtkIsAcyclicHierarchy(Abc_Ntk_t *pNtk);
extern int Abc_NtkCheckUniqueCiNames(Abc_Ntk_t *pNtk);
extern int Abc_NtkCheckUniqueCoNames(Abc_Ntk_t *pNtk);
extern int Abc_NtkCheckUniqueCioNames(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkCollapse(Abc_Ntk_t *pNtk, int fBddSizeMax, int fDualRail, int fReorder, int fReverse, int fDumpOrder, int fVerbose);
extern Abc_Ntk_t *Abc_NtkCollapseSat(Abc_Ntk_t *pNtk, int nCubeLim, int nBTLimit, int nCostMax, int fCanon, int fReverse, int fCnfShared, int fVerbose);
extern Gia_Man_t *Abc_NtkClpGia(Abc_Ntk_t *pNtk);

extern void *Abc_NodeGetCutsRecursive(void *p, Abc_Obj_t *pObj, int fDag, int fTree);
extern void *Abc_NodeGetCuts(void *p, Abc_Obj_t *pObj, int fDag, int fTree);
extern void Abc_NodeGetCutsSeq(void *p, Abc_Obj_t *pObj, int fFirst);
extern void *Abc_NodeReadCuts(void *p, Abc_Obj_t *pObj);
extern void Abc_NodeFreeCuts(void *p, Abc_Obj_t *pObj);

extern int Abc_NtkPhaseFrameNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkDarPrintCone(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkBalanceExor(Abc_Ntk_t *pNtk, int fUpdateLevel, int fVerbose);
extern Abc_Ntk_t *Abc_NtkDarLatchSweep(Abc_Ntk_t *pNtk, int fLatchConst, int fLatchEqual, int fSaveNames, int fUseMvSweep, int nFramesSymb, int nFramesSatur, int fVerbose, int fVeryVerbose);

extern float Abc_NtkDelayTraceLut(Abc_Ntk_t *pNtk, int fUseLutLib);

extern Vec_Ptr_t *Abc_NtkDfs(Abc_Ntk_t *pNtk, int fCollectAll);
extern Vec_Ptr_t *Abc_NtkDfs2(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkDfsNodes(Abc_Ntk_t *pNtk, Abc_Obj_t **ppNodes, int nNodes);
extern Vec_Ptr_t *Abc_NtkDfsReverse(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkDfsReverseNodes(Abc_Ntk_t *pNtk, Abc_Obj_t **ppNodes, int nNodes);
extern Vec_Ptr_t *Abc_NtkDfsReverseNodesContained(Abc_Ntk_t *pNtk, Abc_Obj_t **ppNodes, int nNodes);
extern Vec_Ptr_t *Abc_NtkDfsSeq(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkDfsSeqReverse(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkDfsIter(Abc_Ntk_t *pNtk, int fCollectAll);
extern Vec_Ptr_t *Abc_NtkDfsIterNodes(Abc_Ntk_t *pNtk, Vec_Ptr_t *vRoots);
extern Vec_Ptr_t *Abc_NtkDfsHie(Abc_Ntk_t *pNtk, int fCollectAll);
extern int Abc_NtkIsDfsOrdered(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkDfsWithBoxes(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkSupport(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkNodeSupport(Abc_Ntk_t *pNtk, Abc_Obj_t **ppNodes, int nNodes);
extern Vec_Int_t *Abc_NtkNodeSupportInt(Abc_Ntk_t *pNtk, int iCo);
extern int Abc_NtkFunctionalIso(Abc_Ntk_t *pNtk, int iCo1, int iCo2, int fCommon);
extern Vec_Ptr_t *Abc_AigDfs(Abc_Ntk_t *pNtk, int fCollectAll, int fCollectCos);
extern Vec_Ptr_t *Abc_AigDfsMap(Abc_Ntk_t *pNtk);
extern Vec_Vec_t *Abc_DfsLevelized(Abc_Obj_t *pNode, int fTfi);
extern Vec_Vec_t *Abc_NtkLevelize(Abc_Ntk_t *pNtk);
extern int Abc_NtkLevel(Abc_Ntk_t *pNtk);
extern int Abc_NtkLevelReverse(Abc_Ntk_t *pNtk);
extern int Abc_NtkIsAcyclic(Abc_Ntk_t *pNtk);
extern int Abc_NtkIsAcyclicWithBoxes(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_AigGetLevelizedOrder(Abc_Ntk_t *pNtk, int fCollectCis);

extern int Abc_ExactInputNum();
extern int Abc_ExactIsRunning();
extern Abc_Obj_t *Abc_ExactBuildNode(word *pTruth, int nVars, int *pArrTimeProfile, Abc_Obj_t **pFanins, Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkFindExact(word *pTruth, int nVars, int nFunc, int nMaxDepth, int *pArrivalTimes, int nBTLimit, int nStartGates, int fVerbose);

extern void Abc_ObjAddFanin(Abc_Obj_t *pObj, Abc_Obj_t *pFanin);
extern void Abc_ObjDeleteFanin(Abc_Obj_t *pObj, Abc_Obj_t *pFanin);
extern void Abc_ObjRemoveFanins(Abc_Obj_t *pObj);
extern void Abc_ObjPatchFanin(Abc_Obj_t *pObj, Abc_Obj_t *pFaninOld, Abc_Obj_t *pFaninNew);
extern void Abc_ObjPatchFanoutFanin(Abc_Obj_t *pObj, int iObjNew);
extern Abc_Obj_t *Abc_ObjInsertBetween(Abc_Obj_t *pNodeIn, Abc_Obj_t *pNodeOut, Abc_ObjType_t Type);
extern void Abc_ObjTransferFanout(Abc_Obj_t *pObjOld, Abc_Obj_t *pObjNew);
extern void Abc_ObjReplace(Abc_Obj_t *pObjOld, Abc_Obj_t *pObjNew);
extern void Abc_ObjReplaceByConstant(Abc_Obj_t *pNode, int fConst1);
extern int Abc_ObjFanoutFaninNum(Abc_Obj_t *pFanout, Abc_Obj_t *pFanin);

extern int Abc_NtkMakeLegit(Abc_Ntk_t *pNtk);
extern void Abc_NtkSortSops(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkFraig(Abc_Ntk_t *pNtk, void *pParams, int fAllNodes, int fExdc);
extern void *Abc_NtkToFraig(Abc_Ntk_t *pNtk, void *pParams, int fAllNodes, int fExdc);
extern Abc_Ntk_t *Abc_NtkFraigTrust(Abc_Ntk_t *pNtk);
extern int Abc_NtkFraigStore(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkFraigRestore(int nPatsRand, int nPatsDyna, int nBTLimit);
extern void Abc_NtkFraigStoreClean();

extern int Abc_NtkSopToBdd(Abc_Ntk_t *pNtk);
extern int Abc_NtkBddToSop(Abc_Ntk_t *pNtk, int fMode, int nCubeLimit, int fCubeSort);
extern void Abc_NodeBddToCnf(Abc_Obj_t *pNode, Mem_Flex_t *pMmMan, Vec_Str_t *vCube, int fAllPrimes, char **ppSop0, char **ppSop1);
extern void Abc_NtkLogicMakeDirectSops(Abc_Ntk_t *pNtk);
extern int Abc_NtkSopToAig(Abc_Ntk_t *pNtk);
extern int Abc_NtkAigToBdd(Abc_Ntk_t *pNtk);
extern Gia_Man_t *Abc_NtkAigToGia(Abc_Ntk_t *p, int fGiaSimple);
extern int Abc_NtkMapToSopUsingLibrary(Abc_Ntk_t *pNtk, void *library);
extern int Abc_NtkMapToSop(Abc_Ntk_t *pNtk);
extern int Abc_NtkToSop(Abc_Ntk_t *pNtk, int fMode, int nCubeLimit);
extern int Abc_NtkToBdd(Abc_Ntk_t *pNtk);
extern int Abc_NtkToAig(Abc_Ntk_t *pNtk);

extern int Abc_NtkHaigStart(Abc_Ntk_t *pNtk);
extern int Abc_NtkHaigStop(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkHaigUse(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkFlattenLogicHierarchy(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkConvertBlackboxes(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkInsertNewLogic(Abc_Ntk_t *pNtkH, Abc_Ntk_t *pNtkL);
extern void Abc_NtkPrintBoxInfo(Abc_Ntk_t *pNtk);

extern Gia_Man_t *Abc_NtkFlattenHierarchyGia(Abc_Ntk_t *pNtk, Vec_Ptr_t **pvBuffers, int fVerbose);
extern void Abc_NtkInsertHierarchyGia(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNew, int fVerbose);

extern int Abc_NtkLatchIsSelfFeed(Abc_Obj_t *pLatch);
extern int Abc_NtkCountSelfFeedLatches(Abc_Ntk_t *pNtk);
extern int Abc_NtkRemoveSelfFeedLatches(Abc_Ntk_t *pNtk);
extern Vec_Int_t *Abc_NtkCollectLatchValues(Abc_Ntk_t *pNtk);
extern char *Abc_NtkCollectLatchValuesStr(Abc_Ntk_t *pNtk);
extern void Abc_NtkInsertLatchValues(Abc_Ntk_t *pNtk, Vec_Int_t *vValues);
extern Abc_Obj_t *Abc_NtkAddLatch(Abc_Ntk_t *pNtk, Abc_Obj_t *pDriver, Abc_InitType_t Init);
extern void Abc_NtkConvertDcLatches(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkConverLatchNamesIntoNumbers(Abc_Ntk_t *pNtk);

extern Abc_Des_t *Abc_DesCreate(char *pName);
extern void Abc_DesCleanManPointer(Abc_Des_t *p, void *pMan);
extern void Abc_DesFree(Abc_Des_t *p, Abc_Ntk_t *pNtk);
extern Abc_Des_t *Abc_DesDup(Abc_Des_t *p);
extern void Abc_DesPrint(Abc_Des_t *p);
extern int Abc_DesAddModel(Abc_Des_t *p, Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_DesFindModelByName(Abc_Des_t *p, char *pName);
extern int Abc_DesFindTopLevelModels(Abc_Des_t *p);
extern Abc_Ntk_t *Abc_DesDeriveRoot(Abc_Des_t *p);

extern void Abc_NtkWriteLogFile(char *pFileName, Abc_Cex_t *pSeqCex, int Status, int nFrames, char *pCommand);

extern Abc_Obj_t *Abc_NtkFetchTwinNode(Abc_Obj_t *pNode);

extern int Abc_NtkMinimumBase(Abc_Ntk_t *pNtk);
extern int Abc_NodeMinimumBase(Abc_Obj_t *pNode);
extern int Abc_NtkRemoveDupFanins(Abc_Ntk_t *pNtk);
extern int Abc_NodeRemoveDupFanins(Abc_Obj_t *pNode);

extern Abc_Ntk_t *Abc_NtkMiter(Abc_Ntk_t *pNtk1, Abc_Ntk_t *pNtk2, int fComb, int nPartSize, int fImplic, int fMulti);
extern void Abc_NtkMiterAddCone(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNtkMiter, Abc_Obj_t *pNode);
extern Abc_Ntk_t *Abc_NtkMiterAnd(Abc_Ntk_t *pNtk1, Abc_Ntk_t *pNtk2, int fOr, int fCompl2);
extern Abc_Ntk_t *Abc_NtkMiterCofactor(Abc_Ntk_t *pNtk, Vec_Int_t *vPiValues);
extern Abc_Ntk_t *Abc_NtkMiterForCofactors(Abc_Ntk_t *pNtk, int Out, int In1, int In2);
extern Abc_Ntk_t *Abc_NtkMiterQuantify(Abc_Ntk_t *pNtk, int In, int fExist);
extern Abc_Ntk_t *Abc_NtkMiterQuantifyPis(Abc_Ntk_t *pNtk);
extern int Abc_NtkMiterIsConstant(Abc_Ntk_t *pMiter);
extern void Abc_NtkMiterReport(Abc_Ntk_t *pMiter);
extern Abc_Ntk_t *Abc_NtkFrames(Abc_Ntk_t *pNtk, int nFrames, int fInitial, int fVerbose);
extern int Abc_NtkCombinePos(Abc_Ntk_t *pNtk, int fAnd, int fXor);

extern char *Abc_ObjName(Abc_Obj_t *pNode);
extern char *Abc_ObjAssignName(Abc_Obj_t *pObj, char *pName, char *pSuffix);
extern char *Abc_ObjNamePrefix(Abc_Obj_t *pObj, char *pPrefix);
extern char *Abc_ObjNameSuffix(Abc_Obj_t *pObj, char *pSuffix);
extern char *Abc_ObjNameDummy(char *pPrefix, int Num, int nDigits);
extern void Abc_NtkTrasferNames(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNtkNew);
extern void Abc_NtkTrasferNamesNoLatches(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNtkNew);
extern Vec_Ptr_t *Abc_NodeGetFaninNames(Abc_Obj_t *pNode);
extern Vec_Ptr_t *Abc_NodeGetFakeNames(int nNames);
extern void Abc_NodeFreeNames(Vec_Ptr_t *vNames);
extern char **Abc_NtkCollectCioNames(Abc_Ntk_t *pNtk, int fCollectCos);
extern int Abc_NodeCompareNames(Abc_Obj_t **pp1, Abc_Obj_t **pp2);
extern void Abc_NtkOrderObjsByName(Abc_Ntk_t *pNtk, int fComb);
extern void Abc_NtkAddDummyPiNames(Abc_Ntk_t *pNtk);
extern void Abc_NtkAddDummyPoNames(Abc_Ntk_t *pNtk);
extern void Abc_NtkAddDummyBoxNames(Abc_Ntk_t *pNtk);
extern void Abc_NtkShortNames(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanNames(Abc_Ntk_t *pNtk);
extern void Abc_NtkStartNameIds(Abc_Ntk_t *p);
extern void Abc_NtkTransferNameIds(Abc_Ntk_t *p, Abc_Ntk_t *pNew);
extern void Abc_NtkUpdateNameIds(Abc_Ntk_t *p);

extern Abc_Ntk_t *Abc_NtkToLogic(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkToNetlist(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkToNetlistBench(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkDeriveFromBdd(void *dd, void *bFunc, char *pNamePo, Vec_Ptr_t *vNamesPi);
extern Abc_Ntk_t *Abc_NtkBddToMuxes(Abc_Ntk_t *pNtk, int fGlobal, int Limit, int fUseAdd);
extern void *Abc_NtkBuildGlobalBdds(Abc_Ntk_t *pNtk, int fBddSizeMax, int fDropInternal, int fReorder, int fReverse, int fVerbose);
extern void *Abc_NtkFreeGlobalBdds(Abc_Ntk_t *pNtk, int fFreeMan);
extern int Abc_NtkSizeOfGlobalBdds(Abc_Ntk_t *pNtk);

extern Abc_Ntk_t *Abc_NtkAlloc(Abc_NtkType_t Type, Abc_NtkFunc_t Func, int fUseMemMan);
extern Abc_Ntk_t *Abc_NtkStartFrom(Abc_Ntk_t *pNtk, Abc_NtkType_t Type, Abc_NtkFunc_t Func);
extern Abc_Ntk_t *Abc_NtkStartFromNoLatches(Abc_Ntk_t *pNtk, Abc_NtkType_t Type, Abc_NtkFunc_t Func);
extern void Abc_NtkFinalize(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNtkNew);
extern Abc_Ntk_t *Abc_NtkStartRead(char *pName);
extern void Abc_NtkFinalizeRead(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkDup(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkDupDfs(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkDupDfsNoBarBufs(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkDupTransformMiter(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkCreateCone(Abc_Ntk_t *pNtk, Abc_Obj_t *pNode, char *pNodeName, int fUseAllCis);
extern Abc_Ntk_t *Abc_NtkCreateConeArray(Abc_Ntk_t *pNtk, Vec_Ptr_t *vRoots, int fUseAllCis);
extern void Abc_NtkAppendToCone(Abc_Ntk_t *pNtkNew, Abc_Ntk_t *pNtk, Vec_Ptr_t *vRoots);
extern Abc_Ntk_t *Abc_NtkCreateMffc(Abc_Ntk_t *pNtk, Abc_Obj_t *pNode, char *pNodeName);
extern Abc_Ntk_t *Abc_NtkCreateTarget(Abc_Ntk_t *pNtk, Vec_Ptr_t *vRoots, Vec_Int_t *vValues);
extern Abc_Ntk_t *Abc_NtkCreateFromNode(Abc_Ntk_t *pNtk, Abc_Obj_t *pNode);
extern Abc_Ntk_t *Abc_NtkCreateFromRange(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkCreateWithNode(char *pSop);
extern Abc_Ntk_t *Abc_NtkCreateWithNodes(Vec_Ptr_t *vSops);
extern void Abc_NtkDelete(Abc_Ntk_t *pNtk);
extern void Abc_NtkFixNonDrivenNets(Abc_Ntk_t *pNtk);
extern void Abc_NtkMakeComb(Abc_Ntk_t *pNtk, int fRemoveLatches);
extern void Abc_NtkPermute(Abc_Ntk_t *pNtk, int fInputs, int fOutputs, int fFlops, char *pFlopPermFile);
extern void Abc_NtkUnpermute(Abc_Ntk_t *pNtk);
extern Abc_Ntk_t *Abc_NtkCreateFromSops(char *pName, Vec_Ptr_t *vSops);
extern Abc_Ntk_t *Abc_NtkCreateFromGias(char *pName, Vec_Ptr_t *vGias, Gia_Man_t *pMulti);

extern Abc_Obj_t *Abc_ObjAlloc(Abc_Ntk_t *pNtk, Abc_ObjType_t Type);
extern void Abc_ObjRecycle(Abc_Obj_t *pObj);
extern Abc_Obj_t *Abc_NtkCreateObj(Abc_Ntk_t *pNtk, Abc_ObjType_t Type);
extern void Abc_NtkDeleteObj(Abc_Obj_t *pObj);
extern void Abc_NtkDeleteObjPo(Abc_Obj_t *pObj);
extern void Abc_NtkDeleteObj_rec(Abc_Obj_t *pObj, int fOnlyNodes);
extern void Abc_NtkDeleteAll_rec(Abc_Obj_t *pObj);
extern Abc_Obj_t *Abc_NtkDupObj(Abc_Ntk_t *pNtkNew, Abc_Obj_t *pObj, int fCopyName);
extern Abc_Obj_t *Abc_NtkDupBox(Abc_Ntk_t *pNtkNew, Abc_Obj_t *pBox, int fCopyName);
extern Abc_Obj_t *Abc_NtkCloneObj(Abc_Obj_t *pNode);
extern Abc_Obj_t *Abc_NtkFindNode(Abc_Ntk_t *pNtk, char *pName);
extern Abc_Obj_t *Abc_NtkFindNet(Abc_Ntk_t *pNtk, char *pName);
extern Abc_Obj_t *Abc_NtkFindCi(Abc_Ntk_t *pNtk, char *pName);
extern Abc_Obj_t *Abc_NtkFindCo(Abc_Ntk_t *pNtk, char *pName);
extern Abc_Obj_t *Abc_NtkFindOrCreateNet(Abc_Ntk_t *pNtk, char *pName);
extern Abc_Obj_t *Abc_NtkCreateNodeConst0(Abc_Ntk_t *pNtk);
extern Abc_Obj_t *Abc_NtkCreateNodeConst1(Abc_Ntk_t *pNtk);
extern Abc_Obj_t *Abc_NtkCreateNodeInv(Abc_Ntk_t *pNtk, Abc_Obj_t *pFanin);
extern Abc_Obj_t *Abc_NtkCreateNodeBuf(Abc_Ntk_t *pNtk, Abc_Obj_t *pFanin);
extern Abc_Obj_t *Abc_NtkCreateNodeAnd(Abc_Ntk_t *pNtk, Vec_Ptr_t *vFanins);
extern Abc_Obj_t *Abc_NtkCreateNodeOr(Abc_Ntk_t *pNtk, Vec_Ptr_t *vFanins);
extern Abc_Obj_t *Abc_NtkCreateNodeExor(Abc_Ntk_t *pNtk, Vec_Ptr_t *vFanins);
extern Abc_Obj_t *Abc_NtkCreateNodeMux(Abc_Ntk_t *pNtk, Abc_Obj_t *pNodeC, Abc_Obj_t *pNode1, Abc_Obj_t *pNode0);
extern int Abc_NodeIsConst(Abc_Obj_t *pNode);
extern int Abc_NodeIsConst0(Abc_Obj_t *pNode);
extern int Abc_NodeIsConst1(Abc_Obj_t *pNode);
extern int Abc_NodeIsBuf(Abc_Obj_t *pNode);
extern int Abc_NodeIsInv(Abc_Obj_t *pNode);
extern void Abc_NodeComplement(Abc_Obj_t *pNode);
extern void Abc_NodeComplementInput(Abc_Obj_t *pNode, Abc_Obj_t *pFanin);

typedef struct Odc_Man_t_ Odc_Man_t;
extern Odc_Man_t *Abc_NtkDontCareAlloc(int nVarsMax, int nLevels, int fVerbose, int fVeryVerbose);
extern void Abc_NtkDontCareClear(Odc_Man_t *p);
extern void Abc_NtkDontCareFree(Odc_Man_t *p);
extern int Abc_NtkDontCareCompute(Odc_Man_t *p, Abc_Obj_t *pNode, Vec_Ptr_t *vLeaves, unsigned *puTruth);

extern float Abc_NtkMfsTotalSwitching(Abc_Ntk_t *pNtk);
extern float Abc_NtkMfsTotalGlitching(Abc_Ntk_t *pNtk, int nPats, int Prob, int fVerbose);
extern void Abc_NtkPrintStats(Abc_Ntk_t *pNtk, int fFactored, int fSaveBest, int fDumpResult, int fUseLutLib, int fPrintMuxes, int fPower, int fGlitch, int fSkipBuf, int fSkipSmall, int fPrintMem);
extern void Abc_NtkPrintIo(FILE *pFile, Abc_Ntk_t *pNtk, int fPrintFlops);
extern void Abc_NtkPrintLatch(FILE *pFile, Abc_Ntk_t *pNtk);
extern void Abc_NtkPrintFanio(FILE *pFile, Abc_Ntk_t *pNtk, int fUseFanio, int fUsePio, int fUseSupp, int fUseCone);
extern void Abc_NtkPrintFanioNew(FILE *pFile, Abc_Ntk_t *pNtk, int fMffc);
extern void Abc_NodePrintFanio(FILE *pFile, Abc_Obj_t *pNode);
extern void Abc_NtkPrintFactor(FILE *pFile, Abc_Ntk_t *pNtk, int fUseRealNames);
extern void Abc_NodePrintFactor(FILE *pFile, Abc_Obj_t *pNode, int fUseRealNames);
extern void Abc_NtkPrintLevel(FILE *pFile, Abc_Ntk_t *pNtk, int fProfile, int fListNodes, int fOutputs, int fVerbose);
extern void Abc_NodePrintLevel(FILE *pFile, Abc_Obj_t *pNode);
extern void Abc_NtkPrintSkews(FILE *pFile, Abc_Ntk_t *pNtk, int fPrintAll);
extern void Abc_ObjPrint(FILE *pFile, Abc_Obj_t *pObj);
extern void Abc_NtkShow6VarFunc(char *pF0, char *pF1);

extern int Abc_NtkMiterProve(Abc_Ntk_t **ppNtk, void *pParams);
extern int Abc_NtkIvyProve(Abc_Ntk_t **ppNtk, void *pPars);

extern void Abc_NtkRecStart3(Gia_Man_t *p, int nVars, int nCuts, int fFuncOnly, int fVerbose);
extern void Abc_NtkRecStop3();
extern void Abc_NtkRecAdd3(Abc_Ntk_t *pNtk, int fUseSOPB);
extern void Abc_NtkRecPs3(int fPrintLib);
extern Gia_Man_t *Abc_NtkRecGetGia3();
extern int Abc_NtkRecIsRunning3();
extern void Abc_NtkRecLibMerge3(Gia_Man_t *pGia);
extern int Abc_NtkRecInputNum3();


extern Abc_ManCut_t *Abc_NtkManCutStart(int nNodeSizeMax, int nConeSizeMax, int nNodeFanStop, int nConeFanStop);
extern void Abc_NtkManCutStop(Abc_ManCut_t *p);
extern Vec_Ptr_t *Abc_NtkManCutReadCutLarge(Abc_ManCut_t *p);
extern Vec_Ptr_t *Abc_NtkManCutReadCutSmall(Abc_ManCut_t *p);
extern Vec_Ptr_t *Abc_NtkManCutReadVisited(Abc_ManCut_t *p);
extern Vec_Ptr_t *Abc_NodeFindCut(Abc_ManCut_t *p, Abc_Obj_t *pRoot, int fContain);
extern void Abc_NodeConeCollect(Abc_Obj_t **ppRoots, int nRoots, Vec_Ptr_t *vFanins, Vec_Ptr_t *vVisited, int fIncludeFanins);
extern Vec_Ptr_t *Abc_NodeCollectTfoCands(Abc_ManCut_t *p, Abc_Obj_t *pRoot, Vec_Ptr_t *vFanins, int LevelMax);

extern int Abc_NodeMffcSize(Abc_Obj_t *pNode);
extern int Abc_NodeMffcSizeSupp(Abc_Obj_t *pNode);
extern int Abc_NodeMffcSizeStop(Abc_Obj_t *pNode);
extern int Abc_NodeMffcLabelAig(Abc_Obj_t *pNode);
extern int Abc_NodeMffcLabel(Abc_Obj_t *pNode, Vec_Ptr_t *vNodes);
extern void Abc_NodeMffcConeSupp(Abc_Obj_t *pNode, Vec_Ptr_t *vCone, Vec_Ptr_t *vSupp);
extern int Abc_NodeDeref_rec(Abc_Obj_t *pNode);
extern int Abc_NodeRef_rec(Abc_Obj_t *pNode);

extern int Abc_NtkRefactor(Abc_Ntk_t *pNtk, int nNodeSizeMax, int nMinSaved, int nConeSizeMax, int fUpdateLevel, int fUseZeros, int fUseDcs, int fVerbose);

extern int Abc_NtkRewrite(Abc_Ntk_t *pNtk, int fUpdateLevel, int fUseZeros, int fVerbose, int fVeryVerbose, int fPlaceEnable);

extern int Abc_NtkMiterSat(Abc_Ntk_t *pNtk, ABC_INT64_T nConfLimit, ABC_INT64_T nInsLimit, int fVerbose, ABC_INT64_T *pNumConfs, ABC_INT64_T *pNumInspects);
extern void *Abc_NtkMiterSatCreate(Abc_Ntk_t *pNtk, int fAllPrimes);

extern char *Abc_SopRegister(Mem_Flex_t *pMan, const char *pName);
extern char *Abc_SopStart(Mem_Flex_t *pMan, int nCubes, int nVars);
extern char *Abc_SopCreateConst0(Mem_Flex_t *pMan);
extern char *Abc_SopCreateConst1(Mem_Flex_t *pMan);
extern char *Abc_SopCreateAnd2(Mem_Flex_t *pMan, int fCompl0, int fCompl1);
extern char *Abc_SopCreateAnd(Mem_Flex_t *pMan, int nVars, int *pfCompl);
extern char *Abc_SopCreateNand(Mem_Flex_t *pMan, int nVars);
extern char *Abc_SopCreateOr(Mem_Flex_t *pMan, int nVars, int *pfCompl);
extern char *Abc_SopCreateOrMultiCube(Mem_Flex_t *pMan, int nVars, int *pfCompl);
extern char *Abc_SopCreateNor(Mem_Flex_t *pMan, int nVars);
extern char *Abc_SopCreateXor(Mem_Flex_t *pMan, int nVars);
extern char *Abc_SopCreateXorSpecial(Mem_Flex_t *pMan, int nVars);
extern char *Abc_SopCreateNxor(Mem_Flex_t *pMan, int nVars);
extern char *Abc_SopCreateMux(Mem_Flex_t *pMan);
extern char *Abc_SopCreateInv(Mem_Flex_t *pMan);
extern char *Abc_SopCreateBuf(Mem_Flex_t *pMan);
extern char *Abc_SopCreateFromTruth(Mem_Flex_t *pMan, int nVars, unsigned *pTruth);
extern char *Abc_SopCreateFromIsop(Mem_Flex_t *pMan, int nVars, Vec_Int_t *vCover);
extern char *Abc_SopCreateFromTruthIsop(Mem_Flex_t *pMan, int nVars, word *pTruth, Vec_Int_t *vCover);
extern int Abc_SopGetCubeNum(char *pSop);
extern int Abc_SopGetLitNum(char *pSop);
extern int Abc_SopGetVarNum(char *pSop);
extern int Abc_SopGetPhase(char *pSop);
extern int Abc_SopGetIthCareLit(char *pSop, int i);
extern void Abc_SopComplement(char *pSop);
extern void Abc_SopComplementVar(char *pSop, int iVar);
extern int Abc_SopIsComplement(char *pSop);
extern int Abc_SopIsConst0(char *pSop);
extern int Abc_SopIsConst1(char *pSop);
extern int Abc_SopIsBuf(char *pSop);
extern int Abc_SopIsInv(char *pSop);
extern int Abc_SopIsAndType(char *pSop);
extern int Abc_SopIsOrType(char *pSop);
extern int Abc_SopIsExorType(char *pSop);
extern int Abc_SopCheck(char *pSop, int nFanins);
extern char *Abc_SopFromTruthBin(char *pTruth);
extern char *Abc_SopFromTruthHex(char *pTruth);
extern Vec_Ptr_t *Abc_SopFromTruthsBin(char *pTruth);
extern Vec_Ptr_t *Abc_SopFromTruthsHex(char *pTruth);
extern char *Abc_SopEncoderPos(Mem_Flex_t *pMan, int iValue, int nValues);
extern char *Abc_SopEncoderLog(Mem_Flex_t *pMan, int iBit, int nValues);
extern char *Abc_SopDecoderPos(Mem_Flex_t *pMan, int nValues);
extern char *Abc_SopDecoderLog(Mem_Flex_t *pMan, int nValues);
extern word Abc_SopToTruth(char *pSop, int nInputs);
extern void Abc_SopToTruth7(char *pSop, int nInputs, word r[2]);
extern void Abc_SopToTruthBig(char *pSop, int nInputs, word **pVars, word *pCube, word *pRes);

extern Abc_Ntk_t *Abc_NtkRestrash(Abc_Ntk_t *pNtk, int fCleanup);
extern Abc_Ntk_t *Abc_NtkRestrashZero(Abc_Ntk_t *pNtk, int fCleanup);
extern Abc_Ntk_t *Abc_NtkStrash(Abc_Ntk_t *pNtk, int fAllNodes, int fCleanup, int fRecord);
extern Abc_Obj_t *Abc_NodeStrash(Abc_Ntk_t *pNtkNew, Abc_Obj_t *pNode, int fRecord);
extern int Abc_NtkAppend(Abc_Ntk_t *pNtk1, Abc_Ntk_t *pNtk2, int fAddPos);
extern Abc_Ntk_t *Abc_NtkTopmost(Abc_Ntk_t *pNtk, int nLevels);

extern int Abc_NtkSweep(Abc_Ntk_t *pNtk, int fVerbose);
extern int Abc_NtkCleanup(Abc_Ntk_t *pNtk, int fVerbose);
extern int Abc_NtkCleanupNodes(Abc_Ntk_t *pNtk, Vec_Ptr_t *vNodes, int fVerbose);
extern int Abc_NtkCleanupSeq(Abc_Ntk_t *pNtk, int fLatchSweep, int fAutoSweep, int fVerbose);
extern int Abc_NtkSweepBufsInvs(Abc_Ntk_t *pNtk, int fVerbose);

extern Abc_Time_t *Abc_NtkReadDefaultArrival(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NtkReadDefaultRequired(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NodeReadArrival(Abc_Obj_t *pNode);
extern Abc_Time_t *Abc_NodeReadRequired(Abc_Obj_t *pNode);
extern float Abc_NtkReadDefaultArrivalWorst(Abc_Ntk_t *pNtk);
extern float Abc_NtkReadDefaultRequiredWorst(Abc_Ntk_t *pNtk);
extern float Abc_NodeReadArrivalAve(Abc_Obj_t *pNode);
extern float Abc_NodeReadRequiredAve(Abc_Obj_t *pNode);
extern float Abc_NodeReadArrivalWorst(Abc_Obj_t *pNode);
extern float Abc_NodeReadRequiredWorst(Abc_Obj_t *pNode);
extern Abc_Time_t *Abc_NtkReadDefaultInputDrive(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NtkReadDefaultOutputLoad(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NodeReadInputDrive(Abc_Ntk_t *pNtk, int iPi);
extern Abc_Time_t *Abc_NodeReadOutputLoad(Abc_Ntk_t *pNtk, int iPo);
extern float Abc_NodeReadInputDriveWorst(Abc_Ntk_t *pNtk, int iPi);
extern float Abc_NodeReadOutputLoadWorst(Abc_Ntk_t *pNtk, int iPo);
extern void Abc_NtkTimeSetDefaultArrival(Abc_Ntk_t *pNtk, float Rise, float Fall);
extern void Abc_NtkTimeSetDefaultRequired(Abc_Ntk_t *pNtk, float Rise, float Fall);
extern void Abc_NtkTimeSetArrival(Abc_Ntk_t *pNtk, int ObjId, float Rise, float Fall);
extern void Abc_NtkTimeSetRequired(Abc_Ntk_t *pNtk, int ObjId, float Rise, float Fall);
extern void Abc_NtkTimeSetDefaultInputDrive(Abc_Ntk_t *pNtk, float Rise, float Fall);
extern void Abc_NtkTimeSetDefaultOutputLoad(Abc_Ntk_t *pNtk, float Rise, float Fall);
extern void Abc_NtkTimeSetInputDrive(Abc_Ntk_t *pNtk, int PiNum, float Rise, float Fall);
extern void Abc_NtkTimeSetOutputLoad(Abc_Ntk_t *pNtk, int PoNum, float Rise, float Fall);
extern void Abc_NtkTimeInitialize(Abc_Ntk_t *pNtk, Abc_Ntk_t *pNtkOld);
extern void Abc_ManTimeStop(Abc_ManTime_t *p);
extern void Abc_ManTimeDup(Abc_Ntk_t *pNtkOld, Abc_Ntk_t *pNtkNew);
extern void Abc_NtkSetNodeLevelsArrival(Abc_Ntk_t *pNtk);
extern float *Abc_NtkGetCiArrivalFloats(Abc_Ntk_t *pNtk);
extern float *Abc_NtkGetCoRequiredFloats(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NtkGetCiArrivalTimes(Abc_Ntk_t *pNtk);
extern Abc_Time_t *Abc_NtkGetCoRequiredTimes(Abc_Ntk_t *pNtk);
extern float Abc_NtkDelayTrace(Abc_Ntk_t *pNtk, Abc_Obj_t *pOut, Abc_Obj_t *pIn, int fPrint);
extern int Abc_ObjLevelNew(Abc_Obj_t *pObj);
extern int Abc_ObjReverseLevelNew(Abc_Obj_t *pObj);
extern int Abc_ObjRequiredLevel(Abc_Obj_t *pObj);
extern int Abc_ObjReverseLevel(Abc_Obj_t *pObj);
extern void Abc_ObjSetReverseLevel(Abc_Obj_t *pObj, int LevelR);
extern void Abc_NtkStartReverseLevels(Abc_Ntk_t *pNtk, int nMaxLevelIncrease);
extern void Abc_NtkStopReverseLevels(Abc_Ntk_t *pNtk);
extern void Abc_NtkUpdateLevel(Abc_Obj_t *pObjNew, Vec_Vec_t *vLevels);
extern void Abc_NtkUpdateReverseLevel(Abc_Obj_t *pObjNew, Vec_Vec_t *vLevels);
extern void Abc_NtkUpdate(Abc_Obj_t *pObj, Abc_Obj_t *pObjNew, Vec_Vec_t *vLevels);

extern void *Abc_NtkAttrFree(Abc_Ntk_t *pNtk, int Attr, int fFreeMan);
extern void Abc_NtkOrderCisCos(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetCubeNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetCubePairNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetLitNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetLitFactNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetBddNodeNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetAigNodeNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetClauseNum(Abc_Ntk_t *pNtk);
extern double Abc_NtkGetMappedArea(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetExorNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetMuxNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetBufNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetLargeNodeNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetChoiceNum(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetFaninMax(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetFanoutMax(Abc_Ntk_t *pNtk);
extern int Abc_NtkGetTotalFanins(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanCopy(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanCopy_rec(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanData(Abc_Ntk_t *pNtk);
extern void Abc_NtkFillTemp(Abc_Ntk_t *pNtk);
extern int Abc_NtkCountCopy(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkSaveCopy(Abc_Ntk_t *pNtk);
extern void Abc_NtkLoadCopy(Abc_Ntk_t *pNtk, Vec_Ptr_t *vCopies);
extern void Abc_NtkCleanNext(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanNext_rec(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanMarkA(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanMarkB(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanMarkC(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanMarkAB(Abc_Ntk_t *pNtk);
extern void Abc_NtkCleanMarkABC(Abc_Ntk_t *pNtk);
extern int Abc_NodeFindFanin(Abc_Obj_t *pNode, Abc_Obj_t *pFanin);
extern Abc_Obj_t *Abc_NodeFindCoFanout(Abc_Obj_t *pNode);
extern Abc_Obj_t *Abc_NodeFindNonCoFanout(Abc_Obj_t *pNode);
extern Abc_Obj_t *Abc_NodeHasUniqueCoFanout(Abc_Obj_t *pNode);
extern int Abc_NtkLogicHasSimpleCos(Abc_Ntk_t *pNtk);
extern int Abc_NtkLogicMakeSimpleCos(Abc_Ntk_t *pNtk, int fDuplicate);
extern void Abc_VecObjPushUniqueOrderByLevel(Vec_Ptr_t *p, Abc_Obj_t *pNode);
extern int Abc_NodeIsExorType(Abc_Obj_t *pNode);
extern int Abc_NodeIsMuxType(Abc_Obj_t *pNode);
extern int Abc_NodeIsMuxControlType(Abc_Obj_t *pNode);
extern Abc_Obj_t *Abc_NodeRecognizeMux(Abc_Obj_t *pNode, Abc_Obj_t **ppNodeT, Abc_Obj_t **ppNodeE);
extern int Abc_NtkPrepareTwoNtks(FILE *pErr, Abc_Ntk_t *pNtk, char **argv, int argc, Abc_Ntk_t **ppNtk1, Abc_Ntk_t **ppNtk2, int *pfDelete1, int *pfDelete2, int fCheck);
extern void Abc_NodeCollectFanins(Abc_Obj_t *pNode, Vec_Ptr_t *vNodes);
extern void Abc_NodeCollectFanouts(Abc_Obj_t *pNode, Vec_Ptr_t *vNodes);
extern Vec_Ptr_t *Abc_NtkCollectLatches(Abc_Ntk_t *pNtk);
extern int Abc_NodeCompareLevelsIncrease(Abc_Obj_t **pp1, Abc_Obj_t **pp2);
extern int Abc_NodeCompareLevelsDecrease(Abc_Obj_t **pp1, Abc_Obj_t **pp2);
extern Vec_Int_t *Abc_NtkFanoutCounts(Abc_Ntk_t *pNtk);
extern Vec_Ptr_t *Abc_NtkCollectObjects(Abc_Ntk_t *pNtk);
extern Vec_Int_t *Abc_NtkGetCiIds(Abc_Ntk_t *pNtk);
extern void Abc_NtkReassignIds(Abc_Ntk_t *pNtk);
extern int Abc_ObjPointerCompare(void **pp1, void **pp2);
extern void Abc_NtkTransferCopy(Abc_Ntk_t *pNtk);
extern void Abc_NtkInvertConstraints(Abc_Ntk_t *pNtk);
extern void Abc_NtkPrintCiLevels(Abc_Ntk_t *pNtk);
extern void Abc_NtkReverseTopoOrder(Abc_Ntk_t *pNtk);
extern int Abc_NtkIsTopo(Abc_Ntk_t *pNtk);
extern void Abc_NtkTransferPhases(Abc_Ntk_t *pNtkNew, Abc_Ntk_t *pNtk);
extern Gia_Man_t *Abc_SopSynthesizeOne(char *pSop, int fClp);


extern int *Abc_NtkVerifyGetCleanModel(Abc_Ntk_t *pNtk, int nFrames);
extern int *Abc_NtkVerifySimulatePattern(Abc_Ntk_t *pNtk, int *pModel);
extern int Abc_NtkIsTrueCex(Abc_Ntk_t *pNtk, Abc_Cex_t *pCex);
extern int Abc_NtkIsValidCex(Abc_Ntk_t *pNtk, Abc_Cex_t *pCex);


# 31 "/app/abc/src/base/main/main.h" 2







# 1 "/app/abc/src/base/main/abcapis.h" 1
# 36 "/app/abc/src/base/main/abcapis.h"


typedef struct Abc_Frame_t_ Abc_Frame_t;
# 65 "/app/abc/src/base/main/abcapis.h"
extern void Abc_Start();
extern void Abc_Stop();


extern Abc_Frame_t *Abc_FrameGetGlobalFrame();
extern int Cmd_CommandExecute(Abc_Frame_t *pAbc, const char *pCommandLine);


extern void Abc_NtkInputMiniAig(Abc_Frame_t *pAbc, void *pMiniAig);
extern void *Abc_NtkOutputMiniAig(Abc_Frame_t *pAbc);
extern void Abc_FrameGiaInputMiniAig(Abc_Frame_t *pAbc, void *p);
extern void *Abc_FrameGiaOutputMiniAig(Abc_Frame_t *pAbc);
extern void Abc_NtkSetFlopNum(Abc_Frame_t *pAbc, int nFlops);


extern void Abc_FrameGiaInputMiniLut(Abc_Frame_t *pAbc, void *pMiniLut);
extern void Abc_FrameGiaInputMiniLut2(Abc_Frame_t *pAbc, void *pMiniLut);
extern void *Abc_FrameGiaOutputMiniLut(Abc_Frame_t *pAbc);
extern char *Abc_FrameGiaOutputMiniLutAttr(Abc_Frame_t *pAbc, void *pMiniLut);
extern int *Abc_FrameReadMiniLutSwitching(Abc_Frame_t *pAbc);
extern int *Abc_FrameReadMiniLutSwitching2(Abc_Frame_t *pAbc, int nRandPiFactor);
extern int *Abc_FrameReadMiniLutSwitchingPo(Abc_Frame_t *pAbc);


extern void Abc_FrameInputNdr(Abc_Frame_t *pAbc, void *pData);
extern void *Abc_FrameOutputNdr(Abc_Frame_t *pAbc);
extern int *Abc_FrameOutputNdrArray(Abc_Frame_t *pAbc);


extern void Abc_NtkSetCiArrivalTime(Abc_Frame_t *pAbc, int iCi, float Rise, float Fall);
extern void Abc_NtkSetCoRequiredTime(Abc_Frame_t *pAbc, int iCo, float Rise, float Fall);


extern void Abc_NtkSetAndGateDelay(Abc_Frame_t *pAbc, float Delay);


extern int *Abc_NtkOutputMiniMapping(Abc_Frame_t *pAbc);
extern void Abc_NtkPrintMiniMapping(int *pArray);
extern int *Abc_FrameReadArrayMapping(Abc_Frame_t *pAbc);
extern int *Abc_FrameReadBoxes(Abc_Frame_t *pAbc);


extern int Abc_FrameReadProbStatus(Abc_Frame_t *pAbc);
extern void *Abc_FrameReadCex(Abc_Frame_t *pAbc);


extern void Abc_FrameSetRetimingData(Abc_Frame_t *pAbc, int *pRst, int *pSet, int *pEna, int nRegs);


extern int *Abc_FrameReadMiniAigEquivClasses(Abc_Frame_t *pAbc);


# 39 "/app/abc/src/base/main/main.h" 2

# 1 "/app/abc/src/base/cmd/cmd.h" 1
# 29 "/app/abc/src/base/cmd/cmd.h"

# 39 "/app/abc/src/base/cmd/cmd.h"
typedef struct MvCommand Abc_Command;
typedef struct MvAlias Abc_Alias;
# 51 "/app/abc/src/base/cmd/cmd.h"
extern void Cmd_Init( Abc_Frame_t * pAbc );
extern void Cmd_End( Abc_Frame_t * pAbc );

typedef int (*Cmd_CommandFuncType)(Abc_Frame_t*, int, char**);
extern int Cmd_CommandIsDefined( Abc_Frame_t * pAbc, const char * sName );
extern void Cmd_CommandAdd( Abc_Frame_t * pAbc, const char * sGroup, const char * sName, Cmd_CommandFuncType pFunc, int fChanges );
extern int Cmd_CommandExecute( Abc_Frame_t * pAbc, const char * sCommand );

extern char * Cmd_FlagReadByName( Abc_Frame_t * pAbc, char * flag );
extern void Cmd_FlagDeleteByName( Abc_Frame_t * pAbc, const char * key );
extern void Cmd_FlagUpdateValue( Abc_Frame_t * pAbc, const char * key, char * value );

extern void Cmd_HistoryAddCommand( Abc_Frame_t * pAbc, const char * command );
extern void Cmd_HistoryRead( Abc_Frame_t * p );
extern void Cmd_HistoryWrite( Abc_Frame_t * p, int Limit );
extern void Cmd_HistoryPrint( Abc_Frame_t * p, int Limit );

extern int CmdCommandLoad( Abc_Frame_t * pAbc, int argc, char ** argv );




# 41 "/app/abc/src/base/main/main.h" 2
# 1 "/app/abc/src/base/io/ioAbc.h" 1
# 31 "/app/abc/src/base/io/ioAbc.h"
# 1 "/app/abc/src/misc/util/utilNam.h" 1
# 33 "/app/abc/src/misc/util/utilNam.h"






typedef struct Abc_Nam_t_ Abc_Nam_t;
# 53 "/app/abc/src/misc/util/utilNam.h"
extern Abc_Nam_t * Abc_NamStart( int nObjs, int nAveSize );
extern void Abc_NamStop( Abc_Nam_t * p );
extern void Abc_NamPrint( Abc_Nam_t * p, char * pFileName );
extern void Abc_NamSave( Abc_Nam_t * p, char * pFileName );
extern Abc_Nam_t * Abc_NamLoad( char * pFileName );
extern Abc_Nam_t * Abc_NamRef( Abc_Nam_t * p );
extern void Abc_NamDeref( Abc_Nam_t * p );
extern int Abc_NamObjNumMax( Abc_Nam_t * p );
extern int Abc_NamMemUsed( Abc_Nam_t * p );
extern int Abc_NamMemAlloc( Abc_Nam_t * p );
extern int Abc_NamStrFind( Abc_Nam_t * p, char * pStr );
extern int Abc_NamStrFindLim( Abc_Nam_t * p, char * pStr, char * pLim );
extern int Abc_NamStrFindOrAdd( Abc_Nam_t * p, char * pStr, int * pfFound );
extern int Abc_NamStrFindOrAddLim( Abc_Nam_t * p, char * pStr, char * pLim, int * pfFound );
extern int Abc_NamStrFindOrAddF( Abc_Nam_t * p, const char * format, ... );
extern char * Abc_NamStr( Abc_Nam_t * p, int id );
extern Vec_Str_t * Abc_NamBuffer( Abc_Nam_t * p );
extern Vec_Int_t * Abc_NamComputeIdMap( Abc_Nam_t * p1, Abc_Nam_t * p2 );
extern int Abc_NamReportCommon( Vec_Int_t * vNameIds1, Abc_Nam_t * p1, Abc_Nam_t * p2 );
extern char * Abc_NamReportUnique( Vec_Int_t * vNameIds1, Abc_Nam_t * p1, Abc_Nam_t * p2 );



# 32 "/app/abc/src/base/io/ioAbc.h" 2















typedef enum {
    IO_FILE_NONE = 0,
    IO_FILE_AIGER,
    IO_FILE_BAF,
    IO_FILE_BBLIF,
    IO_FILE_BLIF,
    IO_FILE_BLIFMV,
    IO_FILE_BENCH,
    IO_FILE_BOOK,
    IO_FILE_CNF,
    IO_FILE_DOT,
    IO_FILE_EDIF,
    IO_FILE_EQN,
    IO_FILE_GML,
    IO_FILE_JSON,
    IO_FILE_LIST,
    IO_FILE_PLA,
    IO_FILE_MOPLA,
    IO_FILE_SMV,
    IO_FILE_VERILOG,
    IO_FILE_UNKNOWN
} Io_FileType_t;
# 81 "/app/abc/src/base/io/ioAbc.h"
extern Abc_Ntk_t * Io_ReadAiger( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadBaf( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadBblif( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadBlif( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadBlifMv( char * pFileName, int fBlifMv, int fCheck );

extern Abc_Ntk_t * Io_ReadBench( char * pFileName, int fCheck );
extern void Io_ReadBenchInit( Abc_Ntk_t * pNtk, char * pFileName );

extern Abc_Ntk_t * Io_ReadEdif( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadEqn( char * pFileName, int fCheck );

extern Abc_Ntk_t * Io_ReadPla( char * pFileName, int fZeros, int fBoth, int fOnDc, int fSkipPrepro, int fCheck );

extern Abc_Ntk_t * Io_ReadVerilog( char * pFileName, int fCheck );

extern void Io_WriteAiger( Abc_Ntk_t * pNtk, char * pFileName, int fWriteSymbols, int fCompact, int fUnique );
extern void Io_WriteAigerCex( Abc_Cex_t * pCex, Abc_Ntk_t * pNtk, void * pG, char * pFileName );

extern void Io_WriteBaf( Abc_Ntk_t * pNtk, char * pFileName );

extern void Io_WriteBblif( Abc_Ntk_t * pNtk, char * pFileName );

extern void Io_WriteBlifLogic( Abc_Ntk_t * pNtk, char * pFileName, int fWriteLatches );
extern void Io_WriteBlif( Abc_Ntk_t * pNtk, char * pFileName, int fWriteLatches, int fBb2Wb, int fSeq );
extern void Io_WriteTimingInfo( FILE * pFile, Abc_Ntk_t * pNtk );
extern void Io_WriteBlifSpecial( Abc_Ntk_t * pNtk, char * FileName, char * pLutStruct, int fUseHie );

extern void Io_WriteBlifMv( Abc_Ntk_t * pNtk, char * FileName );

extern int Io_WriteBench( Abc_Ntk_t * pNtk, const char * FileName );
extern int Io_WriteBenchLut( Abc_Ntk_t * pNtk, char * FileName );

extern void Io_WriteBook( Abc_Ntk_t * pNtk, char * FileName );

extern int Io_WriteCnf( Abc_Ntk_t * pNtk, char * FileName, int fAllPrimes );

extern void Io_WriteDot( Abc_Ntk_t * pNtk, char * FileName );
extern void Io_WriteDotNtk( Abc_Ntk_t * pNtk, Vec_Ptr_t * vNodes, Vec_Ptr_t * vNodesShow, char * pFileName, int fGateNames, int fUseReverse, int fAigIds );
extern void Io_WriteDotSeq( Abc_Ntk_t * pNtk, Vec_Ptr_t * vNodes, Vec_Ptr_t * vNodesShow, char * pFileName, int fGateNames, int fUseReverse );

extern void Io_WriteEqn( Abc_Ntk_t * pNtk, char * pFileName );

extern void Io_WriteEdgelist( Abc_Ntk_t * pNtk, char * pFileName, int fWriteLatches, int fBb2Wb, int fSeq , int fName);

extern void Io_WriteGml( Abc_Ntk_t * pNtk, char * pFileName );

extern void Io_WriteList( Abc_Ntk_t * pNtk, char * pFileName, int fUseHost );

extern int Io_WritePla( Abc_Ntk_t * pNtk, char * FileName );
extern int Io_WriteMoPla( Abc_Ntk_t * pNtk, char * FileName );

extern int Io_WriteSmv( Abc_Ntk_t * pNtk, char * FileName );

extern void Io_WriteVerilog( Abc_Ntk_t * pNtk, char * FileName, int fOnlyAnds, int fNewInterface );

extern Io_FileType_t Io_ReadFileType( char * pFileName );
extern Io_FileType_t Io_ReadLibType( char * pFileName );
extern Abc_Ntk_t * Io_ReadNetlist( char * pFileName, Io_FileType_t FileType, int fCheck );
extern Abc_Ntk_t * Io_Read( char * pFileName, Io_FileType_t FileType, int fCheck, int fBarBufs );
extern void Io_Write( Abc_Ntk_t * pNtk, char * pFileName, Io_FileType_t FileType );
extern void Io_WriteHie( Abc_Ntk_t * pNtk, char * pBaseName, char * pFileName );
extern Abc_Obj_t * Io_ReadCreatePi( Abc_Ntk_t * pNtk, char * pName );
extern Abc_Obj_t * Io_ReadCreatePo( Abc_Ntk_t * pNtk, char * pName );
extern Abc_Obj_t * Io_ReadCreateLatch( Abc_Ntk_t * pNtk, char * pNetLI, char * pNetLO );
extern Abc_Obj_t * Io_ReadCreateResetLatch( Abc_Ntk_t * pNtk, int fBlifMv );
extern Abc_Obj_t * Io_ReadCreateResetMux( Abc_Ntk_t * pNtk, char * pResetLO, char * pDataLI, int fBlifMv );
extern Abc_Obj_t * Io_ReadCreateNode( Abc_Ntk_t * pNtk, char * pNameOut, char * pNamesIn[], int nInputs );
extern Abc_Obj_t * Io_ReadCreateConst( Abc_Ntk_t * pNtk, char * pName, int fConst1 );
extern Abc_Obj_t * Io_ReadCreateInv( Abc_Ntk_t * pNtk, char * pNameIn, char * pNameOut );
extern Abc_Obj_t * Io_ReadCreateBuf( Abc_Ntk_t * pNtk, char * pNameIn, char * pNameOut );
extern FILE * Io_FileOpen( const char * FileName, const char * PathVar, const char * Mode, int fVerbose );


extern void Io_ReadJson( char * pFileName );
extern void Io_WriteJson( char * pFileName );




# 42 "/app/abc/src/base/main/main.h" 2


# 70 "/app/abc/src/base/main/main.h"
extern void Abc_Start();
extern void Abc_Stop();


extern Abc_Ntk_t * Abc_FrameReadNtk( Abc_Frame_t * p );
extern Gia_Man_t * Abc_FrameReadGia( Abc_Frame_t * p );
extern FILE * Abc_FrameReadOut( Abc_Frame_t * p );
extern FILE * Abc_FrameReadErr( Abc_Frame_t * p );
extern int Abc_FrameReadMode( Abc_Frame_t * p );
extern int Abc_FrameSetMode( Abc_Frame_t * p, int fNameMode );
extern void Abc_FrameRestart( Abc_Frame_t * p );
extern int Abc_FrameShowProgress( Abc_Frame_t * p );
extern void Abc_FrameClearVerifStatus( Abc_Frame_t * p );
extern void Abc_FrameUpdateGia( Abc_Frame_t * p, Gia_Man_t * pNew );
extern Gia_Man_t * Abc_FrameGetGia( Abc_Frame_t * p );

extern void Abc_FrameSetCurrentNetwork( Abc_Frame_t * p, Abc_Ntk_t * pNet );
extern void Abc_FrameSwapCurrentAndBackup( Abc_Frame_t * p );
extern void Abc_FrameReplaceCurrentNetwork( Abc_Frame_t * p, Abc_Ntk_t * pNet );
extern void Abc_FrameUnmapAllNetworks( Abc_Frame_t * p );
extern void Abc_FrameDeleteAllNetworks( Abc_Frame_t * p );

extern void Abc_FrameSetGlobalFrame( Abc_Frame_t * p );
extern Abc_Frame_t * Abc_FrameGetGlobalFrame();
extern Abc_Frame_t * Abc_FrameReadGlobalFrame();

extern Vec_Ptr_t * Abc_FrameReadStore();
extern int Abc_FrameReadStoreSize();
extern void * Abc_FrameReadLibLut();
extern void * Abc_FrameReadLibBox();
extern void * Abc_FrameReadLibGen();
extern void * Abc_FrameReadLibGen2();
extern void * Abc_FrameReadLibSuper();
extern void * Abc_FrameReadLibScl();
extern void * Abc_FrameReadManDd();
extern void * Abc_FrameReadManDec();
extern void * Abc_FrameReadManDsd();
extern void * Abc_FrameReadManDsd2();
extern Vec_Ptr_t * Abc_FrameReadSignalNames();
extern char * Abc_FrameReadSpecName();

extern char * Abc_FrameReadFlag( char * pFlag );
extern int Abc_FrameIsFlagEnabled( char * pFlag );
extern int Abc_FrameIsBatchMode();
extern void Abc_FrameSetBatchMode( int Mode );
extern int Abc_FrameIsBridgeMode();
extern void Abc_FrameSetBridgeMode();

extern int Abc_FrameReadBmcFrames( Abc_Frame_t * p );
extern int Abc_FrameReadProbStatus( Abc_Frame_t * p );
extern void * Abc_FrameReadCex( Abc_Frame_t * p );
extern Vec_Ptr_t * Abc_FrameReadCexVec( Abc_Frame_t * p );
extern Vec_Int_t * Abc_FrameReadStatusVec( Abc_Frame_t * p );
extern Vec_Ptr_t * Abc_FrameReadPoEquivs( Abc_Frame_t * p );
extern Vec_Int_t * Abc_FrameReadPoStatuses( Abc_Frame_t * p );
extern Vec_Int_t * Abc_FrameReadObjIds( Abc_Frame_t * p );
extern Abc_Nam_t * Abc_FrameReadJsonStrs( Abc_Frame_t * p );
extern Vec_Wec_t * Abc_FrameReadJsonObjs( Abc_Frame_t * p );

extern int Abc_FrameReadCexPiNum( Abc_Frame_t * p );
extern int Abc_FrameReadCexRegNum( Abc_Frame_t * p );
extern int Abc_FrameReadCexPo( Abc_Frame_t * p );
extern int Abc_FrameReadCexFrame( Abc_Frame_t * p );

extern void Abc_FrameSetNtkStore( Abc_Ntk_t * pNtk );
extern void Abc_FrameSetNtkStoreSize( int nStored );
extern void Abc_FrameSetLibLut( void * pLib );
extern void Abc_FrameSetLibBox( void * pLib );
extern void Abc_FrameSetLibGen( void * pLib );
extern void Abc_FrameSetLibGen2( void * pLib );
extern void Abc_FrameSetLibSuper( void * pLib );
extern void Abc_FrameSetLibVer( void * pLib );
extern void Abc_FrameSetFlag( char * pFlag, char * pValue );
extern void Abc_FrameSetCex( Abc_Cex_t * pCex );
extern void Abc_FrameSetNFrames( int nFrames );
extern void Abc_FrameSetStatus( int Status );
extern void Abc_FrameSetManDsd( void * pMan );
extern void Abc_FrameSetManDsd2( void * pMan );
extern void Abc_FrameSetInv( Vec_Int_t * vInv );
extern void Abc_FrameSetCnf( Vec_Int_t * vInv );
extern void Abc_FrameSetStr( Vec_Str_t * vInv );
extern void Abc_FrameSetJsonStrs( Abc_Nam_t * pStrs );
extern void Abc_FrameSetJsonObjs( Vec_Wec_t * vObjs );
extern void Abc_FrameSetSignalNames( Vec_Ptr_t * vNames );
extern void Abc_FrameSetSpecName( char * pFileName );

extern int Abc_FrameCheckPoConst( Abc_Frame_t * p, int iPoNum );

extern void Abc_FrameReplaceCex( Abc_Frame_t * pAbc, Abc_Cex_t ** ppCex );
extern void Abc_FrameReplaceCexVec( Abc_Frame_t * pAbc, Vec_Ptr_t ** pvCexVec );
extern void Abc_FrameReplacePoEquivs( Abc_Frame_t * pAbc, Vec_Ptr_t ** pvPoEquivs );
extern void Abc_FrameReplacePoStatuses( Abc_Frame_t * pAbc, Vec_Int_t ** pvStatuses );

extern char * Abc_FrameReadDrivingCell();
extern float Abc_FrameReadMaxLoad();
extern void Abc_FrameSetDrivingCell( char * pName );
extern void Abc_FrameSetMaxLoad( float Load );

extern void Abc_FrameSetArrayMapping( int * p );
extern void Abc_FrameSetBoxes( int * p );


# 30 "/app/abc/src/base/main/mainInt.h" 2
# 1 "/app/abc/src/misc/tim/tim.h" 1
# 86 "/app/abc/src/misc/tim/tim.h"






typedef struct Tim_Man_t_ Tim_Man_t;
# 113 "/app/abc/src/misc/tim/tim.h"
extern void Tim_ManCreateBox( Tim_Man_t * p, int firstIn, int nIns, int firstOut, int nOuts, int iDelayTable, int fBlack );
extern int Tim_ManBoxForCi( Tim_Man_t * p, int iCo );
extern int Tim_ManBoxForCo( Tim_Man_t * p, int iCi );
extern int Tim_ManBoxInputFirst( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxInputLast( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxOutputFirst( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxOutputLast( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxInputNum( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxOutputNum( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxDelayTableId( Tim_Man_t * p, int iBox );
extern float * Tim_ManBoxDelayTable( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxIsBlack( Tim_Man_t * p, int iBox );
extern int Tim_ManBoxCopy( Tim_Man_t * p, int iBox );
extern void Tim_ManBoxSetCopy( Tim_Man_t * p, int iBox, int iCopy );
extern int Tim_ManBoxFindFromCiNum( Tim_Man_t * p, int iCiNum );

extern Vec_Str_t * Tim_ManSave( Tim_Man_t * p, int fHieOnly );
extern Tim_Man_t * Tim_ManLoad( Vec_Str_t * p, int fHieOnly );

extern Tim_Man_t * Tim_ManStart( int nCis, int nCos );
extern Tim_Man_t * Tim_ManDup( Tim_Man_t * p, int fUnitDelay );
extern Tim_Man_t * Tim_ManTrim( Tim_Man_t * p, Vec_Int_t * vBoxPres );
extern Tim_Man_t * Tim_ManReduce( Tim_Man_t * p, Vec_Int_t * vBoxesLeft, int nTermsDiff );
extern Vec_Int_t * Tim_ManAlignTwo( Tim_Man_t * pSpec, Tim_Man_t * pImpl );
extern void Tim_ManCreate( Tim_Man_t * p, void * pLib, Vec_Flt_t * vInArrs, Vec_Flt_t * vOutReqs );
extern float * Tim_ManGetArrTimes( Tim_Man_t * p );
extern float * Tim_ManGetReqTimes( Tim_Man_t * p );
extern void Tim_ManStop( Tim_Man_t * p );
extern void Tim_ManStopP( Tim_Man_t ** p );
extern void Tim_ManPrint( Tim_Man_t * p );
extern void Tim_ManPrintStats( Tim_Man_t * p, int nAnd2Delay );
extern int Tim_ManCiNum( Tim_Man_t * p );
extern int Tim_ManCoNum( Tim_Man_t * p );
extern int Tim_ManPiNum( Tim_Man_t * p );
extern int Tim_ManPoNum( Tim_Man_t * p );
extern int Tim_ManBoxNum( Tim_Man_t * p );
extern int Tim_ManBlackBoxNum( Tim_Man_t * p );
extern void Tim_ManBlackBoxIoNum( Tim_Man_t * p, int * pnBbIns, int * pnBbOuts );
extern int Tim_ManDelayTableNum( Tim_Man_t * p );
extern void Tim_ManSetDelayTables( Tim_Man_t * p, Vec_Ptr_t * vDelayTables );
extern void Tim_ManTravIdDisable( Tim_Man_t * p );
extern void Tim_ManTravIdEnable( Tim_Man_t * p );

extern void Tim_ManInitPiArrival( Tim_Man_t * p, int iPi, float Delay );
extern void Tim_ManInitPoRequired( Tim_Man_t * p, int iPo, float Delay );
extern void Tim_ManInitPiArrivalAll( Tim_Man_t * p, float Delay );
extern void Tim_ManInitPoRequiredAll( Tim_Man_t * p, float Delay );
extern void Tim_ManSetCoArrival( Tim_Man_t * p, int iCo, float Delay );
extern void Tim_ManSetCiRequired( Tim_Man_t * p, int iCi, float Delay );
extern void Tim_ManSetCoRequired( Tim_Man_t * p, int iCo, float Delay );
extern float Tim_ManGetCiArrival( Tim_Man_t * p, int iCi );
extern float Tim_ManGetCoRequired( Tim_Man_t * p, int iCo );

extern void Tim_ManIncrementTravId( Tim_Man_t * p );
extern void Tim_ManSetCurrentTravIdBoxInputs( Tim_Man_t * p, int iBox );
extern void Tim_ManSetCurrentTravIdBoxOutputs( Tim_Man_t * p, int iBox );
extern void Tim_ManSetPreviousTravIdBoxInputs( Tim_Man_t * p, int iBox );
extern void Tim_ManSetPreviousTravIdBoxOutputs( Tim_Man_t * p, int iBox );
extern int Tim_ManIsCiTravIdCurrent( Tim_Man_t * p, int iCi );
extern int Tim_ManIsCoTravIdCurrent( Tim_Man_t * p, int iCo );



# 31 "/app/abc/src/base/main/mainInt.h" 2
# 1 "/app/abc/src/map/if/if.h" 1
# 32 "/app/abc/src/map/if/if.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/map/if/if.h" 2





# 1 "/app/abc/src/misc/vec/vecMem.h" 1
# 39 "/app/abc/src/map/if/if.h" 2
# 1 "/app/abc/src/misc/util/utilTruth.h" 1
# 37 "/app/abc/src/misc/util/utilTruth.h"






static unsigned s_Truths5[6] = {
    0xAAAAAAAA,
    0xCCCCCCCC,
    0xF0F0F0F0,
    0xFF00FF00,
    0xFFFF0000
};

static unsigned s_Truths5Neg[6] = {
    0x55555555,
    0x33333333,
    0x0F0F0F0F,
    0x00FF00FF,
    0x0000FFFF
};

static word s_Truths6[6] = {
    0xAAAAAAAAAAAAAAAA,
    0xCCCCCCCCCCCCCCCC,
    0xF0F0F0F0F0F0F0F0,
    0xFF00FF00FF00FF00,
    0xFFFF0000FFFF0000,
    0xFFFFFFFF00000000
};

static word s_Truths6Neg[6] = {
    0x5555555555555555,
    0x3333333333333333,
    0x0F0F0F0F0F0F0F0F,
    0x00FF00FF00FF00FF,
    0x0000FFFF0000FFFF,
    0x00000000FFFFFFFF
};

static word s_TruthXors[6] = {
    0x0000000000000000,
    0x6666666666666666,
    0x6969696969696969,
    0x6996699669966996,
    0x6996966969969669,
    0x6996966996696996
};

static word s_PMasks[5][3] = {
    { 0x9999999999999999, 0x2222222222222222, 0x4444444444444444 },
    { 0xC3C3C3C3C3C3C3C3, 0x0C0C0C0C0C0C0C0C, 0x3030303030303030 },
    { 0xF00FF00FF00FF00F, 0x00F000F000F000F0, 0x0F000F000F000F00 },
    { 0xFF0000FFFF0000FF, 0x0000FF000000FF00, 0x00FF000000FF0000 },
    { 0xFFFF00000000FFFF, 0x00000000FFFF0000, 0x0000FFFF00000000 }
};

static word s_PPMasks[5][6][3] = {
    {
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x9999999999999999, 0x2222222222222222, 0x4444444444444444 },
        { 0xA5A5A5A5A5A5A5A5, 0x0A0A0A0A0A0A0A0A, 0x5050505050505050 },
        { 0xAA55AA55AA55AA55, 0x00AA00AA00AA00AA, 0x5500550055005500 },
        { 0xAAAA5555AAAA5555, 0x0000AAAA0000AAAA, 0x5555000055550000 },
        { 0xAAAAAAAA55555555, 0x00000000AAAAAAAA, 0x5555555500000000 }
    },
    {
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0xC3C3C3C3C3C3C3C3, 0x0C0C0C0C0C0C0C0C, 0x3030303030303030 },
        { 0xCC33CC33CC33CC33, 0x00CC00CC00CC00CC, 0x3300330033003300 },
        { 0xCCCC3333CCCC3333, 0x0000CCCC0000CCCC, 0x3333000033330000 },
        { 0xCCCCCCCC33333333, 0x00000000CCCCCCCC, 0x3333333300000000 }
    },
    {
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0xF00FF00FF00FF00F, 0x00F000F000F000F0, 0x0F000F000F000F00 },
        { 0xF0F00F0FF0F00F0F, 0x0000F0F00000F0F0, 0x0F0F00000F0F0000 },
        { 0xF0F0F0F00F0F0F0F, 0x00000000F0F0F0F0, 0x0F0F0F0F00000000 }
    },
    {
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0xFF0000FFFF0000FF, 0x0000FF000000FF00, 0x00FF000000FF0000 },
        { 0xFF00FF0000FF00FF, 0x00000000FF00FF00, 0x00FF00FF00000000 }
    },
    {
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 },
        { 0xFFFF00000000FFFF, 0x00000000FFFF0000, 0x0000FFFF00000000 }
    }
};

static inline int Abc_TtBitCount16( int i ) { return __builtin_popcount( i & 0xffff ); }
# 159 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtGetBit( word * p, int k ) { return (int)(p[k>>6] >> (k & 63)) & 1; }
static inline void Abc_TtSetBit( word * p, int k ) { p[k>>6] |= (((word)1)<<(k & 63)); }
static inline void Abc_TtXorBit( word * p, int k ) { p[k>>6] ^= (((word)1)<<(k & 63)); }


static inline int Abc_TtGetQua( word * p, int k ) { return (int)(p[k>>5] >> ((k<<1) & 63)) & 3; }
static inline void Abc_TtSetQua( word * p, int k, int d ) { p[k>>5] |= (((word)d)<<((k<<1) & 63)); }
static inline void Abc_TtXorQua( word * p, int k, int d ) { p[k>>5] ^= (((word)d)<<((k<<1) & 63)); }


static inline int Abc_TtGetHex( word * p, int k ) { return (int)(p[k>>4] >> ((k<<2) & 63)) & 15; }
static inline void Abc_TtSetHex( word * p, int k, int d ) { p[k>>4] |= (((word)d)<<((k<<2) & 63)); }
static inline void Abc_TtXorHex( word * p, int k, int d ) { p[k>>4] ^= (((word)d)<<((k<<2) & 63)); }


static inline int Abc_TtGet256( word * p, int k ) { return (int)(p[k>>3] >> ((k<<3) & 63)) & 255; }
static inline void Abc_TtSet256( word * p, int k, int d ) { p[k>>3] |= (((word)d)<<((k<<3) & 63)); }
static inline void Abc_TtXor256( word * p, int k, int d ) { p[k>>3] ^= (((word)d)<<((k<<3) & 63)); }


static inline int Abc_TtGet65536( word * p, int k ) { return (int)(p[k>>2] >> ((k<<4) & 63))&0xFFFF; }
static inline void Abc_TtSet65536( word * p, int k, int d ) { p[k>>2] |= (((word)d)<<((k<<4) & 63)); }
static inline void Abc_TtXor65536( word * p, int k, int d ) { p[k>>2] ^= (((word)d)<<((k<<4) & 63)); }


static inline int Abc_TtGetV( word * p, int v, int k ) { return (int)((p[k>>(6-v)] << (64-(1<<v)-((k<<v) & 63))) >> (64-(1<<v)));}
static inline void Abc_TtSetV( word * p, int v, int k, int d ) { p[k>>(6-v)] |= (((word)d)<<((k<<v) & 63)); }
static inline void Abc_TtXorV( word * p, int v, int k, int d ) { p[k>>(6-v)] ^= (((word)d)<<((k<<v) & 63)); }
# 199 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtWordNum( int nVars ) { return nVars <= 6 ? 1 : 1 << (nVars-6); }
static inline int Abc_TtByteNum( int nVars ) { return nVars <= 3 ? 1 : 1 << (nVars-3); }
static inline int Abc_TtHexDigitNum( int nVars ) { return nVars <= 2 ? 1 : 1 << (nVars-2); }
# 214 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Mask( int nBits ) { 
# 214 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                   ((void) sizeof ((
# 214 "/app/abc/src/misc/util/utilTruth.h"
                                                   nBits >= 0 && nBits <= 64
# 214 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                   ) ? 1 : 0), __extension__ ({ if (
# 214 "/app/abc/src/misc/util/utilTruth.h"
                                                   nBits >= 0 && nBits <= 64
# 214 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                   ) ; else __assert_fail (
# 214 "/app/abc/src/misc/util/utilTruth.h"
                                                   "nBits >= 0 && nBits <= 64"
# 214 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                   , "/app/abc/src/misc/util/utilTruth.h", 214, __extension__ __PRETTY_FUNCTION__); }))
# 214 "/app/abc/src/misc/util/utilTruth.h"
                                                                                      ; return (~(word)0) >> (64-nBits); }
static inline void Abc_TtMask( word * pTruth, int nWords, int nBits )
{
    int w;
    
# 218 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 218 "/app/abc/src/misc/util/utilTruth.h"
   nBits >= 0 && nBits <= nWords * 64
# 218 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 218 "/app/abc/src/misc/util/utilTruth.h"
   nBits >= 0 && nBits <= nWords * 64
# 218 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 218 "/app/abc/src/misc/util/utilTruth.h"
   "nBits >= 0 && nBits <= nWords * 64"
# 218 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 218, __extension__ __PRETTY_FUNCTION__); }))
# 218 "/app/abc/src/misc/util/utilTruth.h"
                                               ;
    for ( w = 0; w < nWords; w++ )
        if ( nBits >= (w + 1) * 64 )
            pTruth[w] = ~(word)0;
        else if ( nBits > w * 64 )
            pTruth[w] = Abc_Tt6Mask( nBits - w * 64 );
        else
            pTruth[w] = 0;
}
# 239 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_TtWordReverseBits( word w )
{
    int Rev[16] = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};
    word r = 0; int i;
    for ( i = 0; i < 16; i++ )
        r |= (word)Rev[(w >> (i<<2))&15] << ((15-i)<<2);
    return r;
}
static inline word Abc_TtWordReverseHexDigits( word w )
{
    word r = 0; int i;
    for ( i = 0; i < 16; i++ )
        r |= ((w >> (i<<2))&15) << ((15-i)<<2);
    return r;
}
# 266 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtVec( word * pOut, int nWords, word Entry )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = Entry;
}
static inline void Abc_TtConst( word * pOut, int nWords, int fConst1 )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = fConst1 ? ~(word)0 : 0;
}
static inline void Abc_TtClear( word * pOut, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = 0;
}
static inline void Abc_TtFill( word * pOut, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = ~(word)0;
}
static inline void Abc_TtUnit( word * pOut, int nWords, int fCompl )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = fCompl ? ~s_Truths6[0] : s_Truths6[0];
}
static inline void Abc_TtNot( word * pOut, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = ~pOut[w];
}
static inline void Abc_TtCopy( word * pOut, word * pIn, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            pOut[w] = ~pIn[w];
    else
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn[w];
}
static inline word * Abc_TtDup( word * pIn, int nWords, int fCompl )
{
    word * pOut = ((word *) malloc(sizeof(word) * (size_t)(nWords)));
    Abc_TtCopy( pOut, pIn, nWords, fCompl );
    return pOut;
}
static inline void Abc_TtAnd( word * pOut, word * pIn1, word * pIn2, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            pOut[w] = ~(pIn1[w] & pIn2[w]);
    else
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn1[w] & pIn2[w];
}
static inline void Abc_TtAndCompl( word * pOut, word * pIn1, int fCompl1, word * pIn2, int fCompl2, int nWords )
{
    int w;
    if ( fCompl1 )
    {
        if ( fCompl2 )
            for ( w = 0; w < nWords; w++ )
                pOut[w] = ~pIn1[w] & ~pIn2[w];
        else
            for ( w = 0; w < nWords; w++ )
                pOut[w] = ~pIn1[w] & pIn2[w];
    }
    else
    {
        if ( fCompl2 )
            for ( w = 0; w < nWords; w++ )
                pOut[w] = pIn1[w] & ~pIn2[w];
        else
            for ( w = 0; w < nWords; w++ )
                pOut[w] = pIn1[w] & pIn2[w];
    }
}
static inline void Abc_TtAndSharp( word * pOut, word * pIn1, word * pIn2, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn1[w] & ~pIn2[w];
    else
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn1[w] & pIn2[w];
}
static inline void Abc_TtSharp( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = pIn1[w] & ~pIn2[w];
}
static inline void Abc_TtOr( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = pIn1[w] | pIn2[w];
}
static inline void Abc_TtOrXor( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] |= pIn1[w] ^ pIn2[w];
}
static inline void Abc_TtAndXor( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] &= pIn1[w] ^ pIn2[w];
}
static inline void Abc_TtOrAnd( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] |= pIn1[w] & pIn2[w];
}
static inline void Abc_TtSharpOr( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = (pOut[w] & ~pIn1[w]) | pIn2[w];
}
static inline void Abc_TtXor( word * pOut, word * pIn1, word * pIn2, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn1[w] ^ ~pIn2[w];
    else
        for ( w = 0; w < nWords; w++ )
            pOut[w] = pIn1[w] ^ pIn2[w];
}
static inline void Abc_TtXorMask( word * pOut, word * pIn1, word * pIn2, word * pMask, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            pOut[w] = (pIn1[w] ^ pIn2[w]) & ~pMask[w];
    else
        for ( w = 0; w < nWords; w++ )
            pOut[w] = (pIn1[w] ^ pIn2[w]) & pMask[w];
}
static inline void Abc_TtMux( word * pOut, word * pCtrl, word * pIn1, word * pIn0, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = (pCtrl[w] & pIn1[w]) | (~pCtrl[w] & pIn0[w]);
}
static inline void Abc_TtMaj( word * pOut, word * pIn0, word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pOut[w] = (pIn0[w] & pIn1[w]) | (pIn0[w] & pIn2[w]) | (pIn1[w] & pIn2[w]);
}
static inline int Abc_TtIntersect( word * pIn1, word * pIn2, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
    {
        for ( w = 0; w < nWords; w++ )
            if ( ~pIn1[w] & pIn2[w] )
                return 1;
    }
    else
    {
        for ( w = 0; w < nWords; w++ )
            if ( pIn1[w] & pIn2[w] )
                return 1;
    }
    return 0;
}
static inline int Abc_TtIntersectCare( word * pIn1, word * pIn2, word * pCare, int nWords, int fCompl )
{
    int w;
    if ( fCompl )
    {
        for ( w = 0; w < nWords; w++ )
            if ( ~pIn1[w] & pIn2[w] & pCare[w] )
                return 1;
    }
    else
    {
        for ( w = 0; w < nWords; w++ )
            if ( pIn1[w] & pIn2[w] & pCare[w] )
                return 1;
    }
    return 0;
}static inline int Abc_TtIntersectOne( word * pOut, int fComp, word * pIn, int fComp0, int nWords )
{
    int w;
    if ( fComp0 )
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn[w] & pOut[w] )
                    return 1;
        }
    }
    else
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn[w] & pOut[w] )
                    return 1;
        }
    }
    return 0;
}
static inline int Abc_TtIntersectTwo( word * pOut, int fComp, word * pIn0, int fComp0, word * pIn1, int fComp1, int nWords )
{
    int w;
    if ( fComp0 && fComp1 )
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn0[w] & ~pIn1[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn0[w] & ~pIn1[w] & pOut[w] )
                    return 1;
        }
    }
    else if ( fComp0 )
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn0[w] & pIn1[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~pIn0[w] & pIn1[w] & pOut[w] )
                    return 1;
        }
    }
    else if ( fComp1 )
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn0[w] & ~pIn1[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn0[w] & ~pIn1[w] & pOut[w] )
                    return 1;
        }
    }
    else
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn0[w] & pIn1[w] & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( pIn0[w] & pIn1[w] & pOut[w] )
                    return 1;
        }
    }
    return 0;
}
static inline int Abc_TtIntersectXor( word * pOut, int fComp, word * pIn0, word * pIn1, int fComp01, int nWords )
{
    int w;
    if ( fComp01 )
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~(pIn0[w] ^ pIn1[w]) & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( ~(pIn0[w] ^ pIn1[w]) & pOut[w] )
                    return 1;
        }
    }
    else
    {
        if ( fComp )
        {
            for ( w = 0; w < nWords; w++ )
                if ( (pIn0[w] ^ pIn1[w]) & ~pOut[w] )
                    return 1;
        }
        else
        {
            for ( w = 0; w < nWords; w++ )
                if ( (pIn0[w] ^ pIn1[w]) & pOut[w] )
                    return 1;
        }
    }
    return 0;
}
static inline int Abc_TtEqual( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] != pIn2[w] )
            return 0;
    return 1;
}
static inline int Abc_TtEqualCare( word * pIn1, word * pIn2, word * pCare, int fComp, int nWords )
{
    int w;
    if ( fComp )
    {
        for ( w = 0; w < nWords; w++ )
            if ( (~pIn1[w] ^ pIn2[w]) & pCare[w] )
                return 0;
    }
    else
    {
        for ( w = 0; w < nWords; w++ )
            if ( (pIn1[w] ^ pIn2[w]) & pCare[w] )
                return 0;
    }
    return 1;
}
static inline int Abc_TtOpposite( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] != ~pIn2[w] )
            return 0;
    return 1;
}
static inline int Abc_TtImply( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( (pIn1[w] & pIn2[w]) != pIn1[w] )
            return 0;
    return 1;
}
static inline int Abc_TtCompare( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] != pIn2[w] )
            return (pIn1[w] < pIn2[w]) ? -1 : 1;
    return 0;
}
static inline int Abc_TtCompareRev( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn1[w] != pIn2[w] )
            return (pIn1[w] < pIn2[w]) ? -1 : 1;
    return 0;
}
static inline int Abc_TtIsConst0( word * pIn1, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] )
            return 0;
    return 1;
}
static inline int Abc_TtIsConst1( word * pIn1, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( ~pIn1[w] )
            return 0;
    return 1;
}
static inline void Abc_TtConst0( word * pIn1, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pIn1[w] = 0;
}
static inline void Abc_TtConst1( word * pIn1, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        pIn1[w] = ~(word)0;
}
static inline void Abc_TtIthVar( word * pOut, int iVar, int nVars )
{
    int k, nWords = Abc_TtWordNum( nVars );
    if ( iVar < 6 )
    {
        for ( k = 0; k < nWords; k++ )
            pOut[k] = s_Truths6[iVar];
    }
    else
    {
        for ( k = 0; k < nWords; k++ )
            if ( k & (1 << (iVar-6)) )
                pOut[k] = ~(word)0;
            else
                pOut[k] = 0;
    }
}
static inline void Abc_TtTruth2( word * pOut, word * pIn0, word * pIn1, int Truth, int nWords )
{
    int w;
    
# 701 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 701 "/app/abc/src/misc/util/utilTruth.h"
   Truth >= 0 && Truth <= 0xF
# 701 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 701 "/app/abc/src/misc/util/utilTruth.h"
   Truth >= 0 && Truth <= 0xF
# 701 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 701 "/app/abc/src/misc/util/utilTruth.h"
   "Truth >= 0 && Truth <= 0xF"
# 701 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 701, __extension__ __PRETTY_FUNCTION__); }))
# 701 "/app/abc/src/misc/util/utilTruth.h"
                                       ;
    switch ( Truth )
    {
        case 0x0 : for ( w = 0; w < nWords; w++ ) pOut[w] = 0; break;
        case 0x1 : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn1[w] & ~pIn0[w]; break;
        case 0x2 : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn1[w] & pIn0[w]; break;
        case 0x3 : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn1[w] ; break;
        case 0x4 : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] & ~pIn0[w]; break;
        case 0x5 : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn0[w]; break;
        case 0x6 : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] ^ pIn0[w]; break;
        case 0x7 : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn1[w] | ~pIn0[w]; break;
        case 0x8 : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] & pIn0[w]; break;
        case 0x9 : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] ^ ~pIn0[w]; break;
        case 0xA : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn0[w]; break;
        case 0xB : for ( w = 0; w < nWords; w++ ) pOut[w] = ~pIn1[w] | pIn0[w]; break;
        case 0xC : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] ; break;
        case 0xD : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] | ~pIn0[w]; break;
        case 0xE : for ( w = 0; w < nWords; w++ ) pOut[w] = pIn1[w] | pIn0[w]; break;
        case 0xF : for ( w = 0; w < nWords; w++ ) pOut[w] = ~(word)0; break;
        default : 
# 720 "/app/abc/src/misc/util/utilTruth.h" 3 4
                  ((void) sizeof ((
# 720 "/app/abc/src/misc/util/utilTruth.h"
                  0
# 720 "/app/abc/src/misc/util/utilTruth.h" 3 4
                  ) ? 1 : 0), __extension__ ({ if (
# 720 "/app/abc/src/misc/util/utilTruth.h"
                  0
# 720 "/app/abc/src/misc/util/utilTruth.h" 3 4
                  ) ; else __assert_fail (
# 720 "/app/abc/src/misc/util/utilTruth.h"
                  "0"
# 720 "/app/abc/src/misc/util/utilTruth.h" 3 4
                  , "/app/abc/src/misc/util/utilTruth.h", 720, __extension__ __PRETTY_FUNCTION__); }))
# 720 "/app/abc/src/misc/util/utilTruth.h"
                             ;
    }
}
static inline void Abc_TtTruth4( word Entry, word ** pNodes, word * pOut, int nWords, int fCompl )
{
    unsigned First = (unsigned)Entry;
    unsigned Second = (unsigned)(Entry >> 32);
    int i, k = 5;
    for ( i = 0; i < 4; i++ )
    {
        int Lit0, Lit1, Pair = (First >> (i*8)) & 0xFF;
        if ( Pair == 0 )
            break;
        Lit0 = Pair & 0xF;
        Lit1 = Pair >> 4;
        
# 735 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 735 "/app/abc/src/misc/util/utilTruth.h"
       Lit0 != Lit1
# 735 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 735 "/app/abc/src/misc/util/utilTruth.h"
       Lit0 != Lit1
# 735 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 735 "/app/abc/src/misc/util/utilTruth.h"
       "Lit0 != Lit1"
# 735 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 735, __extension__ __PRETTY_FUNCTION__); }))
# 735 "/app/abc/src/misc/util/utilTruth.h"
                             ;
        if ( Lit0 < Lit1 )
            Abc_TtAndCompl( pNodes[k++], pNodes[Lit0 >> 1], Lit0 & 1, pNodes[Lit1 >> 1], Lit1 & 1, nWords );
        else
            Abc_TtXor( pNodes[k++], pNodes[Lit0 >> 1], pNodes[Lit1 >> 1], nWords, (Lit0 & 1) ^ (Lit1 & 1) );
    }
    for ( i = 0; i < 3; i++ )
    {
        int Lit0, Lit1, Pair = (Second >> (i*10)) & 0x3FF;
        if ( Pair == 0 )
            break;
        Lit0 = Pair & 0x1F;
        Lit1 = Pair >> 5;
        
# 748 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 748 "/app/abc/src/misc/util/utilTruth.h"
       Lit0 != Lit1
# 748 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 748 "/app/abc/src/misc/util/utilTruth.h"
       Lit0 != Lit1
# 748 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 748 "/app/abc/src/misc/util/utilTruth.h"
       "Lit0 != Lit1"
# 748 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 748, __extension__ __PRETTY_FUNCTION__); }))
# 748 "/app/abc/src/misc/util/utilTruth.h"
                             ;
        if ( Lit0 < Lit1 )
            Abc_TtAndCompl( pNodes[k++], pNodes[Lit0 >> 1], Lit0 & 1, pNodes[Lit1 >> 1], Lit1 & 1, nWords );
        else
            Abc_TtXor( pNodes[k++], pNodes[Lit0 >> 1], pNodes[Lit1 >> 1], nWords, (Lit0 & 1) ^ (Lit1 & 1) );
    }
    
# 754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 754 "/app/abc/src/misc/util/utilTruth.h"
   k > 5
# 754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 754 "/app/abc/src/misc/util/utilTruth.h"
   k > 5
# 754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 754 "/app/abc/src/misc/util/utilTruth.h"
   "k > 5"
# 754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 754, __extension__ __PRETTY_FUNCTION__); }))
# 754 "/app/abc/src/misc/util/utilTruth.h"
                  ;
    Abc_TtCopy( pOut, pNodes[k-1], nWords, (int)(Entry >> 62) ^ fCompl );
}
# 769 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtIsAndCompl( word * pOut, int fCompl, word * pIn1, int fCompl1, word * pIn2, int fCompl2, word * pCare, int nWords )
{
    int w;
    if ( fCompl )
    {
        if ( fCompl1 )
        {
            if ( fCompl2 )
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (~pOut[w] & pCare[w]) != (~pIn1[w] & ~pIn2[w] & pCare[w]) )
                        return 0;
            }
            else
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (~pOut[w] & pCare[w]) != (~pIn1[w] & pIn2[w] & pCare[w]) )
                        return 0;
            }
        }
        else
        {
            if ( fCompl2 )
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (~pOut[w] & pCare[w]) != (pIn1[w] & ~pIn2[w] & pCare[w]) )
                        return 0;
            }
            else
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (~pOut[w] & pCare[w]) != (pIn1[w] & pIn2[w] & pCare[w]) )
                        return 0;
            }
        }
    }
    else
    {
        if ( fCompl1 )
        {
            if ( fCompl2 )
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (pOut[w] & pCare[w]) != (~pIn1[w] & ~pIn2[w] & pCare[w]) )
                        return 0;
            }
            else
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (pOut[w] & pCare[w]) != (~pIn1[w] & pIn2[w] & pCare[w]) )
                        return 0;
            }
        }
        else
        {
            if ( fCompl2 )
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (pOut[w] & pCare[w]) != (pIn1[w] & ~pIn2[w] & pCare[w]) )
                        return 0;
            }
            else
            {
                for ( w = 0; w < nWords; w++ )
                    if ( (pOut[w] & pCare[w]) != (pIn1[w] & pIn2[w] & pCare[w]) )
                        return 0;
            }
        }
    }
    return 1;
}

static inline int Abc_TtIsXorCompl( word * pOut, int fCompl, word * pIn1, word * pIn2, word * pCare, int nWords )
{
    int w;
    if ( fCompl )
    {
        for ( w = 0; w < nWords; w++ )
            if ( (~pOut[w] & pCare[w]) != ((pIn1[w] ^ pIn2[w]) & pCare[w]) )
                return 0;
    }
    else
    {
        for ( w = 0; w < nWords; w++ )
            if ( ( pOut[w] & pCare[w]) != ((pIn1[w] ^ pIn2[w]) & pCare[w]) )
                return 0;
    }
    return 1;
}
# 871 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtCompare1VarCofs( word * pTruth, int nWords, int iVar )
{
    if ( nWords == 1 )
    {
        word Cof0 = pTruth[0] & s_Truths6Neg[iVar];
        word Cof1 = (pTruth[0] >> (1 << iVar)) & s_Truths6Neg[iVar];
        if ( Cof0 != Cof1 )
            return Cof0 < Cof1 ? -1 : 1;
        return 0;
    }
    if ( iVar <= 5 )
    {
        word Cof0, Cof1;
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
        {
            Cof0 = pTruth[w] & s_Truths6Neg[iVar];
            Cof1 = (pTruth[w] >> shift) & s_Truths6Neg[iVar];
            if ( Cof0 != Cof1 )
                return Cof0 < Cof1 ? -1 : 1;
        }
        return 0;
    }

    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        
# 898 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 898 "/app/abc/src/misc/util/utilTruth.h"
       nWords >= 2
# 898 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 898 "/app/abc/src/misc/util/utilTruth.h"
       nWords >= 2
# 898 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 898 "/app/abc/src/misc/util/utilTruth.h"
       "nWords >= 2"
# 898 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 898, __extension__ __PRETTY_FUNCTION__); }))
# 898 "/app/abc/src/misc/util/utilTruth.h"
                            ;
        for ( ; pTruth < pLimit; pTruth += 2*iStep )
            for ( i = 0; i < iStep; i++ )
                if ( pTruth[i] != pTruth[i + iStep] )
                    return pTruth[i] < pTruth[i + iStep] ? -1 : 1;
        return 0;
    }
}
static inline int Abc_TtCompare1VarCofsRev( word * pTruth, int nWords, int iVar )
{
    if ( nWords == 1 )
    {
        word Cof0 = pTruth[0] & s_Truths6Neg[iVar];
        word Cof1 = (pTruth[0] >> (1 << iVar)) & s_Truths6Neg[iVar];
        if ( Cof0 != Cof1 )
            return Cof0 < Cof1 ? -1 : 1;
        return 0;
    }
    if ( iVar <= 5 )
    {
        word Cof0, Cof1;
        int w, shift = (1 << iVar);
        for ( w = nWords - 1; w >= 0; w-- )
        {
            Cof0 = pTruth[w] & s_Truths6Neg[iVar];
            Cof1 = (pTruth[w] >> shift) & s_Truths6Neg[iVar];
            if ( Cof0 != Cof1 )
                return Cof0 < Cof1 ? -1 : 1;
        }
        return 0;
    }

    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        
# 933 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 933 "/app/abc/src/misc/util/utilTruth.h"
       nWords >= 2
# 933 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 933 "/app/abc/src/misc/util/utilTruth.h"
       nWords >= 2
# 933 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 933 "/app/abc/src/misc/util/utilTruth.h"
       "nWords >= 2"
# 933 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 933, __extension__ __PRETTY_FUNCTION__); }))
# 933 "/app/abc/src/misc/util/utilTruth.h"
                            ;
        for ( pLimit -= 2*iStep; pLimit >= pTruth; pLimit -= 2*iStep )
            for ( i = iStep - 1; i >= 0; i-- )
                if ( pLimit[i] != pLimit[i + iStep] )
                    return pLimit[i] < pLimit[i + iStep] ? -1 : 1;
        return 0;
    }
}
# 953 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtElemInit( word ** pTtElems, int nVars )
{
    int i, k, nWords = Abc_TtWordNum( nVars );
    for ( i = 0; i < nVars; i++ )
        if ( i < 6 )
            for ( k = 0; k < nWords; k++ )
                pTtElems[i][k] = s_Truths6[i];
        else
            for ( k = 0; k < nWords; k++ )
                pTtElems[i][k] = (k & (1 << (i-6))) ? ~(word)0 : 0;
}
static inline void Abc_TtElemInit2( word * pTtElems, int nVars )
{
    int i, k, nWords = Abc_TtWordNum( nVars );
    for ( i = 0; i < nVars; i++ )
    {
        word * pTruth = pTtElems + i * nWords;
        if ( i < 6 )
            for ( k = 0; k < nWords; k++ )
                pTruth[k] = s_Truths6[i];
        else
            for ( k = 0; k < nWords; k++ )
                pTruth[k] = (k & (1 << (i-6))) ? ~(word)0 : 0;
    }
}
# 990 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt5HasVar( unsigned t, int iVar )
{
    return ((t << (1<<iVar)) & s_Truths5[iVar]) != (t & s_Truths5[iVar]);
}
static inline unsigned Abc_Tt5Cofactor0( unsigned t, int iVar )
{
    
# 996 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 996 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 5
# 996 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 996 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 5
# 996 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 996 "/app/abc/src/misc/util/utilTruth.h"
   "iVar >= 0 && iVar < 5"
# 996 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 996, __extension__ __PRETTY_FUNCTION__); }))
# 996 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return (t &s_Truths5Neg[iVar]) | ((t &s_Truths5Neg[iVar]) << (1<<iVar));
}
static inline unsigned Abc_Tt5Cofactor1( unsigned t, int iVar )
{
    
# 1001 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1001 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 5
# 1001 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1001 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 5
# 1001 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1001 "/app/abc/src/misc/util/utilTruth.h"
   "iVar >= 0 && iVar < 5"
# 1001 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1001, __extension__ __PRETTY_FUNCTION__); }))
# 1001 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return (t & s_Truths5[iVar]) | ((t & s_Truths5[iVar]) >> (1<<iVar));
}
# 1017 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Cofactor0( word t, int iVar )
{
    
# 1019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1019 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 6
# 1019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1019 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 6
# 1019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1019 "/app/abc/src/misc/util/utilTruth.h"
   "iVar >= 0 && iVar < 6"
# 1019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1019, __extension__ __PRETTY_FUNCTION__); }))
# 1019 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return (t &s_Truths6Neg[iVar]) | ((t &s_Truths6Neg[iVar]) << (1<<iVar));
}
static inline word Abc_Tt6Cofactor1( word t, int iVar )
{
    
# 1024 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1024 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 6
# 1024 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1024 "/app/abc/src/misc/util/utilTruth.h"
   iVar >= 0 && iVar < 6
# 1024 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1024 "/app/abc/src/misc/util/utilTruth.h"
   "iVar >= 0 && iVar < 6"
# 1024 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1024, __extension__ __PRETTY_FUNCTION__); }))
# 1024 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return (t & s_Truths6[iVar]) | ((t & s_Truths6[iVar]) >> (1<<iVar));
}

static inline void Abc_TtCofactor0p( word * pOut, word * pIn, int nWords, int iVar )
{
    if ( nWords == 1 )
        pOut[0] = ((pIn[0] & s_Truths6Neg[iVar]) << (1 << iVar)) | (pIn[0] & s_Truths6Neg[iVar]);
    else if ( iVar <= 5 )
    {
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pOut[w] = ((pIn[w] & s_Truths6Neg[iVar]) << shift) | (pIn[w] & s_Truths6Neg[iVar]);
    }
    else
    {
        word * pLimit = pIn + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pIn < pLimit; pIn += 2*iStep, pOut += 2*iStep )
            for ( i = 0; i < iStep; i++ )
            {
                pOut[i] = pIn[i];
                pOut[i + iStep] = pIn[i];
            }
    }
}
static inline void Abc_TtCofactor1p( word * pOut, word * pIn, int nWords, int iVar )
{
    if ( nWords == 1 )
        pOut[0] = (pIn[0] & s_Truths6[iVar]) | ((pIn[0] & s_Truths6[iVar]) >> (1 << iVar));
    else if ( iVar <= 5 )
    {
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pOut[w] = (pIn[w] & s_Truths6[iVar]) | ((pIn[w] & s_Truths6[iVar]) >> shift);
    }
    else
    {
        word * pLimit = pIn + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pIn < pLimit; pIn += 2*iStep, pOut += 2*iStep )
            for ( i = 0; i < iStep; i++ )
            {
                pOut[i] = pIn[i + iStep];
                pOut[i + iStep] = pIn[i + iStep];
            }
    }
}
static inline void Abc_TtCofactor0( word * pTruth, int nWords, int iVar )
{
    if ( nWords == 1 )
        pTruth[0] = ((pTruth[0] & s_Truths6Neg[iVar]) << (1 << iVar)) | (pTruth[0] & s_Truths6Neg[iVar]);
    else if ( iVar <= 5 )
    {
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pTruth[w] = ((pTruth[w] & s_Truths6Neg[iVar]) << shift) | (pTruth[w] & s_Truths6Neg[iVar]);
    }
    else
    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pTruth < pLimit; pTruth += 2*iStep )
            for ( i = 0; i < iStep; i++ )
                pTruth[i + iStep] = pTruth[i];
    }
}
static inline void Abc_TtCofactor1( word * pTruth, int nWords, int iVar )
{
    if ( nWords == 1 )
        pTruth[0] = (pTruth[0] & s_Truths6[iVar]) | ((pTruth[0] & s_Truths6[iVar]) >> (1 << iVar));
    else if ( iVar <= 5 )
    {
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pTruth[w] = (pTruth[w] & s_Truths6[iVar]) | ((pTruth[w] & s_Truths6[iVar]) >> shift);
    }
    else
    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pTruth < pLimit; pTruth += 2*iStep )
            for ( i = 0; i < iStep; i++ )
                pTruth[i] = pTruth[i + iStep];
    }
}
# 1122 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtCheckEqualCofs( word * pTruth, int nWords, int iVar, int jVar, int Num1, int Num2 )
{
    
# 1124 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1124 "/app/abc/src/misc/util/utilTruth.h"
   Num1 < Num2 && Num2 < 4
# 1124 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1124 "/app/abc/src/misc/util/utilTruth.h"
   Num1 < Num2 && Num2 < 4
# 1124 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1124 "/app/abc/src/misc/util/utilTruth.h"
   "Num1 < Num2 && Num2 < 4"
# 1124 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1124, __extension__ __PRETTY_FUNCTION__); }))
# 1124 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
    
# 1125 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1125 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 1125 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1125 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 1125 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1125 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < jVar"
# 1125 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1125, __extension__ __PRETTY_FUNCTION__); }))
# 1125 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    if ( nWords == 1 )
    {
        word Mask = s_Truths6Neg[jVar] & s_Truths6Neg[iVar];
        int shift1 = (Num1 >> 1) * (1 << jVar) + (Num1 & 1) * (1 << iVar);
        int shift2 = (Num2 >> 1) * (1 << jVar) + (Num2 & 1) * (1 << iVar);
        return ((pTruth[0] >> shift1) & Mask) == ((pTruth[0] >> shift2) & Mask);
    }
    if ( jVar <= 5 )
    {
        word Mask = s_Truths6Neg[jVar] & s_Truths6Neg[iVar];
        int shift1 = (Num1 >> 1) * (1 << jVar) + (Num1 & 1) * (1 << iVar);
        int shift2 = (Num2 >> 1) * (1 << jVar) + (Num2 & 1) * (1 << iVar);
        int w;
        for ( w = 0; w < nWords; w++ )
            if ( ((pTruth[w] >> shift1) & Mask) != ((pTruth[w] >> shift2) & Mask) )
                return 0;
        return 1;
    }
    if ( iVar <= 5 && jVar > 5 )
    {
        word * pLimit = pTruth + nWords;
        int j, jStep = Abc_TtWordNum(jVar);
        int shift1 = (Num1 & 1) * (1 << iVar);
        int shift2 = (Num2 & 1) * (1 << iVar);
        int Offset1 = (Num1 >> 1) * jStep;
        int Offset2 = (Num2 >> 1) * jStep;
        for ( ; pTruth < pLimit; pTruth += 2*jStep )
            for ( j = 0; j < jStep; j++ )
                if ( ((pTruth[j + Offset1] >> shift1) & s_Truths6Neg[iVar]) != ((pTruth[j + Offset2] >> shift2) & s_Truths6Neg[iVar]) )
                    return 0;
        return 1;
    }
    {
        word * pLimit = pTruth + nWords;
        int j, jStep = Abc_TtWordNum(jVar);
        int i, iStep = Abc_TtWordNum(iVar);
        int Offset1 = (Num1 >> 1) * jStep + (Num1 & 1) * iStep;
        int Offset2 = (Num2 >> 1) * jStep + (Num2 & 1) * iStep;
        for ( ; pTruth < pLimit; pTruth += 2*jStep )
            for ( i = 0; i < jStep; i += 2*iStep )
                for ( j = 0; j < iStep; j++ )
                    if ( pTruth[Offset1 + i + j] != pTruth[Offset2 + i + j] )
                        return 0;
        return 1;
    }
}
# 1185 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6Cof0IsConst0( word t, int iVar ) { return (t & s_Truths6Neg[iVar]) == 0; }
static inline int Abc_Tt6Cof0IsConst1( word t, int iVar ) { return (t & s_Truths6Neg[iVar]) == s_Truths6Neg[iVar]; }
static inline int Abc_Tt6Cof1IsConst0( word t, int iVar ) { return (t & s_Truths6[iVar]) == 0; }
static inline int Abc_Tt6Cof1IsConst1( word t, int iVar ) { return (t & s_Truths6[iVar]) == s_Truths6[iVar]; }
static inline int Abc_Tt6CofsOpposite( word t, int iVar ) { return (~t & s_Truths6Neg[iVar]) == ((t >> (1 << iVar)) & s_Truths6Neg[iVar]); }
static inline int Abc_Tt6Cof0EqualCof1( word t1, word t2, int iVar ) { return (t1 & s_Truths6Neg[iVar]) == ((t2 >> (1 << iVar)) & s_Truths6Neg[iVar]); }
static inline int Abc_Tt6Cof0EqualCof0( word t1, word t2, int iVar ) { return (t1 & s_Truths6Neg[iVar]) == (t2 & s_Truths6Neg[iVar]); }
static inline int Abc_Tt6Cof1EqualCof1( word t1, word t2, int iVar ) { return (t1 & s_Truths6[iVar]) == (t2 & s_Truths6[iVar]); }
# 1205 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtTruthIsConst0( word * p, int nWords ) { int w; for ( w = 0; w < nWords; w++ ) if ( p[w] != 0 ) return 0; return 1; }
static inline int Abc_TtTruthIsConst1( word * p, int nWords ) { int w; for ( w = 0; w < nWords; w++ ) if ( p[w] != ~(word)0 ) return 0; return 1; }

static inline int Abc_TtCof0IsConst0( word * t, int nWords, int iVar )
{
    if ( iVar < 6 )
    {
        int i;
        for ( i = 0; i < nWords; i++ )
            if ( t[i] & s_Truths6Neg[iVar] )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + nWords;
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( t[i] )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtCof0IsConst1( word * t, int nWords, int iVar )
{
    if ( iVar < 6 )
    {
        int i;
        for ( i = 0; i < nWords; i++ )
            if ( (t[i] & s_Truths6Neg[iVar]) != s_Truths6Neg[iVar] )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + nWords;
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( ~t[i] )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtCof1IsConst0( word * t, int nWords, int iVar )
{
    if ( iVar < 6 )
    {
        int i;
        for ( i = 0; i < nWords; i++ )
            if ( t[i] & s_Truths6[iVar] )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + nWords;
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( t[i+Step] )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtCof1IsConst1( word * t, int nWords, int iVar )
{
    if ( iVar < 6 )
    {
        int i;
        for ( i = 0; i < nWords; i++ )
            if ( (t[i] & s_Truths6[iVar]) != s_Truths6[iVar] )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + nWords;
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( ~t[i+Step] )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtCofsOpposite( word * t, int nWords, int iVar )
{
    if ( iVar < 6 )
    {
        int i, Shift = (1 << iVar);
        for ( i = 0; i < nWords; i++ )
            if ( ((t[i] << Shift) & s_Truths6[iVar]) != (~t[i] & s_Truths6[iVar]) )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + nWords;
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( t[i] != ~t[i+Step] )
                    return 0;
        return 1;
    }
}
# 1325 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtStretch5( unsigned * pInOut, int nVarS, int nVarB )
{
    int w, i, step, nWords;
    if ( nVarS == nVarB )
        return;
    
# 1330 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1330 "/app/abc/src/misc/util/utilTruth.h"
   nVarS < nVarB
# 1330 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1330 "/app/abc/src/misc/util/utilTruth.h"
   nVarS < nVarB
# 1330 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1330 "/app/abc/src/misc/util/utilTruth.h"
   "nVarS < nVarB"
# 1330 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1330, __extension__ __PRETTY_FUNCTION__); }))
# 1330 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    step = Abc_TruthWordNum(nVarS);
    nWords = Abc_TruthWordNum(nVarB);
    if ( step == nWords )
        return;
    
# 1335 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1335 "/app/abc/src/misc/util/utilTruth.h"
   step < nWords
# 1335 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1335 "/app/abc/src/misc/util/utilTruth.h"
   step < nWords
# 1335 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1335 "/app/abc/src/misc/util/utilTruth.h"
   "step < nWords"
# 1335 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1335, __extension__ __PRETTY_FUNCTION__); }))
# 1335 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    for ( w = 0; w < nWords; w += step )
        for ( i = 0; i < step; i++ )
            pInOut[w + i] = pInOut[i];
}
static inline void Abc_TtStretch6( word * pInOut, int nVarS, int nVarB )
{
    int w, i, step, nWords;
    if ( nVarS == nVarB )
        return;
    
# 1345 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1345 "/app/abc/src/misc/util/utilTruth.h"
   nVarS < nVarB
# 1345 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1345 "/app/abc/src/misc/util/utilTruth.h"
   nVarS < nVarB
# 1345 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1345 "/app/abc/src/misc/util/utilTruth.h"
   "nVarS < nVarB"
# 1345 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1345, __extension__ __PRETTY_FUNCTION__); }))
# 1345 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    step = Abc_Truth6WordNum(nVarS);
    nWords = Abc_Truth6WordNum(nVarB);
    if ( step == nWords )
        return;
    
# 1350 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1350 "/app/abc/src/misc/util/utilTruth.h"
   step < nWords
# 1350 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1350 "/app/abc/src/misc/util/utilTruth.h"
   step < nWords
# 1350 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1350 "/app/abc/src/misc/util/utilTruth.h"
   "step < nWords"
# 1350 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1350, __extension__ __PRETTY_FUNCTION__); }))
# 1350 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    for ( w = 0; w < nWords; w += step )
        for ( i = 0; i < step; i++ )
            pInOut[w + i] = pInOut[i];
}
static inline word Abc_Tt6Stretch( word t, int nVars )
{
    
# 1357 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1357 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 0
# 1357 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1357 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 0
# 1357 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1357 "/app/abc/src/misc/util/utilTruth.h"
   "nVars >= 0"
# 1357 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1357, __extension__ __PRETTY_FUNCTION__); }))
# 1357 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    if ( nVars == 0 )
        nVars++, t = (t & 0x1) | ((t & 0x1) << 1);
    if ( nVars == 1 )
        nVars++, t = (t & 0x3) | ((t & 0x3) << 2);
    if ( nVars == 2 )
        nVars++, t = (t & 0xF) | ((t & 0xF) << 4);
    if ( nVars == 3 )
        nVars++, t = (t & 0xFF) | ((t & 0xFF) << 8);
    if ( nVars == 4 )
        nVars++, t = (t & 0xFFFF) | ((t & 0xFFFF) << 16);
    if ( nVars == 5 )
        nVars++, t = (t & 0xFFFFFFFF) | ((t & 0xFFFFFFFF) << 32);
    
# 1370 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1370 "/app/abc/src/misc/util/utilTruth.h"
   nVars == 6
# 1370 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1370 "/app/abc/src/misc/util/utilTruth.h"
   nVars == 6
# 1370 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1370 "/app/abc/src/misc/util/utilTruth.h"
   "nVars == 6"
# 1370 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1370, __extension__ __PRETTY_FUNCTION__); }))
# 1370 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    return t;
}
# 1385 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtIsHexDigit( char HexChar )
{
    return (HexChar >= '0' && HexChar <= '9') || (HexChar >= 'A' && HexChar <= 'F') || (HexChar >= 'a' && HexChar <= 'f');
}
static inline char Abc_TtPrintDigit( int Digit )
{
    
# 1391 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1391 "/app/abc/src/misc/util/utilTruth.h"
   Digit >= 0 && Digit < 16
# 1391 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1391 "/app/abc/src/misc/util/utilTruth.h"
   Digit >= 0 && Digit < 16
# 1391 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1391 "/app/abc/src/misc/util/utilTruth.h"
   "Digit >= 0 && Digit < 16"
# 1391 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1391, __extension__ __PRETTY_FUNCTION__); }))
# 1391 "/app/abc/src/misc/util/utilTruth.h"
                                     ;
    if ( Digit < 10 )
        return '0' + Digit;
    return 'A' + Digit-10;
}
static inline char Abc_TtPrintDigitLower( int Digit )
{
    
# 1398 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1398 "/app/abc/src/misc/util/utilTruth.h"
   Digit >= 0 && Digit < 16
# 1398 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1398 "/app/abc/src/misc/util/utilTruth.h"
   Digit >= 0 && Digit < 16
# 1398 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1398 "/app/abc/src/misc/util/utilTruth.h"
   "Digit >= 0 && Digit < 16"
# 1398 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1398, __extension__ __PRETTY_FUNCTION__); }))
# 1398 "/app/abc/src/misc/util/utilTruth.h"
                                     ;
    if ( Digit < 10 )
        return '0' + Digit;
    return 'a' + Digit-10;
}
static inline int Abc_TtReadHexDigit( char HexChar )
{
    if ( HexChar >= '0' && HexChar <= '9' )
        return HexChar - '0';
    if ( HexChar >= 'A' && HexChar <= 'F' )
        return HexChar - 'A' + 10;
    if ( HexChar >= 'a' && HexChar <= 'f' )
        return HexChar - 'a' + 10;
    
# 1411 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1411 "/app/abc/src/misc/util/utilTruth.h"
   0
# 1411 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1411 "/app/abc/src/misc/util/utilTruth.h"
   0
# 1411 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1411 "/app/abc/src/misc/util/utilTruth.h"
   "0"
# 1411 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1411, __extension__ __PRETTY_FUNCTION__); }))
# 1411 "/app/abc/src/misc/util/utilTruth.h"
              ;
    return -1;
}
# 1426 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtPrintHex( word * pTruth, int nVars )
{
    word * pThis, * pLimit = pTruth + Abc_TtWordNum(nVars);
    int k;
    if ( nVars < 2 )
        printf( "%c", Abc_TtPrintDigit((int)pTruth[0] & 15) );
    else
    {
        
# 1434 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1434 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1434 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1434 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1434 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1434 "/app/abc/src/misc/util/utilTruth.h"
       "nVars >= 2"
# 1434 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1434, __extension__ __PRETTY_FUNCTION__); }))
# 1434 "/app/abc/src/misc/util/utilTruth.h"
                           ;
        for ( pThis = pTruth; pThis < pLimit; pThis++ )
            for ( k = 0; k < 16; k++ )
                printf( "%c", Abc_TtPrintDigit((int)(pThis[0] >> (k << 2)) & 15) );
    }
    printf( "\n" );
}
static inline void Abc_TtPrintHexRev( FILE * pFile, word * pTruth, int nVars )
{
    word * pThis;
    int k, StartK = nVars >= 6 ? 16 : (1 << (nVars - 2));
    if ( nVars < 2 )
        fprintf( pFile, "%c", Abc_TtPrintDigit((int)pTruth[0] & 15) );
    else
    {
        
# 1449 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1449 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1449 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1449 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1449 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1449 "/app/abc/src/misc/util/utilTruth.h"
       "nVars >= 2"
# 1449 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1449, __extension__ __PRETTY_FUNCTION__); }))
# 1449 "/app/abc/src/misc/util/utilTruth.h"
                           ;
        for ( pThis = pTruth + Abc_TtWordNum(nVars) - 1; pThis >= pTruth; pThis-- )
            for ( k = StartK - 1; k >= 0; k-- )
                fprintf( pFile, "%c", Abc_TtPrintDigit((int)(pThis[0] >> (k << 2)) & 15) );
    }

}
static inline void Abc_TtPrintHexSpecial( word * pTruth, int nVars )
{
    word * pThis;
    int k;
    if ( nVars < 2 )
        printf( "%c", Abc_TtPrintDigit((int)pTruth[0] & 15) );
    else
    {
        
# 1464 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1464 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1464 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1464 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1464 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1464 "/app/abc/src/misc/util/utilTruth.h"
       "nVars >= 2"
# 1464 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1464, __extension__ __PRETTY_FUNCTION__); }))
# 1464 "/app/abc/src/misc/util/utilTruth.h"
                           ;
        for ( pThis = pTruth + Abc_TtWordNum(nVars) - 1; pThis >= pTruth; pThis-- )
            for ( k = 0; k < 16; k++ )
                printf( "%c", Abc_TtPrintDigit((int)(pThis[0] >> (k << 2)) & 15) );
    }
    printf( "\n" );
}
static inline int Abc_TtWriteHexRev( char * pStr, word * pTruth, int nVars )
{
    word * pThis;
    char * pStrInit = pStr;
    int k, StartK = nVars >= 6 ? 16 : (1 << (nVars - 2));
    if ( nVars < 2 )
        *pStr++ = Abc_TtPrintDigit((int)pTruth[0] & 15);
    else
    {
        
# 1480 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1480 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1480 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1480 "/app/abc/src/misc/util/utilTruth.h"
       nVars >= 2
# 1480 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1480 "/app/abc/src/misc/util/utilTruth.h"
       "nVars >= 2"
# 1480 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1480, __extension__ __PRETTY_FUNCTION__); }))
# 1480 "/app/abc/src/misc/util/utilTruth.h"
                           ;
        for ( pThis = pTruth + Abc_TtWordNum(nVars) - 1; pThis >= pTruth; pThis-- )
            for ( k = StartK - 1; k >= 0; k-- )
                *pStr++ = Abc_TtPrintDigit( (int)(pThis[0] >> (k << 2)) & 15 );
    }
    return pStr - pStrInit;
}
static inline void Abc_TtPrintHexArrayRev( FILE * pFile, word * pTruth, int nDigits )
{
    int k;
    for ( k = nDigits - 1; k >= 0; k-- )
        fprintf( pFile, "%c", Abc_TtPrintDigitLower( Abc_TtGetHex(pTruth, k) ) );
}
# 1505 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtReadHex( word * pTruth, char * pString )
{
    int k, nVars, Digit, nDigits;

    if ( pString[0] == '0' && pString[1] == 'x' )
        pString += 2;

    nDigits = 0;
    for ( k = 0; Abc_TtIsHexDigit(pString[k]); k++ )
        nDigits++;
    if ( nDigits == 1 )
    {
        if ( pString[0] == '0' || pString[0] == 'F' )
        {
            pTruth[0] = (pString[0] == '0') ? 0 : ~(word)0;
            return 0;
        }
        if ( pString[0] == '5' || pString[0] == 'A' )
        {
            pTruth[0] = (pString[0] == '5') ? s_Truths6Neg[0] : s_Truths6[0];
            return 1;
        }
    }

    nVars = 2 + (nDigits == 1 ? 0 : Abc_Base2Log(nDigits));

    for ( k = Abc_TtWordNum(nVars) - 1; k >= 0; k-- )
        pTruth[k] = 0;


    for ( k = 0; k < nDigits; k++ )
    {
        Digit = Abc_TtReadHexDigit( pString[nDigits - 1 - k] );
        
# 1538 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1538 "/app/abc/src/misc/util/utilTruth.h"
       Digit >= 0 && Digit < 16
# 1538 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1538 "/app/abc/src/misc/util/utilTruth.h"
       Digit >= 0 && Digit < 16
# 1538 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1538 "/app/abc/src/misc/util/utilTruth.h"
       "Digit >= 0 && Digit < 16"
# 1538 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1538, __extension__ __PRETTY_FUNCTION__); }))
# 1538 "/app/abc/src/misc/util/utilTruth.h"
                                         ;
        Abc_TtSetHex( pTruth, k, Digit );
    }
    if ( nVars < 6 )
        pTruth[0] = Abc_Tt6Stretch( pTruth[0], nVars );
    return nVars;
}
static inline int Abc_TtReadHexNumber( word * pTruth, char * pString )
{

    int k, Digit, nDigits = 0;
    for ( k = 0; Abc_TtIsHexDigit(pString[k]); k++ )
        nDigits++;


    for ( k = 0; k < nDigits; k++ )
    {
        Digit = Abc_TtReadHexDigit( pString[nDigits - 1 - k] );
        
# 1556 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 1556 "/app/abc/src/misc/util/utilTruth.h"
       Digit >= 0 && Digit < 16
# 1556 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 1556 "/app/abc/src/misc/util/utilTruth.h"
       Digit >= 0 && Digit < 16
# 1556 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 1556 "/app/abc/src/misc/util/utilTruth.h"
       "Digit >= 0 && Digit < 16"
# 1556 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 1556, __extension__ __PRETTY_FUNCTION__); }))
# 1556 "/app/abc/src/misc/util/utilTruth.h"
                                         ;
        Abc_TtSetHex( pTruth, k, Digit );
    }
    return nDigits;
}
# 1574 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtPrintBits( word * pTruth, int nBits )
{
    int k;
    for ( k = 0; k < nBits; k++ )
        printf( "%d", Abc_InfoHasBit( (unsigned *)pTruth, k ) );
    printf( "\n" );
}
static inline void Abc_TtPrintBits2( word * pTruth, int nBits )
{
    int k;
    for ( k = nBits-1; k >= 0; k-- )
        printf( "%d", Abc_InfoHasBit( (unsigned *)pTruth, k ) );
    printf( "\n" );
}
static inline void Abc_TtPrintBinary( word * pTruth, int nVars )
{
    word * pThis, * pLimit = pTruth + Abc_TtWordNum(nVars);
    int k, Limit = Abc_MinInt( 64, (1 << nVars) );
    
# 1592 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1592 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1592 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1592 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1592 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1592 "/app/abc/src/misc/util/utilTruth.h"
   "nVars >= 2"
# 1592 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1592, __extension__ __PRETTY_FUNCTION__); }))
# 1592 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    for ( pThis = pTruth; pThis < pLimit; pThis++ )
        for ( k = 0; k < Limit; k++ )
            printf( "%d", Abc_InfoHasBit( (unsigned *)pThis, k ) );
    printf( "\n" );
}
static inline void Abc_TtPrintBinary1( FILE * pFile, word * pTruth, int nVars )
{
    word * pThis, * pLimit = pTruth + Abc_TtWordNum(nVars);
    int k, Limit = Abc_MinInt( 64, (1 << nVars) );
    
# 1602 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1602 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1602 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1602 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1602 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1602 "/app/abc/src/misc/util/utilTruth.h"
   "nVars >= 2"
# 1602 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1602, __extension__ __PRETTY_FUNCTION__); }))
# 1602 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    for ( pThis = pTruth; pThis < pLimit; pThis++ )
        for ( k = 0; k < Limit; k++ )
            fprintf( pFile, "%d", Abc_InfoHasBit( (unsigned *)pThis, k ) );
}
static inline void Abc_TtPrintBinary2( FILE * pFile, word * pTruth, int nVars )
{
    word * pThis;
    int k, Limit = Abc_MinInt( 64, (1 << nVars) );
    
# 1611 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1611 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1611 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1611 "/app/abc/src/misc/util/utilTruth.h"
   nVars >= 2
# 1611 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1611 "/app/abc/src/misc/util/utilTruth.h"
   "nVars >= 2"
# 1611 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1611, __extension__ __PRETTY_FUNCTION__); }))
# 1611 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    for ( pThis = pTruth + Abc_TtWordNum(nVars) - 1; pThis >= pTruth; pThis-- )
        for ( k = Limit-1; k >= 0; k-- )
            fprintf( pFile, "%d", Abc_InfoHasBit( (unsigned *)pThis, k ) );
}
# 1628 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtSuppFindFirst( int Supp )
{
    int i;
    
# 1631 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1631 "/app/abc/src/misc/util/utilTruth.h"
   Supp > 0
# 1631 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1631 "/app/abc/src/misc/util/utilTruth.h"
   Supp > 0
# 1631 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1631 "/app/abc/src/misc/util/utilTruth.h"
   "Supp > 0"
# 1631 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1631, __extension__ __PRETTY_FUNCTION__); }))
# 1631 "/app/abc/src/misc/util/utilTruth.h"
                     ;
    for ( i = 0; i < 32; i++ )
        if ( Supp & (1 << i) )
            return i;
    return -1;
}
static inline int Abc_TtSuppOnlyOne( int Supp )
{
    if ( Supp == 0 )
        return 0;
    return (Supp & (Supp-1)) == 0;
}
static inline int Abc_TtSuppIsMinBase( int Supp )
{
    
# 1645 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1645 "/app/abc/src/misc/util/utilTruth.h"
   Supp > 0
# 1645 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1645 "/app/abc/src/misc/util/utilTruth.h"
   Supp > 0
# 1645 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1645 "/app/abc/src/misc/util/utilTruth.h"
   "Supp > 0"
# 1645 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1645, __extension__ __PRETTY_FUNCTION__); }))
# 1645 "/app/abc/src/misc/util/utilTruth.h"
                     ;
    return (Supp & (Supp+1)) == 0;
}
static inline int Abc_Tt6HasVar( word t, int iVar )
{
    return ((t >> (1<<iVar)) & s_Truths6Neg[iVar]) != (t & s_Truths6Neg[iVar]);
}
static inline int Abc_Tt6XorVar( word t, int iVar )
{
    return ((t >> (1<<iVar)) & s_Truths6Neg[iVar]) == ~(t & s_Truths6Neg[iVar]);
}
static inline int Abc_TtHasVar( word * t, int nVars, int iVar )
{
    
# 1658 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1658 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 1658 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1658 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 1658 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1658 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < nVars"
# 1658 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1658, __extension__ __PRETTY_FUNCTION__); }))
# 1658 "/app/abc/src/misc/util/utilTruth.h"
                         ;
    if ( nVars <= 6 )
        return Abc_Tt6HasVar( t[0], iVar );
    if ( iVar < 6 )
    {
        int i, Shift = (1 << iVar);
        int nWords = Abc_TtWordNum( nVars );
        for ( i = 0; i < nWords; i++ )
            if ( ((t[i] >> Shift) & s_Truths6Neg[iVar]) != (t[i] & s_Truths6Neg[iVar]) )
                return 1;
        return 0;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + Abc_TtWordNum( nVars );
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( t[i] != t[Step+i] )
                    return 1;
        return 0;
    }
}
static inline int Abc_TtSupport( word * t, int nVars )
{
    int v, Supp = 0;
    for ( v = 0; v < nVars; v++ )
        if ( Abc_TtHasVar( t, nVars, v ) )
            Supp |= (1 << v);
    return Supp;
}
static inline int Abc_TtSupportSize( word * t, int nVars )
{
    int v, SuppSize = 0;
    for ( v = 0; v < nVars; v++ )
        if ( Abc_TtHasVar( t, nVars, v ) )
            SuppSize++;
    return SuppSize;
}
static inline int Abc_TtSupportAndSize( word * t, int nVars, int * pSuppSize )
{
    int v, Supp = 0;
    *pSuppSize = 0;
    for ( v = 0; v < nVars; v++ )
        if ( Abc_TtHasVar( t, nVars, v ) )
            Supp |= (1 << v), (*pSuppSize)++;
    return Supp;
}
static inline int Abc_Tt6SupportAndSize( word t, int nVars, int * pSuppSize )
{
    int v, Supp = 0;
    *pSuppSize = 0;
    
# 1710 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1710 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 1710 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1710 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 1710 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1710 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 6"
# 1710 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1710, __extension__ __PRETTY_FUNCTION__); }))
# 1710 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    for ( v = 0; v < nVars; v++ )
        if ( Abc_Tt6HasVar( t, v ) )
            Supp |= (1 << v), (*pSuppSize)++;
    return Supp;
}
static inline int Abc_Tt6Check1( word t, int nVars )
{
    int n, v, u;
    for ( n = 0; n < 2; n++ )
    for ( v = 0; v < nVars; v++ )
    {
        word Cof = n ? Abc_Tt6Cofactor1(t, v) : Abc_Tt6Cofactor0(t, v);
        for ( u = 0; u < nVars; u++ )
            if ( v != u && !Abc_Tt6HasVar(Cof, u) )
                return 1;
    }
    return 0;
}
static inline int Abc_Tt6Check2( word t, int nVars )
{
    int n, v;
    for ( n = 0; n < 2; n++ )
    for ( v = 0; v < nVars; v++ )
    {
        word Cof = n ? Abc_Tt6Cofactor1(t, v) : Abc_Tt6Cofactor0(t, v);
        if ( Cof == 0 || ~Cof == 0 )
            return 1;
    }
    return 0;
}
# 1752 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtCheckCondDep2( word * pTruth, int nVars, int nSuppLim )
{
    int v, d, nWords = Abc_TtWordNum(nVars);
    if ( nVars <= nSuppLim + 1 )
        return 0;
    for ( v = 0; v < nVars; v++ )
    {
        int nDep0 = 0, nDep1 = 0;
        for ( d = 0; d < nVars; d++ )
        {
            if ( v == d )
                continue;
            if ( v < d )
            {
                nDep0 += !Abc_TtCheckEqualCofs( pTruth, nWords, v, d, 0, 2 );
                nDep1 += !Abc_TtCheckEqualCofs( pTruth, nWords, v, d, 1, 3 );
            }
            else
            {
                nDep0 += !Abc_TtCheckEqualCofs( pTruth, nWords, d, v, 0, 1 );
                nDep1 += !Abc_TtCheckEqualCofs( pTruth, nWords, d, v, 2, 3 );
            }
            if ( nDep0 > nSuppLim || nDep1 > nSuppLim )
                break;
        }
        if ( d == nVars )
            return v;
    }
    return nVars;
}
static inline int Abc_TtCheckCondDep( word * pTruth, int nVars, int nSuppLim )
{
    int nVarsMax = 13;
    word Cof0[128], Cof1[128];
    int v, d, nWords = Abc_TtWordNum(nVars);
    
# 1787 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1787 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= nVarsMax
# 1787 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1787 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= nVarsMax
# 1787 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1787 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= nVarsMax"
# 1787 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1787, __extension__ __PRETTY_FUNCTION__); }))
# 1787 "/app/abc/src/misc/util/utilTruth.h"
                              ;
    if ( nVars <= nSuppLim + 1 )
        return 0;
    for ( v = 0; v < nVars; v++ )
    {
        int nDep0 = 0, nDep1 = 0;
        Abc_TtCofactor0p( Cof0, pTruth, nWords, v );
        Abc_TtCofactor1p( Cof1, pTruth, nWords, v );
        for ( d = 0; d < nVars; d++ )
        {
            if ( v == d )
                continue;
            nDep0 += Abc_TtHasVar( Cof0, nVars, d );
            nDep1 += Abc_TtHasVar( Cof1, nVars, d );
            if ( nDep0 > nSuppLim || nDep1 > nSuppLim )
                break;
        }
        if ( d == nVars )
            return v;
    }
    return nVars;
}
# 1822 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtOnlyOneOne( word t )
{
    if ( t == 0 )
        return 0;
    return (t & (t-1)) == 0;
}
static inline int Abc_Tt6IsAndType( word t, int nVars )
{
    return Abc_TtOnlyOneOne( t & Abc_Tt6Mask(1 << nVars) );
}
static inline int Abc_Tt6IsOrType( word t, int nVars )
{
    return Abc_TtOnlyOneOne( ~t & Abc_Tt6Mask(1 << nVars) );
}
static inline int Abc_Tt6IsXorType( word t, int nVars )
{
    return ((((t & 1) ? ~t : t) ^ s_TruthXors[nVars]) & Abc_Tt6Mask(1 << nVars)) == 0;
}
# 1853 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Flip( word Truth, int iVar )
{
    return Truth = ((Truth << (1 << iVar)) & s_Truths6[iVar]) | ((Truth & s_Truths6[iVar]) >> (1 << iVar));
}
static inline void Abc_TtFlip( word * pTruth, int nWords, int iVar )
{
    if ( nWords == 1 )
        pTruth[0] = ((pTruth[0] << (1 << iVar)) & s_Truths6[iVar]) | ((pTruth[0] & s_Truths6[iVar]) >> (1 << iVar));
    else if ( iVar <= 5 )
    {
        int w, shift = (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pTruth[w] = ((pTruth[w] << shift) & s_Truths6[iVar]) | ((pTruth[w] & s_Truths6[iVar]) >> shift);
    }
    else
    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pTruth < pLimit; pTruth += 2*iStep )
            for ( i = 0; i < iStep; i++ )
                { word t = pTruth[i]; pTruth[i] = pTruth[i + iStep]; pTruth[i + iStep] = t; };
    }
}
# 1888 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6SwapAdjacent( word Truth, int iVar )
{
    return (Truth & s_PMasks[iVar][0]) | ((Truth & s_PMasks[iVar][1]) << (1 << iVar)) | ((Truth & s_PMasks[iVar][2]) >> (1 << iVar));
}
static inline void Abc_TtSwapAdjacent( word * pTruth, int nWords, int iVar )
{
    if ( iVar < 5 )
    {
        int i, Shift = (1 << iVar);
        for ( i = 0; i < nWords; i++ )
            pTruth[i] = (pTruth[i] & s_PMasks[iVar][0]) | ((pTruth[i] & s_PMasks[iVar][1]) << Shift) | ((pTruth[i] & s_PMasks[iVar][2]) >> Shift);
    }
    else if ( iVar == 5 )
    {
        unsigned * pTruthU = (unsigned *)pTruth;
        unsigned * pLimitU = (unsigned *)(pTruth + nWords);
        for ( ; pTruthU < pLimitU; pTruthU += 4 )
            { unsigned t = pTruthU[1]; pTruthU[1] = pTruthU[2]; pTruthU[2] = t; };
    }
    else
    {
        word * pLimit = pTruth + nWords;
        int i, iStep = Abc_TtWordNum(iVar);
        for ( ; pTruth < pLimit; pTruth += 4*iStep )
            for ( i = 0; i < iStep; i++ )
                { word t = pTruth[i + iStep]; pTruth[i + iStep] = pTruth[i + 2*iStep]; pTruth[i + 2*iStep] = t; };
    }
}
static inline word Abc_Tt6SwapVars( word t, int iVar, int jVar )
{
    word * s_PMasks = s_PPMasks[iVar][jVar];
    int shift = (1 << jVar) - (1 << iVar);
    
# 1920 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1920 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 1920 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1920 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 1920 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1920 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < jVar"
# 1920 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1920, __extension__ __PRETTY_FUNCTION__); }))
# 1920 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    return (t & s_PMasks[0]) | ((t & s_PMasks[1]) << shift) | ((t & s_PMasks[2]) >> shift);
}
static inline void Abc_TtSwapVars( word * pTruth, int nVars, int iVar, int jVar )
{
    if ( iVar == jVar )
        return;
    if ( jVar < iVar )
        { int t = iVar; iVar = jVar; jVar = t; };
    
# 1929 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1929 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar && jVar < nVars
# 1929 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1929 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar && jVar < nVars
# 1929 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1929 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < jVar && jVar < nVars"
# 1929 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1929, __extension__ __PRETTY_FUNCTION__); }))
# 1929 "/app/abc/src/misc/util/utilTruth.h"
                                        ;
    if ( nVars <= 6 )
    {
        pTruth[0] = Abc_Tt6SwapVars( pTruth[0], iVar, jVar );
        return;
    }
    if ( jVar <= 5 )
    {
        word * s_PMasks = s_PPMasks[iVar][jVar];
        int nWords = Abc_TtWordNum(nVars);
        int w, shift = (1 << jVar) - (1 << iVar);
        for ( w = 0; w < nWords; w++ )
            pTruth[w] = (pTruth[w] & s_PMasks[0]) | ((pTruth[w] & s_PMasks[1]) << shift) | ((pTruth[w] & s_PMasks[2]) >> shift);
        return;
    }
    if ( iVar <= 5 && jVar > 5 )
    {
        word low2High, high2Low;
        word * pLimit = pTruth + Abc_TtWordNum(nVars);
        int j, jStep = Abc_TtWordNum(jVar);
        int shift = 1 << iVar;
        for ( ; pTruth < pLimit; pTruth += 2*jStep )
            for ( j = 0; j < jStep; j++ )
            {
                low2High = (pTruth[j] & s_Truths6[iVar]) >> shift;
                high2Low = (pTruth[j+jStep] << shift) & s_Truths6[iVar];
                pTruth[j] = (pTruth[j] & ~s_Truths6[iVar]) | high2Low;
                pTruth[j+jStep] = (pTruth[j+jStep] & s_Truths6[iVar]) | low2High;
            }
        return;
    }
    {
        word * pLimit = pTruth + Abc_TtWordNum(nVars);
        int i, iStep = Abc_TtWordNum(iVar);
        int j, jStep = Abc_TtWordNum(jVar);
        for ( ; pTruth < pLimit; pTruth += 2*jStep )
            for ( i = 0; i < jStep; i += 2*iStep )
                for ( j = 0; j < iStep; j++ )
                    { word t = pTruth[iStep + i + j]; pTruth[iStep + i + j] = pTruth[jStep + i + j]; pTruth[jStep + i + j] = t; };
        return;
    }
}

static inline void Abc_TtMoveVar( word * pF, int nVars, int * V2P, int * P2V, int v, int p )
{
    int iVar = V2P[v], jVar = p;
    if ( iVar == jVar )
        return;
    Abc_TtSwapVars( pF, nVars, iVar, jVar );
    V2P[P2V[iVar]] = jVar;
    V2P[P2V[jVar]] = iVar;
    P2V[iVar] ^= P2V[jVar];
    P2V[jVar] ^= P2V[iVar];
    P2V[iVar] ^= P2V[jVar];
}
static inline word Abc_Tt6RemoveVar( word t, int iVar )
{
    
# 1986 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 1986 "/app/abc/src/misc/util/utilTruth.h"
   !Abc_Tt6HasVar(t, iVar)
# 1986 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 1986 "/app/abc/src/misc/util/utilTruth.h"
   !Abc_Tt6HasVar(t, iVar)
# 1986 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 1986 "/app/abc/src/misc/util/utilTruth.h"
   "!Abc_Tt6HasVar(t, iVar)"
# 1986 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 1986, __extension__ __PRETTY_FUNCTION__); }))
# 1986 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
    while ( iVar < 5 )
        t = Abc_Tt6SwapAdjacent( t, iVar++ );
    return t;
}
# 2003 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Permute_rec( word t, int * pPerm, int nVars )
{
    word uRes0, uRes1; int Var;
    if ( t == 0 ) return 0;
    if ( ~t == 0 ) return ~(word)0;
    for ( Var = nVars-1; Var >= 0; Var-- )
        if ( Abc_Tt6HasVar( t, Var ) )
             break;
    
# 2011 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2011 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2011 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2011 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2011 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2011 "/app/abc/src/misc/util/utilTruth.h"
   "Var >= 0"
# 2011 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2011, __extension__ __PRETTY_FUNCTION__); }))
# 2011 "/app/abc/src/misc/util/utilTruth.h"
                     ;
    uRes0 = Abc_Tt6Permute_rec( Abc_Tt6Cofactor0(t, Var), pPerm, Var );
    uRes1 = Abc_Tt6Permute_rec( Abc_Tt6Cofactor1(t, Var), pPerm, Var );
    return (uRes0 & s_Truths6Neg[pPerm[Var]]) | (uRes1 & s_Truths6[pPerm[Var]]);
}
static inline void Abc_TtPermute( word * p, int * pPerm, int nVars )
{
    int v, UnPerm[16], Perm[16];
    
# 2019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2019 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 16
# 2019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2019 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 16
# 2019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2019 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 16"
# 2019 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2019, __extension__ __PRETTY_FUNCTION__); }))
# 2019 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    for ( v = 0; v < nVars; v++ )
        UnPerm[v] = Perm[v] = v;
    for ( v = nVars-1; v >= 0; v-- )
    {
        int Lev = UnPerm[pPerm[v]];
        if ( v == Lev )
            continue;
        Abc_TtSwapVars( p, nVars, v, Lev );
        { int t = Perm[v]; Perm[v] = Perm[Lev]; Perm[Lev] = t; };
        UnPerm[Perm[Lev]] = Lev;
        UnPerm[Perm[v]] = v;
    }
    for ( v = 0; v < nVars; v++ )
        
# 2033 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2033 "/app/abc/src/misc/util/utilTruth.h"
       Perm[v] == pPerm[v]
# 2033 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2033 "/app/abc/src/misc/util/utilTruth.h"
       Perm[v] == pPerm[v]
# 2033 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2033 "/app/abc/src/misc/util/utilTruth.h"
       "Perm[v] == pPerm[v]"
# 2033 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2033, __extension__ __PRETTY_FUNCTION__); }))
# 2033 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
}
static inline void Abc_TtUnpermute( word * p, int * pPerm, int nVars )
{
    int v, Perm[16];
    
# 2038 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2038 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 16
# 2038 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2038 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 16
# 2038 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2038 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 16"
# 2038 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2038, __extension__ __PRETTY_FUNCTION__); }))
# 2038 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    for ( v = 0; v < nVars; v++ )
        Perm[v] = pPerm[v];
    for ( v = nVars-1; v >= 0; v-- )
    {
        while ( v != Perm[v] )
        {
            int vCur = Perm[v];
            Abc_TtSwapVars( p, nVars, v, vCur );
            Perm[v] = Perm[vCur];
            Perm[vCur]= vCur;
        }
    }
    for ( v = 0; v < nVars; v++ )
        
# 2052 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2052 "/app/abc/src/misc/util/utilTruth.h"
       Perm[v] == v
# 2052 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2052 "/app/abc/src/misc/util/utilTruth.h"
       Perm[v] == v
# 2052 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2052 "/app/abc/src/misc/util/utilTruth.h"
       "Perm[v] == v"
# 2052 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2052, __extension__ __PRETTY_FUNCTION__); }))
# 2052 "/app/abc/src/misc/util/utilTruth.h"
                             ;
}
# 2066 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtShrink( word * pF, int nVars, int nVarsAll, unsigned Phase )
{
    int i, k, Var = 0;
    
# 2069 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2069 "/app/abc/src/misc/util/utilTruth.h"
   nVarsAll <= 16
# 2069 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2069 "/app/abc/src/misc/util/utilTruth.h"
   nVarsAll <= 16
# 2069 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2069 "/app/abc/src/misc/util/utilTruth.h"
   "nVarsAll <= 16"
# 2069 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2069, __extension__ __PRETTY_FUNCTION__); }))
# 2069 "/app/abc/src/misc/util/utilTruth.h"
                           ;
    for ( i = 0; i < nVarsAll; i++ )
        if ( Phase & (1 << i) )
        {
            for ( k = i-1; k >= Var; k-- )
                Abc_TtSwapAdjacent( pF, Abc_TtWordNum(nVarsAll), k );
            Var++;
        }
    
# 2077 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2077 "/app/abc/src/misc/util/utilTruth.h"
   Var == nVars
# 2077 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2077 "/app/abc/src/misc/util/utilTruth.h"
   Var == nVars
# 2077 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2077 "/app/abc/src/misc/util/utilTruth.h"
   "Var == nVars"
# 2077 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2077, __extension__ __PRETTY_FUNCTION__); }))
# 2077 "/app/abc/src/misc/util/utilTruth.h"
                         ;
}
static inline int Abc_TtMinimumBase( word * t, int * pSupp, int nVarsAll, int * pnVars )
{
    int v, iVar = 0, uSupp = 0;
    
# 2082 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2082 "/app/abc/src/misc/util/utilTruth.h"
   nVarsAll <= 16
# 2082 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2082 "/app/abc/src/misc/util/utilTruth.h"
   nVarsAll <= 16
# 2082 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2082 "/app/abc/src/misc/util/utilTruth.h"
   "nVarsAll <= 16"
# 2082 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2082, __extension__ __PRETTY_FUNCTION__); }))
# 2082 "/app/abc/src/misc/util/utilTruth.h"
                           ;
    for ( v = 0; v < nVarsAll; v++ )
        if ( Abc_TtHasVar( t, nVarsAll, v ) )
        {
            uSupp |= (1 << v);
            if ( pSupp )
                pSupp[iVar] = pSupp[v];
            iVar++;
        }
    if ( pnVars )
        *pnVars = iVar;
    if ( uSupp == 0 || Abc_TtSuppIsMinBase( uSupp ) )
        return 0;
    Abc_TtShrink( t, iVar, nVarsAll, uSupp );
    return 1;
}
static inline int Abc_TtSimplify( word * t, int * pLits, int nVarsAll, int * pnVars )
{
    int v, u;
    for ( v = 0; v < nVarsAll; v++ )
    {
        if ( pLits[v] == 0 )
            Abc_TtCofactor0( t, Abc_TtWordNum(nVarsAll), v );
        else if ( pLits[v] == 1 )
            Abc_TtCofactor1( t, Abc_TtWordNum(nVarsAll), v );
    }
    for ( v = 0; v < nVarsAll; v++ )
    for ( u = v+1; u < nVarsAll; u++ )
        if ( Abc_Lit2Var(pLits[v]) == Abc_Lit2Var(pLits[u]) )
        {
            
# 2112 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ((void) sizeof ((
# 2112 "/app/abc/src/misc/util/utilTruth.h"
           nVarsAll <= 6
# 2112 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 2112 "/app/abc/src/misc/util/utilTruth.h"
           nVarsAll <= 6
# 2112 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ; else __assert_fail (
# 2112 "/app/abc/src/misc/util/utilTruth.h"
           "nVarsAll <= 6"
# 2112 "/app/abc/src/misc/util/utilTruth.h" 3 4
           , "/app/abc/src/misc/util/utilTruth.h", 2112, __extension__ __PRETTY_FUNCTION__); }))
# 2112 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
            if ( pLits[v] == pLits[u] )
            {
                word t0 = Abc_Tt6Cofactor0(Abc_Tt6Cofactor0(*t, v), u);
                word t1 = Abc_Tt6Cofactor1(Abc_Tt6Cofactor1(*t, v), u);
                *t = (t0 & s_Truths6Neg[v]) | (t1 & s_Truths6[v]);
            }
            else
            {
                word t0 = Abc_Tt6Cofactor1(Abc_Tt6Cofactor0(*t, v), u);
                word t1 = Abc_Tt6Cofactor0(Abc_Tt6Cofactor1(*t, v), u);
                *t = (t0 & s_Truths6Neg[v]) | (t1 & s_Truths6[v]);
            }
        }
    return Abc_TtMinimumBase( t, pLits, nVarsAll, pnVars );
}
# 2140 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Expand( word t, int * pCut0, int nCutSize0, int * pCut, int nCutSize )
{
    int i, k;
    for ( i = nCutSize - 1, k = nCutSize0 - 1; i >= 0 && k >= 0; i-- )
    {
        if ( pCut[i] > pCut0[k] )
            continue;
        
# 2147 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2147 "/app/abc/src/misc/util/utilTruth.h"
       pCut[i] == pCut0[k]
# 2147 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2147 "/app/abc/src/misc/util/utilTruth.h"
       pCut[i] == pCut0[k]
# 2147 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2147 "/app/abc/src/misc/util/utilTruth.h"
       "pCut[i] == pCut0[k]"
# 2147 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2147, __extension__ __PRETTY_FUNCTION__); }))
# 2147 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
        if ( k < i )
            t = Abc_Tt6SwapVars( t, k, i );
        k--;
    }
    
# 2152 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2152 "/app/abc/src/misc/util/utilTruth.h"
   k == -1
# 2152 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2152 "/app/abc/src/misc/util/utilTruth.h"
   k == -1
# 2152 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2152 "/app/abc/src/misc/util/utilTruth.h"
   "k == -1"
# 2152 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2152, __extension__ __PRETTY_FUNCTION__); }))
# 2152 "/app/abc/src/misc/util/utilTruth.h"
                    ;
    return t;
}
static inline void Abc_TtExpand( word * pTruth0, int nVars, int * pCut0, int nCutSize0, int * pCut, int nCutSize )
{
    int i, k;
    for ( i = nCutSize - 1, k = nCutSize0 - 1; i >= 0 && k >= 0; i-- )
    {
        if ( pCut[i] > pCut0[k] )
            continue;
        
# 2162 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2162 "/app/abc/src/misc/util/utilTruth.h"
       pCut[i] == pCut0[k]
# 2162 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2162 "/app/abc/src/misc/util/utilTruth.h"
       pCut[i] == pCut0[k]
# 2162 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2162 "/app/abc/src/misc/util/utilTruth.h"
       "pCut[i] == pCut0[k]"
# 2162 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2162, __extension__ __PRETTY_FUNCTION__); }))
# 2162 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
        if ( k < i )
            Abc_TtSwapVars( pTruth0, nVars, k, i );
        k--;
    }
    
# 2167 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2167 "/app/abc/src/misc/util/utilTruth.h"
   k == -1
# 2167 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2167 "/app/abc/src/misc/util/utilTruth.h"
   k == -1
# 2167 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2167 "/app/abc/src/misc/util/utilTruth.h"
   "k == -1"
# 2167 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2167, __extension__ __PRETTY_FUNCTION__); }))
# 2167 "/app/abc/src/misc/util/utilTruth.h"
                    ;
}
static inline int Abc_Tt6MinBase( word * pTruth, int * pVars, int nVars )
{
    word t = *pTruth;
    int i, k;
    for ( i = k = 0; i < nVars; i++ )
    {
        if ( !Abc_Tt6HasVar( t, i ) )
            continue;
        if ( k < i )
        {
            if ( pVars ) pVars[k] = pVars[i];
            t = Abc_Tt6SwapVars( t, k, i );
        }
        k++;
    }
    if ( k == nVars )
        return k;
    
# 2186 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2186 "/app/abc/src/misc/util/utilTruth.h"
   k < nVars
# 2186 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2186 "/app/abc/src/misc/util/utilTruth.h"
   k < nVars
# 2186 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2186 "/app/abc/src/misc/util/utilTruth.h"
   "k < nVars"
# 2186 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2186, __extension__ __PRETTY_FUNCTION__); }))
# 2186 "/app/abc/src/misc/util/utilTruth.h"
                      ;
    *pTruth = t;
    return k;
}
static inline int Abc_TtMinBase( word * pTruth, int * pVars, int nVars, int nVarsAll )
{
    int i, k;
    
# 2193 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2193 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= nVarsAll
# 2193 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2193 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= nVarsAll
# 2193 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2193 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= nVarsAll"
# 2193 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2193, __extension__ __PRETTY_FUNCTION__); }))
# 2193 "/app/abc/src/misc/util/utilTruth.h"
                              ;
    for ( i = k = 0; i < nVars; i++ )
    {
        if ( !Abc_TtHasVar( pTruth, nVarsAll, i ) )
            continue;
        if ( k < i )
        {
            if ( pVars ) pVars[k] = pVars[i];
            Abc_TtSwapVars( pTruth, nVarsAll, k, i );
        }
        k++;
    }
    if ( k == nVars )
        return k;
    
# 2207 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2207 "/app/abc/src/misc/util/utilTruth.h"
   k < nVars
# 2207 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2207 "/app/abc/src/misc/util/utilTruth.h"
   k < nVars
# 2207 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2207 "/app/abc/src/misc/util/utilTruth.h"
   "k < nVars"
# 2207 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2207, __extension__ __PRETTY_FUNCTION__); }))
# 2207 "/app/abc/src/misc/util/utilTruth.h"
                      ;

    return k;
}
# 2223 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtImplementNpnConfig( word * pTruth, int nVars, char * pCanonPerm, unsigned uCanonPhase )
{
    int i, k, nWords = Abc_TtWordNum( nVars );
    if ( (uCanonPhase >> nVars) & 1 )
        Abc_TtNot( pTruth, nWords );
    for ( i = 0; i < nVars; i++ )
        if ( (uCanonPhase >> i) & 1 )
            Abc_TtFlip( pTruth, nWords, i );
    if ( pCanonPerm )
    for ( i = 0; i < nVars; i++ )
    {
        for ( k = i; k < nVars; k++ )
            if ( pCanonPerm[k] == i )
                break;
        
# 2237 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2237 "/app/abc/src/misc/util/utilTruth.h"
       k < nVars
# 2237 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2237 "/app/abc/src/misc/util/utilTruth.h"
       k < nVars
# 2237 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2237 "/app/abc/src/misc/util/utilTruth.h"
       "k < nVars"
# 2237 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2237, __extension__ __PRETTY_FUNCTION__); }))
# 2237 "/app/abc/src/misc/util/utilTruth.h"
                          ;
        if ( i == k )
            continue;
        Abc_TtSwapVars( pTruth, nVars, i, k );
        { int t = pCanonPerm[i]; pCanonPerm[i] = pCanonPerm[k]; pCanonPerm[k] = t; };
    }
}
# 2256 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtCountOnesSlow( word t )
{
    t = (t & 0x5555555555555555) + ((t>> 1) & 0x5555555555555555);
    t = (t & 0x3333333333333333) + ((t>> 2) & 0x3333333333333333);
    t = (t & 0x0F0F0F0F0F0F0F0F) + ((t>> 4) & 0x0F0F0F0F0F0F0F0F);
    t = (t & 0x00FF00FF00FF00FF) + ((t>> 8) & 0x00FF00FF00FF00FF);
    t = (t & 0x0000FFFF0000FFFF) + ((t>>16) & 0x0000FFFF0000FFFF);
    return (t & 0x00000000FFFFFFFF) + (t>>32);
}
static inline int Abc_TtCountOnes( word x )
{
    x = x - ((x >> 1) & 0x5555555555555555);
    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0F;
    x = x + (x >> 8);
    x = x + (x >> 16);
    x = x + (x >> 32);
    return (int)(x & 0xFF);
}
static inline int Abc_TtCountOnes2( word x )
{
    return x ? Abc_TtCountOnes(x) : 0;
}
static inline int Abc_TtCountOnesVec( word * x, int nWords )
{
    int w, Count = 0;
    for ( w = 0; w < nWords; w++ )
        Count += Abc_TtCountOnes2( x[w] );
    return Count;
}
static inline int Abc_TtCountOnesVecMask( word * x, word * pMask, int nWords, int fCompl )
{
    int w, Count = 0;
    if ( fCompl )
    {
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & ~x[w] );
    }
    else
    {
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & x[w] );
    }
    return Count;
}
static inline int Abc_TtCountOnesVecMask2( word * x0, word * x1, int fComp0, int fComp1, word * pMask, int nWords )
{
    int w, Count = 0;
    if ( !fComp0 && !fComp1 )
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & x0[w] & x1[w] );
    else if ( fComp0 && !fComp1 )
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & ~x0[w] & x1[w] );
    else if ( !fComp0 && fComp1 )
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & x0[w] & ~x1[w] );
    else
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & ~x0[w] & ~x1[w] );
    return Count;
}
static inline int Abc_TtCountOnesVecXor( word * x, word * y, int nWords )
{
    int w, Count = 0;
    for ( w = 0; w < nWords; w++ )
        Count += Abc_TtCountOnes2( x[w] ^ y[w] );
    return Count;
}
static inline int Abc_TtCountOnesVecXorMask( word * x, word * y, int fCompl, word * pMask, int nWords )
{
    int w, Count = 0;
    if ( fCompl )
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & (x[w] ^ ~y[w]) );
    else
        for ( w = 0; w < nWords; w++ )
            Count += Abc_TtCountOnes2( pMask[w] & (x[w] ^ y[w]) );
    return Count;
}
static inline int Abc_TtAndXorSum( word * pOut, word * pIn1, word * pIn2, int nWords )
{
    int w, Count = 0;
    for ( w = 0; w < nWords; w++ )
    {
        pOut[w] &= pIn1[w] ^ pIn2[w];
        Count += Abc_TtCountOnes2( pOut[w] );
    }
    return Count;
}
static inline void Abc_TtIsfPrint( word * pOff, word * pOn, int nWords )
{
    int nTotal = 64*nWords;
    int nOffset = Abc_TtCountOnesVec(pOff, nWords);
    int nOnset = Abc_TtCountOnesVec(pOn, nWords);
    int nDcset = nTotal - nOffset - nOnset;
    printf( "OFF =%6d (%6.2f %%)  ", nOffset, 100.0*nOffset/nTotal );
    printf( "ON =%6d (%6.2f %%)  ", nOnset, 100.0*nOnset/nTotal );
    printf( "DC =%6d (%6.2f %%)", nDcset, 100.0*nDcset/nTotal );
}
# 2368 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6FirstBit( word t )
{
    int n = 0;
    if ( t == 0 ) return -1;
    if ( (t & 0x00000000FFFFFFFF) == 0 ) { n += 32; t >>= 32; }
    if ( (t & 0x000000000000FFFF) == 0 ) { n += 16; t >>= 16; }
    if ( (t & 0x00000000000000FF) == 0 ) { n += 8; t >>= 8; }
    if ( (t & 0x000000000000000F) == 0 ) { n += 4; t >>= 4; }
    if ( (t & 0x0000000000000003) == 0 ) { n += 2; t >>= 2; }
    if ( (t & 0x0000000000000001) == 0 ) { n++; }
    return n;
}
static inline int Abc_Tt6LastBit( word t )
{
    int n = 0;
    if ( t == 0 ) return -1;
    if ( (t & 0xFFFFFFFF00000000) == 0 ) { n += 32; t <<= 32; }
    if ( (t & 0xFFFF000000000000) == 0 ) { n += 16; t <<= 16; }
    if ( (t & 0xFF00000000000000) == 0 ) { n += 8; t <<= 8; }
    if ( (t & 0xF000000000000000) == 0 ) { n += 4; t <<= 4; }
    if ( (t & 0xC000000000000000) == 0 ) { n += 2; t <<= 2; }
    if ( (t & 0x8000000000000000) == 0 ) { n++; }
    return 63-n;
}
static inline int Abc_TtFindFirstBit( word * pIn, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = 0; w < nWords; w++ )
        if ( pIn[w] )
            return 64*w + Abc_Tt6FirstBit(pIn[w]);
    return -1;
}
static inline int Abc_TtFindFirstBit2( word * pIn, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn[w] )
            return 64*w + Abc_Tt6FirstBit(pIn[w]);
    return -1;
}
static inline int Abc_TtFindLastBit( word * pIn, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn[w] )
            return 64*w + Abc_Tt6LastBit(pIn[w]);
    return -1;
}
static inline int Abc_TtFindLastBit2( word * pIn, int nWords )
{
    int w;
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn[w] )
            return 64*w + Abc_Tt6LastBit(pIn[w]);
    return -1;
}
static inline int Abc_TtFindFirstDiffBit( word * pIn1, word * pIn2, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] ^ pIn2[w] )
            return 64*w + Abc_Tt6FirstBit(pIn1[w] ^ pIn2[w]);
    return -1;
}
static inline int Abc_TtFindFirstDiffBit2( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] ^ pIn2[w] )
            return 64*w + Abc_Tt6FirstBit(pIn1[w] ^ pIn2[w]);
    return -1;
}
static inline int Abc_TtFindLastDiffBit( word * pIn1, word * pIn2, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn1[w] ^ pIn2[w] )
            return 64*w + Abc_Tt6LastBit(pIn1[w] ^ pIn2[w]);
    return -1;
}
static inline int Abc_TtFindLastDiffBit2( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn1[w] ^ pIn2[w] )
            return 64*w + Abc_Tt6LastBit(pIn1[w] ^ pIn2[w]);
    return -1;
}
static inline int Abc_TtFindFirstAndBit2( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = 0; w < nWords; w++ )
        if ( pIn1[w] & pIn2[w] )
            return 64*w + Abc_Tt6FirstBit(pIn1[w] & pIn2[w]);
    return -1;
}
static inline int Abc_TtFindLastAndBit2( word * pIn1, word * pIn2, int nWords )
{
    int w;
    for ( w = nWords - 1; w >= 0; w-- )
        if ( pIn1[w] & pIn2[w] )
            return 64*w + Abc_Tt6LastBit(pIn1[w] & pIn2[w]);
    return -1;
}
static inline int Abc_TtFindFirstZero( word * pIn, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = 0; w < nWords; w++ )
        if ( ~pIn[w] )
            return 64*w + Abc_Tt6FirstBit(~pIn[w]);
    return -1;
}
static inline int Abc_TtFindLastZero( word * pIn, int nVars )
{
    int w, nWords = Abc_TtWordNum(nVars);
    for ( w = nWords - 1; w >= 0; w-- )
        if ( ~pIn[w] )
            return 64*w + Abc_Tt6LastBit(~pIn[w]);
    return -1;
}
# 2501 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtReverseVars( word * pTruth, int nVars )
{
    int k;
    for ( k = 0; k < nVars/2 ; k++ )
        Abc_TtSwapVars( pTruth, nVars, k, nVars - 1 - k );
}
static inline void Abc_TtReverseBits( word * pTruth, int nVars )
{
    static unsigned char pMirror[256] = {
          0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240,
          8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
          4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
         12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
          2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242,
         10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
          6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
         14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
          1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241,
          9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
          5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
         13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
          3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243,
         11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
          7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
         15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
    };
    unsigned char Temp, * pTruthC = (unsigned char *)pTruth;
    int i, nBytes = (nVars > 6) ? (1 << (nVars - 3)) : 8;
    for ( i = 0; i < nBytes/2; i++ )
    {
        Temp = pMirror[pTruthC[i]];
        pTruthC[i] = pMirror[pTruthC[nBytes-1-i]];
        pTruthC[nBytes-1-i] = Temp;
    }
}
# 2549 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6PosVar( word t, int iVar )
{
    return ((t >> (1<<iVar)) & t & s_Truths6Neg[iVar]) == (t & s_Truths6Neg[iVar]);
}
static inline int Abc_Tt6NegVar( word t, int iVar )
{
    return ((t << (1<<iVar)) & t & s_Truths6[iVar]) == (t & s_Truths6[iVar]);
}
static inline int Abc_TtPosVar( word * t, int nVars, int iVar )
{
    
# 2559 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2559 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 2559 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2559 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 2559 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2559 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < nVars"
# 2559 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2559, __extension__ __PRETTY_FUNCTION__); }))
# 2559 "/app/abc/src/misc/util/utilTruth.h"
                         ;
    if ( nVars <= 6 )
        return Abc_Tt6PosVar( t[0], iVar );
    if ( iVar < 6 )
    {
        int i, Shift = (1 << iVar);
        int nWords = Abc_TtWordNum( nVars );
        for ( i = 0; i < nWords; i++ )
            if ( ((t[i] >> Shift) & t[i] & s_Truths6Neg[iVar]) != (t[i] & s_Truths6Neg[iVar]) )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + Abc_TtWordNum( nVars );
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( t[i] != (t[i] & t[Step+i]) )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtNegVar( word * t, int nVars, int iVar )
{
    
# 2584 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2584 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 2584 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2584 "/app/abc/src/misc/util/utilTruth.h"
   iVar < nVars
# 2584 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2584 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < nVars"
# 2584 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2584, __extension__ __PRETTY_FUNCTION__); }))
# 2584 "/app/abc/src/misc/util/utilTruth.h"
                         ;
    if ( nVars <= 6 )
        return Abc_Tt6NegVar( t[0], iVar );
    if ( iVar < 6 )
    {
        int i, Shift = (1 << iVar);
        int nWords = Abc_TtWordNum( nVars );
        for ( i = 0; i < nWords; i++ )
            if ( ((t[i] << Shift) & t[i] & s_Truths6[iVar]) != (t[i] & s_Truths6[iVar]) )
                return 0;
        return 1;
    }
    else
    {
        int i, Step = (1 << (iVar - 6));
        word * tLimit = t + Abc_TtWordNum( nVars );
        for ( ; t < tLimit; t += 2*Step )
            for ( i = 0; i < Step; i++ )
                if ( (t[i] & t[Step+i]) != t[Step+i] )
                    return 0;
        return 1;
    }
}
static inline int Abc_TtIsUnate( word * t, int nVars )
{
    int i;
    for ( i = 0; i < nVars; i++ )
        if ( !Abc_TtNegVar(t, nVars, i) && !Abc_TtPosVar(t, nVars, i) )
            return 0;
    return 1;
}
static inline int Abc_TtIsPosUnate( word * t, int nVars )
{
    int i;
    for ( i = 0; i < nVars; i++ )
        if ( !Abc_TtPosVar(t, nVars, i) )
            return 0;
    return 1;
}
static inline void Abc_TtMakePosUnate( word * t, int nVars )
{
    int i, nWords = Abc_TtWordNum(nVars);
    for ( i = 0; i < nVars; i++ )
        if ( Abc_TtNegVar(t, nVars, i) )
            Abc_TtFlip( t, nWords, i );
        else 
# 2629 "/app/abc/src/misc/util/utilTruth.h" 3 4
            ((void) sizeof ((
# 2629 "/app/abc/src/misc/util/utilTruth.h"
            Abc_TtPosVar(t, nVars, i)
# 2629 "/app/abc/src/misc/util/utilTruth.h" 3 4
            ) ? 1 : 0), __extension__ ({ if (
# 2629 "/app/abc/src/misc/util/utilTruth.h"
            Abc_TtPosVar(t, nVars, i)
# 2629 "/app/abc/src/misc/util/utilTruth.h" 3 4
            ) ; else __assert_fail (
# 2629 "/app/abc/src/misc/util/utilTruth.h"
            "Abc_TtPosVar(t, nVars, i)"
# 2629 "/app/abc/src/misc/util/utilTruth.h" 3 4
            , "/app/abc/src/misc/util/utilTruth.h", 2629, __extension__ __PRETTY_FUNCTION__); }))
# 2629 "/app/abc/src/misc/util/utilTruth.h"
                                               ;
}
# 2644 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6Isop( word uOn, word uOnDc, int nVars, int * pnCubes )
{
    word uOn0, uOn1, uOnDc0, uOnDc1, uRes0, uRes1, uRes2;
    int Var;
    
# 2648 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2648 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2648 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2648 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2648 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2648 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 6"
# 2648 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2648, __extension__ __PRETTY_FUNCTION__); }))
# 2648 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    
# 2649 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2649 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uOnDc) == 0
# 2649 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2649 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uOnDc) == 0
# 2649 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2649 "/app/abc/src/misc/util/utilTruth.h"
   "(uOn & ~uOnDc) == 0"
# 2649 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2649, __extension__ __PRETTY_FUNCTION__); }))
# 2649 "/app/abc/src/misc/util/utilTruth.h"
                                ;
    if ( uOn == 0 )
        return 0;
    if ( uOnDc == ~(word)0 )
    {
        (*pnCubes)++;
        return ~(word)0;
    }
    
# 2657 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2657 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2657 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2657 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2657 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2657 "/app/abc/src/misc/util/utilTruth.h"
   "nVars > 0"
# 2657 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2657, __extension__ __PRETTY_FUNCTION__); }))
# 2657 "/app/abc/src/misc/util/utilTruth.h"
                      ;

    for ( Var = nVars-1; Var >= 0; Var-- )
        if ( Abc_Tt6HasVar( uOn, Var ) || Abc_Tt6HasVar( uOnDc, Var ) )
             break;
    
# 2662 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2662 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2662 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2662 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2662 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2662 "/app/abc/src/misc/util/utilTruth.h"
   "Var >= 0"
# 2662 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2662, __extension__ __PRETTY_FUNCTION__); }))
# 2662 "/app/abc/src/misc/util/utilTruth.h"
                     ;

    uOn0 = Abc_Tt6Cofactor0( uOn, Var );
    uOn1 = Abc_Tt6Cofactor1( uOn , Var );
    uOnDc0 = Abc_Tt6Cofactor0( uOnDc, Var );
    uOnDc1 = Abc_Tt6Cofactor1( uOnDc, Var );

    uRes0 = Abc_Tt6Isop( uOn0 & ~uOnDc1, uOnDc0, Var, pnCubes );
    uRes1 = Abc_Tt6Isop( uOn1 & ~uOnDc0, uOnDc1, Var, pnCubes );
    uRes2 = Abc_Tt6Isop( (uOn0 & ~uRes0) | (uOn1 & ~uRes1), uOnDc0 & uOnDc1, Var, pnCubes );

    uRes2 |= (uRes0 & s_Truths6Neg[Var]) | (uRes1 & s_Truths6[Var]);
    
# 2674 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2674 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uRes2) == 0
# 2674 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2674 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uRes2) == 0
# 2674 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2674 "/app/abc/src/misc/util/utilTruth.h"
   "(uOn & ~uRes2) == 0"
# 2674 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2674, __extension__ __PRETTY_FUNCTION__); }))
# 2674 "/app/abc/src/misc/util/utilTruth.h"
                                ;
    
# 2675 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2675 "/app/abc/src/misc/util/utilTruth.h"
   (uRes2 & ~uOnDc) == 0
# 2675 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2675 "/app/abc/src/misc/util/utilTruth.h"
   (uRes2 & ~uOnDc) == 0
# 2675 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2675 "/app/abc/src/misc/util/utilTruth.h"
   "(uRes2 & ~uOnDc) == 0"
# 2675 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2675, __extension__ __PRETTY_FUNCTION__); }))
# 2675 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return uRes2;
}
static inline int Abc_Tt7Isop( word uOn[2], word uOnDc[2], int nVars, word uRes[2] )
{
    int nCubes = 0;
    if ( nVars <= 6 || (uOn[0] == uOn[1] && uOnDc[0] == uOnDc[1]) )
        uRes[0] = uRes[1] = Abc_Tt6Isop( uOn[0], uOnDc[0], Abc_MinInt(nVars, 6), &nCubes );
    else
    {
        word uRes0, uRes1, uRes2;
        
# 2686 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2686 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 7
# 2686 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2686 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 7
# 2686 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2686 "/app/abc/src/misc/util/utilTruth.h"
       "nVars == 7"
# 2686 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2686, __extension__ __PRETTY_FUNCTION__); }))
# 2686 "/app/abc/src/misc/util/utilTruth.h"
                           ;

        uRes0 = Abc_Tt6Isop( uOn[0] & ~uOnDc[1], uOnDc[0], 6, &nCubes );
        uRes1 = Abc_Tt6Isop( uOn[1] & ~uOnDc[0], uOnDc[1], 6, &nCubes );
        uRes2 = Abc_Tt6Isop( (uOn[0] & ~uRes0) | (uOn[1] & ~uRes1), uOnDc[0] & uOnDc[1], 6, &nCubes );

        uRes[0] = uRes2 | uRes0;
        uRes[1] = uRes2 | uRes1;
        
# 2694 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2694 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0
# 2694 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2694 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0
# 2694 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2694 "/app/abc/src/misc/util/utilTruth.h"
       "(uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0"
# 2694 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2694, __extension__ __PRETTY_FUNCTION__); }))
# 2694 "/app/abc/src/misc/util/utilTruth.h"
                                                                     ;
        
# 2695 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2695 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0
# 2695 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2695 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0
# 2695 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2695 "/app/abc/src/misc/util/utilTruth.h"
       "(uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0"
# 2695 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2695, __extension__ __PRETTY_FUNCTION__); }))
# 2695 "/app/abc/src/misc/util/utilTruth.h"
                                                                     ;
    }
    return nCubes;
}
static inline int Abc_Tt8Isop( word uOn[4], word uOnDc[4], int nVars, word uRes[4] )
{
    int nCubes = 0;
    if ( nVars <= 6 )
        uRes[0] = uRes[1] = uRes[2] = uRes[3] = Abc_Tt6Isop( uOn[0], uOnDc[0], nVars, &nCubes );
    else if ( nVars == 7 || (uOn[0] == uOn[2] && uOn[1] == uOn[3] && uOnDc[0] == uOnDc[2] && uOnDc[1] == uOnDc[3]) )
    {
        nCubes = Abc_Tt7Isop( uOn, uOnDc, 7, uRes );
        uRes[2] = uRes[0];
        uRes[3] = uRes[1];
    }
    else
    {
        word uOn0[2], uOn1[2], uOn2[2], uOnDc2[2], uRes0[2], uRes1[2], uRes2[2];
        
# 2713 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2713 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 8
# 2713 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2713 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 8
# 2713 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2713 "/app/abc/src/misc/util/utilTruth.h"
       "nVars == 8"
# 2713 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2713, __extension__ __PRETTY_FUNCTION__); }))
# 2713 "/app/abc/src/misc/util/utilTruth.h"
                           ;

        uOn0[0] = uOn[0] & ~uOnDc[2];
        uOn0[1] = uOn[1] & ~uOnDc[3];
        uOn1[0] = uOn[2] & ~uOnDc[0];
        uOn1[1] = uOn[3] & ~uOnDc[1];
        uOnDc2[0] = uOnDc[0] & uOnDc[2];
        uOnDc2[1] = uOnDc[1] & uOnDc[3];

        nCubes += Abc_Tt7Isop( uOn0, uOnDc+0, 7, uRes0 );
        nCubes += Abc_Tt7Isop( uOn1, uOnDc+2, 7, uRes1 );
        uOn2[0] = (uOn[0] & ~uRes0[0]) | (uOn[2] & ~uRes1[0]);
        uOn2[1] = (uOn[1] & ~uRes0[1]) | (uOn[3] & ~uRes1[1]);
        nCubes += Abc_Tt7Isop( uOn2, uOnDc2, 7, uRes2 );

        uRes[0] = uRes2[0] | uRes0[0];
        uRes[1] = uRes2[1] | uRes0[1];
        uRes[2] = uRes2[0] | uRes1[0];
        uRes[3] = uRes2[1] | uRes1[1];
        
# 2732 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2732 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0
# 2732 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2732 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0
# 2732 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2732 "/app/abc/src/misc/util/utilTruth.h"
       "(uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0"
# 2732 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2732, __extension__ __PRETTY_FUNCTION__); }))
# 2732 "/app/abc/src/misc/util/utilTruth.h"
                                                                                                                             ;
        
# 2733 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2733 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0
# 2733 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2733 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0
# 2733 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2733 "/app/abc/src/misc/util/utilTruth.h"
       "(uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0"
# 2733 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2733, __extension__ __PRETTY_FUNCTION__); }))
# 2733 "/app/abc/src/misc/util/utilTruth.h"
                                                                                                                             ;
    }
    return nCubes;
}
# 2749 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6CnfSize( word t, int nVars )
{
    int nCubes = 0;
    Abc_Tt6Isop( t, t, nVars, &nCubes );
    Abc_Tt6Isop( ~t, ~t, nVars, &nCubes );
    
# 2754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2754 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 64
# 2754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2754 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 64
# 2754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2754 "/app/abc/src/misc/util/utilTruth.h"
   "nCubes <= 64"
# 2754 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2754, __extension__ __PRETTY_FUNCTION__); }))
# 2754 "/app/abc/src/misc/util/utilTruth.h"
                         ;
    return nCubes;
}
static inline int Abc_Tt8CnfSize( word t[4], int nVars )
{
    word uRes[4], tc[4] = {~t[0], ~t[1], ~t[2], ~t[3]};
    int nCubes = 0;
    nCubes += Abc_Tt8Isop( t, t, nVars, uRes );
    nCubes += Abc_Tt8Isop( tc, tc, nVars, uRes );
    
# 2763 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2763 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 256
# 2763 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2763 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 256
# 2763 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2763 "/app/abc/src/misc/util/utilTruth.h"
   "nCubes <= 256"
# 2763 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2763, __extension__ __PRETTY_FUNCTION__); }))
# 2763 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    return nCubes;
}
# 2778 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_Tt6IsopCover( word uOn, word uOnDc, int nVars, int * pCover, int * pnCubes )
{
    word uOn0, uOn1, uOnDc0, uOnDc1, uRes0, uRes1, uRes2;
    int c, Var, nBeg0, nEnd0, nEnd1;
    
# 2782 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2782 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2782 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2782 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2782 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2782 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 6"
# 2782 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2782, __extension__ __PRETTY_FUNCTION__); }))
# 2782 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    
# 2783 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2783 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uOnDc) == 0
# 2783 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2783 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uOnDc) == 0
# 2783 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2783 "/app/abc/src/misc/util/utilTruth.h"
   "(uOn & ~uOnDc) == 0"
# 2783 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2783, __extension__ __PRETTY_FUNCTION__); }))
# 2783 "/app/abc/src/misc/util/utilTruth.h"
                                ;
    if ( uOn == 0 )
        return 0;
    if ( uOnDc == ~(word)0 )
    {
        pCover[(*pnCubes)++] = 0;
        return ~(word)0;
    }
    
# 2791 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2791 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2791 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2791 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2791 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2791 "/app/abc/src/misc/util/utilTruth.h"
   "nVars > 0"
# 2791 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2791, __extension__ __PRETTY_FUNCTION__); }))
# 2791 "/app/abc/src/misc/util/utilTruth.h"
                      ;

    for ( Var = nVars-1; Var >= 0; Var-- )
        if ( Abc_Tt6HasVar( uOn, Var ) || Abc_Tt6HasVar( uOnDc, Var ) )
             break;
    
# 2796 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2796 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2796 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2796 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2796 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2796 "/app/abc/src/misc/util/utilTruth.h"
   "Var >= 0"
# 2796 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2796, __extension__ __PRETTY_FUNCTION__); }))
# 2796 "/app/abc/src/misc/util/utilTruth.h"
                     ;

    uOn0 = Abc_Tt6Cofactor0( uOn, Var );
    uOn1 = Abc_Tt6Cofactor1( uOn , Var );
    uOnDc0 = Abc_Tt6Cofactor0( uOnDc, Var );
    uOnDc1 = Abc_Tt6Cofactor1( uOnDc, Var );

    nBeg0 = *pnCubes;
    uRes0 = Abc_Tt6IsopCover( uOn0 & ~uOnDc1, uOnDc0, Var, pCover, pnCubes );
    nEnd0 = *pnCubes;
    uRes1 = Abc_Tt6IsopCover( uOn1 & ~uOnDc0, uOnDc1, Var, pCover, pnCubes );
    nEnd1 = *pnCubes;
    uRes2 = Abc_Tt6IsopCover( (uOn0 & ~uRes0) | (uOn1 & ~uRes1), uOnDc0 & uOnDc1, Var, pCover, pnCubes );

    uRes2 |= (uRes0 & s_Truths6Neg[Var]) | (uRes1 & s_Truths6[Var]);
    for ( c = nBeg0; c < nEnd0; c++ )
        pCover[c] |= (1 << (2*Var+0));
    for ( c = nEnd0; c < nEnd1; c++ )
        pCover[c] |= (1 << (2*Var+1));
    
# 2815 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2815 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uRes2) == 0
# 2815 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2815 "/app/abc/src/misc/util/utilTruth.h"
   (uOn & ~uRes2) == 0
# 2815 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2815 "/app/abc/src/misc/util/utilTruth.h"
   "(uOn & ~uRes2) == 0"
# 2815 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2815, __extension__ __PRETTY_FUNCTION__); }))
# 2815 "/app/abc/src/misc/util/utilTruth.h"
                                ;
    
# 2816 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2816 "/app/abc/src/misc/util/utilTruth.h"
   (uRes2 & ~uOnDc) == 0
# 2816 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2816 "/app/abc/src/misc/util/utilTruth.h"
   (uRes2 & ~uOnDc) == 0
# 2816 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2816 "/app/abc/src/misc/util/utilTruth.h"
   "(uRes2 & ~uOnDc) == 0"
# 2816 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2816, __extension__ __PRETTY_FUNCTION__); }))
# 2816 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
    return uRes2;
}
static inline void Abc_Tt7IsopCover( word uOn[2], word uOnDc[2], int nVars, word uRes[2], int * pCover, int * pnCubes )
{
    if ( nVars <= 6 || (uOn[0] == uOn[1] && uOnDc[0] == uOnDc[1]) )
        uRes[0] = uRes[1] = Abc_Tt6IsopCover( uOn[0], uOnDc[0], Abc_MinInt(nVars, 6), pCover, pnCubes );
    else
    {
        word uRes0, uRes1, uRes2;
        int c, nBeg0, nEnd0, nEnd1;
        
# 2827 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2827 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 7
# 2827 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2827 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 7
# 2827 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2827 "/app/abc/src/misc/util/utilTruth.h"
       "nVars == 7"
# 2827 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2827, __extension__ __PRETTY_FUNCTION__); }))
# 2827 "/app/abc/src/misc/util/utilTruth.h"
                           ;

        nBeg0 = *pnCubes;
        uRes0 = Abc_Tt6IsopCover( uOn[0] & ~uOnDc[1], uOnDc[0], 6, pCover, pnCubes );
        nEnd0 = *pnCubes;
        uRes1 = Abc_Tt6IsopCover( uOn[1] & ~uOnDc[0], uOnDc[1], 6, pCover, pnCubes );
        nEnd1 = *pnCubes;
        uRes2 = Abc_Tt6IsopCover( (uOn[0] & ~uRes0) | (uOn[1] & ~uRes1), uOnDc[0] & uOnDc[1], 6, pCover, pnCubes );

        uRes[0] = uRes2 | uRes0;
        uRes[1] = uRes2 | uRes1;
        for ( c = nBeg0; c < nEnd0; c++ )
            pCover[c] |= (1 << (2*6+0));
        for ( c = nEnd0; c < nEnd1; c++ )
            pCover[c] |= (1 << (2*6+1));
        
# 2842 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2842 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0
# 2842 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2842 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0
# 2842 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2842 "/app/abc/src/misc/util/utilTruth.h"
       "(uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0"
# 2842 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2842, __extension__ __PRETTY_FUNCTION__); }))
# 2842 "/app/abc/src/misc/util/utilTruth.h"
                                                                     ;
        
# 2843 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2843 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0
# 2843 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2843 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0
# 2843 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2843 "/app/abc/src/misc/util/utilTruth.h"
       "(uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0"
# 2843 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2843, __extension__ __PRETTY_FUNCTION__); }))
# 2843 "/app/abc/src/misc/util/utilTruth.h"
                                                                     ;
    }
}
static inline void Abc_Tt8IsopCover( word uOn[4], word uOnDc[4], int nVars, word uRes[4], int * pCover, int * pnCubes )
{
    if ( nVars <= 6 )
        uRes[0] = uRes[1] = uRes[2] = uRes[3] = Abc_Tt6IsopCover( uOn[0], uOnDc[0], nVars, pCover, pnCubes );
    else if ( nVars == 7 || (uOn[0] == uOn[2] && uOn[1] == uOn[3] && uOnDc[0] == uOnDc[2] && uOnDc[1] == uOnDc[3]) )
    {
        Abc_Tt7IsopCover( uOn, uOnDc, 7, uRes, pCover, pnCubes );
        uRes[2] = uRes[0];
        uRes[3] = uRes[1];
    }
    else
    {
        word uOn0[2], uOn1[2], uOn2[2], uOnDc2[2], uRes0[2], uRes1[2], uRes2[2];
        int c, nBeg0, nEnd0, nEnd1;
        
# 2860 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2860 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 8
# 2860 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2860 "/app/abc/src/misc/util/utilTruth.h"
       nVars == 8
# 2860 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2860 "/app/abc/src/misc/util/utilTruth.h"
       "nVars == 8"
# 2860 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2860, __extension__ __PRETTY_FUNCTION__); }))
# 2860 "/app/abc/src/misc/util/utilTruth.h"
                           ;

        uOn0[0] = uOn[0] & ~uOnDc[2];
        uOn0[1] = uOn[1] & ~uOnDc[3];
        uOn1[0] = uOn[2] & ~uOnDc[0];
        uOn1[1] = uOn[3] & ~uOnDc[1];
        uOnDc2[0] = uOnDc[0] & uOnDc[2];
        uOnDc2[1] = uOnDc[1] & uOnDc[3];

        nBeg0 = *pnCubes;
        Abc_Tt7IsopCover( uOn0, uOnDc+0, 7, uRes0, pCover, pnCubes );
        nEnd0 = *pnCubes;
        Abc_Tt7IsopCover( uOn1, uOnDc+2, 7, uRes1, pCover, pnCubes );
        nEnd1 = *pnCubes;
        uOn2[0] = (uOn[0] & ~uRes0[0]) | (uOn[2] & ~uRes1[0]);
        uOn2[1] = (uOn[1] & ~uRes0[1]) | (uOn[3] & ~uRes1[1]);
        Abc_Tt7IsopCover( uOn2, uOnDc2, 7, uRes2, pCover, pnCubes );

        uRes[0] = uRes2[0] | uRes0[0];
        uRes[1] = uRes2[1] | uRes0[1];
        uRes[2] = uRes2[0] | uRes1[0];
        uRes[3] = uRes2[1] | uRes1[1];
        for ( c = nBeg0; c < nEnd0; c++ )
            pCover[c] |= (1 << (2*7+0));
        for ( c = nEnd0; c < nEnd1; c++ )
            pCover[c] |= (1 << (2*7+1));
        
# 2886 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2886 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0
# 2886 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2886 "/app/abc/src/misc/util/utilTruth.h"
       (uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0
# 2886 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2886 "/app/abc/src/misc/util/utilTruth.h"
       "(uOn[0] & ~uRes[0]) == 0 && (uOn[1] & ~uRes[1]) == 0 && (uOn[2] & ~uRes[2]) == 0 && (uOn[3] & ~uRes[3]) == 0"
# 2886 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2886, __extension__ __PRETTY_FUNCTION__); }))
# 2886 "/app/abc/src/misc/util/utilTruth.h"
                                                                                                                             ;
        
# 2887 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ((void) sizeof ((
# 2887 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0
# 2887 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2887 "/app/abc/src/misc/util/utilTruth.h"
       (uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0
# 2887 "/app/abc/src/misc/util/utilTruth.h" 3 4
       ) ; else __assert_fail (
# 2887 "/app/abc/src/misc/util/utilTruth.h"
       "(uRes[0] & ~uOnDc[0])==0 && (uRes[1] & ~uOnDc[1])==0 && (uRes[2] & ~uOnDc[2])==0 && (uRes[3] & ~uOnDc[3])==0"
# 2887 "/app/abc/src/misc/util/utilTruth.h" 3 4
       , "/app/abc/src/misc/util/utilTruth.h", 2887, __extension__ __PRETTY_FUNCTION__); }))
# 2887 "/app/abc/src/misc/util/utilTruth.h"
                                                                                                                             ;
    }
}
# 2902 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6Cnf( word t, int nVars, int * pCover )
{
    int c, nCubes = 0;
    Abc_Tt6IsopCover( t, t, nVars, pCover, &nCubes );
    for ( c = 0; c < nCubes; c++ )
        pCover[c] |= (1 << (2*nVars+0));
    Abc_Tt6IsopCover( ~t, ~t, nVars, pCover, &nCubes );
    for ( ; c < nCubes; c++ )
        pCover[c] |= (1 << (2*nVars+1));
    
# 2911 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2911 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 64
# 2911 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2911 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 64
# 2911 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2911 "/app/abc/src/misc/util/utilTruth.h"
   "nCubes <= 64"
# 2911 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2911, __extension__ __PRETTY_FUNCTION__); }))
# 2911 "/app/abc/src/misc/util/utilTruth.h"
                         ;
    return nCubes;
}
static inline int Abc_Tt8Cnf( word t[4], int nVars, int * pCover )
{
    word uRes[4], tc[4] = {~t[0], ~t[1], ~t[2], ~t[3]};
    int c, nCubes = 0;
    Abc_Tt8IsopCover( t, t, nVars, uRes, pCover, &nCubes );
    for ( c = 0; c < nCubes; c++ )
        pCover[c] |= (1 << (2*nVars+0));
    Abc_Tt8IsopCover( tc, tc, nVars, uRes, pCover, &nCubes );
    for ( ; c < nCubes; c++ )
        pCover[c] |= (1 << (2*nVars+1));
    
# 2924 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2924 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 256
# 2924 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2924 "/app/abc/src/misc/util/utilTruth.h"
   nCubes <= 256
# 2924 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2924 "/app/abc/src/misc/util/utilTruth.h"
   "nCubes <= 256"
# 2924 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2924, __extension__ __PRETTY_FUNCTION__); }))
# 2924 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    return nCubes;
}
# 2940 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6Esop( word t, int nVars, int * pCover )
{
    word c0, c1;
    int Var, r0, r1, r2, Max, i;
    
# 2944 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2944 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2944 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2944 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 6
# 2944 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2944 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 6"
# 2944 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2944, __extension__ __PRETTY_FUNCTION__); }))
# 2944 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    if ( t == 0 )
        return 0;
    if ( t == ~(word)0 )
    {
        if ( pCover ) *pCover = 0;
        return 1;
    }
    
# 2952 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2952 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2952 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2952 "/app/abc/src/misc/util/utilTruth.h"
   nVars > 0
# 2952 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2952 "/app/abc/src/misc/util/utilTruth.h"
   "nVars > 0"
# 2952 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2952, __extension__ __PRETTY_FUNCTION__); }))
# 2952 "/app/abc/src/misc/util/utilTruth.h"
                      ;

    for ( Var = nVars-1; Var >= 0; Var-- )
        if ( Abc_Tt6HasVar( t, Var ) )
             break;
    
# 2957 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 2957 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2957 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 2957 "/app/abc/src/misc/util/utilTruth.h"
   Var >= 0
# 2957 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 2957 "/app/abc/src/misc/util/utilTruth.h"
   "Var >= 0"
# 2957 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 2957, __extension__ __PRETTY_FUNCTION__); }))
# 2957 "/app/abc/src/misc/util/utilTruth.h"
                     ;

    c0 = Abc_Tt6Cofactor0( t, Var );
    c1 = Abc_Tt6Cofactor1( t, Var );

    r0 = Abc_Tt6Esop( c0, Var, pCover ? pCover : 
# 2962 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                     ((void *)0) 
# 2962 "/app/abc/src/misc/util/utilTruth.h"
                                                          );
    r1 = Abc_Tt6Esop( c1, Var, pCover ? pCover + r0 : 
# 2963 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                          ((void *)0) 
# 2963 "/app/abc/src/misc/util/utilTruth.h"
                                                               );
    r2 = Abc_Tt6Esop( c0 ^ c1, Var, pCover ? pCover + r0 + r1 : 
# 2964 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                               ((void *)0) 
# 2964 "/app/abc/src/misc/util/utilTruth.h"
                                                                    );
    Max = Abc_MaxInt( r0, Abc_MaxInt(r1, r2) );

    if ( pCover )
    {
        if ( Max == r0 )
        {
            for ( i = 0; i < r1; i++ )
                pCover[i] = pCover[r0+i];
            for ( i = 0; i < r2; i++ )
                pCover[r1+i] = pCover[r0+r1+i] | (1 << (2*Var+0));
        }
        else if ( Max == r1 )
        {
            for ( i = 0; i < r2; i++ )
                pCover[r0+i] = pCover[r0+r1+i] | (1 << (2*Var+1));
        }
        else
        {
            for ( i = 0; i < r0; i++ )
                pCover[i] |= (1 << (2*Var+0));
            for ( i = 0; i < r1; i++ )
                pCover[r0+i] |= (1 << (2*Var+1));
        }
    }
    return r0 + r1 + r2 - Max;
}
static inline word Abc_Tt6EsopBuild( int nVars, int * pCover, int nCubes )
{
    word p, t = 0; int c, v;
    for ( c = 0; c < nCubes; c++ )
    {
        p = ~(word)0;
        for ( v = 0; v < nVars; v++ )
            if ( ((pCover[c] >> (v << 1)) & 3) == 1 )
                p &= ~s_Truths6[v];
            else if ( ((pCover[c] >> (v << 1)) & 3) == 2 )
                p &= s_Truths6[v];
        t ^= p;
    }
    return t;
}
static inline int Abc_Tt6EsopVerify( word t, int nVars )
{
    int pCover[64];
    int nCubes = Abc_Tt6Esop( t, nVars, pCover );
    word t2 = Abc_Tt6EsopBuild( nVars, pCover, nCubes );
    if ( t != t2 )
        printf( "Verification failed.\n" );
    return nCubes;
}
# 3027 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6CheckOutDec( word t, int i, word * pOut )
{
    word c0 = Abc_Tt6Cofactor0( t, i );
    word c1 = Abc_Tt6Cofactor1( t, i );
    
# 3031 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3031 "/app/abc/src/misc/util/utilTruth.h"
   c0 != c1
# 3031 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3031 "/app/abc/src/misc/util/utilTruth.h"
   c0 != c1
# 3031 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3031 "/app/abc/src/misc/util/utilTruth.h"
   "c0 != c1"
# 3031 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3031, __extension__ __PRETTY_FUNCTION__); }))
# 3031 "/app/abc/src/misc/util/utilTruth.h"
                     ;
    if ( c0 == 0 )
    {
        if ( pOut ) *pOut = c1;
        return 0;
    }
    if ( c1 == 0 )
    {
        if ( pOut ) *pOut = c0;
        return 1;
    }
    if ( ~c0 == 0 )
    {
        if ( pOut ) *pOut = c1;
        return 2;
    }
    if ( ~c1 == 0 )
    {
        if ( pOut ) *pOut = c0;
        return 3;
    }
    if ( c0 == ~c1 )
    {
        if ( pOut ) *pOut = c0;
        return 4;
    }
    return -1;
}
static inline int Abc_TtCheckOutDec( word * pTruth, int nVars, int v, word * pOut )
{
    word Cof0[4], Cof1[4];
    int nWords = Abc_TtWordNum(nVars);
    
# 3063 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3063 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 8
# 3063 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3063 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 8
# 3063 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3063 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 8"
# 3063 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3063, __extension__ __PRETTY_FUNCTION__); }))
# 3063 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    Abc_TtCofactor0p( Cof0, pTruth, nWords, v );
    Abc_TtCofactor1p( Cof1, pTruth, nWords, v );
    
# 3066 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3066 "/app/abc/src/misc/util/utilTruth.h"
   !Abc_TtEqual(Cof0, Cof1, nWords)
# 3066 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3066 "/app/abc/src/misc/util/utilTruth.h"
   !Abc_TtEqual(Cof0, Cof1, nWords)
# 3066 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3066 "/app/abc/src/misc/util/utilTruth.h"
   "!Abc_TtEqual(Cof0, Cof1, nWords)"
# 3066 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3066, __extension__ __PRETTY_FUNCTION__); }))
# 3066 "/app/abc/src/misc/util/utilTruth.h"
                                             ;
    if ( Abc_TtIsConst0(Cof0, nWords) )
    {
        if ( pOut ) Abc_TtCopy( pOut, Cof1, nWords, 0 );
        return 0;
    }
    if ( Abc_TtIsConst0(Cof1, nWords) )
    {
        if ( pOut ) Abc_TtCopy( pOut, Cof0, nWords, 0 );
        return 1;
    }
    if ( Abc_TtIsConst1(Cof0, nWords) )
    {
        if ( pOut ) Abc_TtCopy( pOut, Cof1, nWords, 0 );
        return 2;
    }
    if ( Abc_TtIsConst1(Cof1, nWords) )
    {
        if ( pOut ) Abc_TtCopy( pOut, Cof0, nWords, 0 );
        return 3;
    }
    if ( Abc_TtOpposite(Cof0, Cof1, nWords) )
    {
        if ( pOut ) Abc_TtCopy( pOut, Cof0, nWords, 0 );
        return 4;
    }
    return -1;
}
static inline word Abc_TtCheckDecOutOne7( word * t, int * piVar, int * pType )
{
    int v, Type, Type2; word Out[2];
    for ( v = 6; v >= 0; v-- )
        if ( (Type = Abc_TtCheckOutDec(t, 7, v, 
# 3098 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                               ((void *)0)
# 3098 "/app/abc/src/misc/util/utilTruth.h"
                                                   )) != -1 )
        {
            Abc_TtSwapVars( t, 7, 6, v );
            Type2 = Abc_TtCheckOutDec( t, 7, 6, Out );
            
# 3102 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ((void) sizeof ((
# 3102 "/app/abc/src/misc/util/utilTruth.h"
           Type == Type2
# 3102 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 3102 "/app/abc/src/misc/util/utilTruth.h"
           Type == Type2
# 3102 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ; else __assert_fail (
# 3102 "/app/abc/src/misc/util/utilTruth.h"
           "Type == Type2"
# 3102 "/app/abc/src/misc/util/utilTruth.h" 3 4
           , "/app/abc/src/misc/util/utilTruth.h", 3102, __extension__ __PRETTY_FUNCTION__); }))
# 3102 "/app/abc/src/misc/util/utilTruth.h"
                                  ;
            *piVar = v;
            *pType = Type;
            return Out[0];
        }
    return 0;
}
static inline word Abc_TtCheckDecOutOne8( word * t, int * piVar1, int * piVar2, int * pType1, int * pType2 )
{
    int v, Type1, Type12, Type2, Type22; word Out[4], Out2[2];
    for ( v = 7; v >= 0; v-- )
        if ( (Type1 = Abc_TtCheckOutDec(t, 8, v, 
# 3113 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                ((void *)0)
# 3113 "/app/abc/src/misc/util/utilTruth.h"
                                                    )) != -1 )
        {
            Abc_TtSwapVars( t, 8, 7, v );
            Type12 = Abc_TtCheckOutDec( t, 8, 7, Out );
            
# 3117 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ((void) sizeof ((
# 3117 "/app/abc/src/misc/util/utilTruth.h"
           Type1 == Type12
# 3117 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 3117 "/app/abc/src/misc/util/utilTruth.h"
           Type1 == Type12
# 3117 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ; else __assert_fail (
# 3117 "/app/abc/src/misc/util/utilTruth.h"
           "Type1 == Type12"
# 3117 "/app/abc/src/misc/util/utilTruth.h" 3 4
           , "/app/abc/src/misc/util/utilTruth.h", 3117, __extension__ __PRETTY_FUNCTION__); }))
# 3117 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
            *piVar1 = v;
            *pType1 = Type1;
            break;
        }
    if ( v == -1 )
        return 0;
    for ( v = 6; v >= 0; v-- )
        if ( (Type2 = Abc_TtCheckOutDec(Out, 7, v, 
# 3125 "/app/abc/src/misc/util/utilTruth.h" 3 4
                                                  ((void *)0)
# 3125 "/app/abc/src/misc/util/utilTruth.h"
                                                      )) != -1 && Abc_Lit2Var(Type2) == Abc_Lit2Var(Type1) )
        {
            Abc_TtSwapVars( Out, 7, 6, v );
            Type22 = Abc_TtCheckOutDec(Out, 7, 6, Out2);
            
# 3129 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ((void) sizeof ((
# 3129 "/app/abc/src/misc/util/utilTruth.h"
           Type2 == Type22
# 3129 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 3129 "/app/abc/src/misc/util/utilTruth.h"
           Type2 == Type22
# 3129 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ; else __assert_fail (
# 3129 "/app/abc/src/misc/util/utilTruth.h"
           "Type2 == Type22"
# 3129 "/app/abc/src/misc/util/utilTruth.h" 3 4
           , "/app/abc/src/misc/util/utilTruth.h", 3129, __extension__ __PRETTY_FUNCTION__); }))
# 3129 "/app/abc/src/misc/util/utilTruth.h"
                                    ;
            *piVar2 = v;
            *pType2 = Type2;
            
# 3132 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ((void) sizeof ((
# 3132 "/app/abc/src/misc/util/utilTruth.h"
           *piVar2 < *piVar1
# 3132 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 3132 "/app/abc/src/misc/util/utilTruth.h"
           *piVar2 < *piVar1
# 3132 "/app/abc/src/misc/util/utilTruth.h" 3 4
           ) ; else __assert_fail (
# 3132 "/app/abc/src/misc/util/utilTruth.h"
           "*piVar2 < *piVar1"
# 3132 "/app/abc/src/misc/util/utilTruth.h" 3 4
           , "/app/abc/src/misc/util/utilTruth.h", 3132, __extension__ __PRETTY_FUNCTION__); }))
# 3132 "/app/abc/src/misc/util/utilTruth.h"
                                      ;
            return Out2[0];
        }
    return 0;
}
# 3149 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_TtCheckDsdAnd( word t, int i, int j, word * pOut )
{
    word c0 = Abc_Tt6Cofactor0( t, i );
    word c1 = Abc_Tt6Cofactor1( t, i );
    word c00 = Abc_Tt6Cofactor0( c0, j );
    word c01 = Abc_Tt6Cofactor1( c0, j );
    word c10 = Abc_Tt6Cofactor0( c1, j );
    word c11 = Abc_Tt6Cofactor1( c1, j );
    if ( c00 == c01 && c00 == c10 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c00) | (s_Truths6[i] & c11);
        return 0;
    }
    if ( c11 == c00 && c11 == c10 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c11) | (s_Truths6[i] & c01);
        return 1;
    }
    if ( c11 == c00 && c11 == c01 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c11) | (s_Truths6[i] & c10);
        return 2;
    }
    if ( c11 == c01 && c11 == c10 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c11) | (s_Truths6[i] & c00);
        return 3;
    }
    if ( c00 == c11 && c01 == c10 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c11) | (s_Truths6[i] & c10);
        return 4;
    }
    return -1;
}
static inline int Abc_TtCheckDsdMux( word t, int i, word * pOut )
{
    word c0 = Abc_Tt6Cofactor0( t, i );
    word c1 = Abc_Tt6Cofactor1( t, i );
    word c00, c01, c10, c11;
    int k, fPres0, fPres1, iVar0 = -1, iVar1 = -1;
    for ( k = 0; k < 6; k++ )
    {
        if ( k == i ) continue;
        fPres0 = Abc_Tt6HasVar( c0, k );
        fPres1 = Abc_Tt6HasVar( c1, k );
        if ( fPres0 && !fPres1 )
        {
            if ( iVar0 >= 0 )
                return -1;
            iVar0 = k;
        }
        if ( !fPres0 && fPres1 )
        {
            if ( iVar1 >= 0 )
                return -1;
            iVar1 = k;
        }
    }
    if ( iVar0 == -1 || iVar1 == -1 )
        return -1;
    c00 = Abc_Tt6Cofactor0( c0, iVar0 );
    c01 = Abc_Tt6Cofactor1( c0, iVar0 );
    c10 = Abc_Tt6Cofactor0( c1, iVar1 );
    c11 = Abc_Tt6Cofactor1( c1, iVar1 );
    if ( c00 == c10 && c01 == c11 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c10) | (s_Truths6[i] & c11);
        return (Abc_Var2Lit(iVar1, 0) << 16) | Abc_Var2Lit(iVar0, 0);
    }
    if ( c00 == ~c10 && c01 == ~c11 )
    {
        if ( pOut ) *pOut = (~s_Truths6[i] & c10) | (s_Truths6[i] & c11);
        return (Abc_Var2Lit(iVar1, 0) << 16) | Abc_Var2Lit(iVar0, 1);
    }
    return -1;
}
static inline void Unm_ManCheckTest2()
{
    word t, t1, Out, Var0, Var1, Var0_, Var1_;
    int iVar0, iVar1, i, Res;
    for ( iVar0 = 0; iVar0 < 6; iVar0++ )
    for ( iVar1 = 0; iVar1 < 6; iVar1++ )
    {
        if ( iVar0 == iVar1 )
            continue;
        Var0 = s_Truths6[iVar0];
        Var1 = s_Truths6[iVar1];
        for ( i = 0; i < 5; i++ )
        {
            Var0_ = ((i >> 0) & 1) ? ~Var0 : Var0;
            Var1_ = ((i >> 1) & 1) ? ~Var1 : Var1;

            t = Var0_ & Var1_;
            if ( i == 4 )
                t = ~(Var0_ ^ Var1_);



            Res = Abc_TtCheckDsdAnd( t, iVar0, iVar1, &Out );
            if ( Res == -1 )
            {
                printf( "No decomposition\n" );
                continue;
            }

            Var0_ = s_Truths6[iVar0];
            Var0_ = ((Res >> 0) & 1) ? ~Var0_ : Var0_;

            Var1_ = s_Truths6[iVar1];
            Var1_ = ((Res >> 1) & 1) ? ~Var1_ : Var1_;

            t1 = Var0_ & Var1_;
            if ( Res == 4 )
                t1 = Var0_ ^ Var1_;

            t1 = (~t1 & Abc_Tt6Cofactor0(Out, iVar0)) | (t1 & Abc_Tt6Cofactor1(Out, iVar0));



            if ( t1 != t )
                printf( "Verification failed.\n" );
            else
                printf( "Verification succeeded.\n" );
        }
    }
}
static inline void Unm_ManCheckTest()
{
    word t, t1, Out, Ctrl, Var0, Var1, Ctrl_, Var0_, Var1_;
    int iVar0, iVar1, iCtrl, i, Res;
    for ( iCtrl = 0; iCtrl < 6; iCtrl++ )
    for ( iVar0 = 0; iVar0 < 6; iVar0++ )
    for ( iVar1 = 0; iVar1 < 6; iVar1++ )
    {
        if ( iCtrl == iVar0 || iCtrl == iVar1 || iVar0 == iVar1 )
            continue;
        Ctrl = s_Truths6[iCtrl];
        Var0 = s_Truths6[iVar0];
        Var1 = s_Truths6[iVar1];
        for ( i = 0; i < 8; i++ )
        {
            Ctrl_ = ((i >> 0) & 1) ? ~Ctrl : Ctrl;
            Var0_ = ((i >> 1) & 1) ? ~Var0 : Var0;
            Var1_ = ((i >> 2) & 1) ? ~Var1 : Var1;

            t = (~Ctrl_ & Var0_) | (Ctrl_ & Var1_);



            Res = Abc_TtCheckDsdMux( t, iCtrl, &Out );
            if ( Res == -1 )
            {
                printf( "No decomposition\n" );
                continue;
            }



            Ctrl_ = s_Truths6[iCtrl];
            Var0_ = s_Truths6[Abc_Lit2Var(Res & 0xFFFF)];
            Var0_ = Abc_LitIsCompl(Res & 0xFFFF) ? ~Var0_ : Var0_;

            Res >>= 16;
            Var1_ = s_Truths6[Abc_Lit2Var(Res & 0xFFFF)];
            Var1_ = Abc_LitIsCompl(Res & 0xFFFF) ? ~Var1_ : Var1_;

            t1 = (~Ctrl_ & Var0_) | (Ctrl_ & Var1_);




            t1 = (~t1 & Abc_Tt6Cofactor0(Out, iCtrl)) | (t1 & Abc_Tt6Cofactor1(Out, iCtrl));



            if ( t1 != t )
                printf( "Verification failed.\n" );
            else
                printf( "Verification succeeded.\n" );
        }
    }
}
# 3345 "/app/abc/src/misc/util/utilTruth.h"
static inline word Abc_TtEvalLut6( word Ins[6], word Lut, int nVars )
{
    word Cube, Res = 0; int k, i;
    for ( k = 0; k < (1<<nVars); k++ )
    {
        if ( ((Lut >> k) & 1) == 0 )
            continue;
        Cube = ~(word)0;
        for ( i = 0; i < nVars; i++ )
            Cube &= ((k >> i) & 1) ? Ins[i] : ~Ins[i];
        Res |= Cube;
    }
    return Res;
}
static inline unsigned Abc_TtEvalLut5( unsigned Ins[5], int Lut, int nVars )
{
    unsigned Cube, Res = 0; int k, i;
    for ( k = 0; k < (1<<nVars); k++ )
    {
        if ( ((Lut >> k) & 1) == 0 )
            continue;
        Cube = ~(unsigned)0;
        for ( i = 0; i < nVars; i++ )
            Cube &= ((k >> i) & 1) ? Ins[i] : ~Ins[i];
        Res |= Cube;
    }
    return Res;
}
static inline int Abc_TtEvalLut4( int Ins[4], int Lut, int nVars )
{
    int Cube, Res = 0; int k, i;
    for ( k = 0; k < (1<<nVars); k++ )
    {
        if ( ((Lut >> k) & 1) == 0 )
            continue;
        Cube = ~(int)0;
        for ( i = 0; i < nVars; i++ )
            Cube &= ((k >> i) & 1) ? Ins[i] : ~Ins[i];
        Res |= Cube;
    }
    return Res & ~(~0 << (1<<nVars));
}
# 3400 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtComputeGraph( word * pTruth, int v, int nVars, int * pGraph )
{
    word Cof0[64], Cof1[64];
    word Cof00[64], Cof01[64], Cof10[64], Cof11[64];
    word CofXor, CofAndTest;
    int i, w, nWords = Abc_TtWordNum(nVars);
    pGraph[v] |= (1 << v);
    if ( v == nVars - 1 )
        return;
    
# 3409 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3409 "/app/abc/src/misc/util/utilTruth.h"
   v < nVars - 1
# 3409 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3409 "/app/abc/src/misc/util/utilTruth.h"
   v < nVars - 1
# 3409 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3409 "/app/abc/src/misc/util/utilTruth.h"
   "v < nVars - 1"
# 3409 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3409, __extension__ __PRETTY_FUNCTION__); }))
# 3409 "/app/abc/src/misc/util/utilTruth.h"
                          ;
    Abc_TtCofactor0p( Cof0, pTruth, nWords, v );
    Abc_TtCofactor1p( Cof1, pTruth, nWords, v );
    for ( i = v + 1; i < nVars; i++ )
    {
        Abc_TtCofactor0p( Cof00, Cof0, nWords, i );
        Abc_TtCofactor1p( Cof01, Cof0, nWords, i );
        Abc_TtCofactor0p( Cof10, Cof1, nWords, i );
        Abc_TtCofactor1p( Cof11, Cof1, nWords, i );
        for ( w = 0; w < nWords; w++ )
        {
            CofXor = Cof00[w] ^ Cof01[w] ^ Cof10[w] ^ Cof11[w];
            CofAndTest = (Cof00[w] & Cof01[w]) | (Cof10[w] & Cof11[w]);
            if ( CofXor & CofAndTest )
            {
                pGraph[v] |= (1 << i);
                pGraph[i] |= (1 << v);
            }
            else if ( CofXor & ~CofAndTest )
            {
                pGraph[v] |= (1 << (16+i));
                pGraph[i] |= (1 << (16+v));
            }
        }
    }
}
static inline void Abc_TtPrintVarSet( int Mask, int nVars )
{
    int i;
    for ( i = 0; i < nVars; i++ )
        if ( (Mask >> i) & 1 )
            printf( "1" );
        else
            printf( "." );
}
static inline void Abc_TtPrintBiDec( word * pTruth, int nVars )
{
    int v, pGraph[12] = {0};
    
# 3447 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3447 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 12
# 3447 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3447 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 12
# 3447 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3447 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 12"
# 3447 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3447, __extension__ __PRETTY_FUNCTION__); }))
# 3447 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    for ( v = 0; v < nVars; v++ )
    {
        Abc_TtComputeGraph( pTruth, v, nVars, pGraph );
        Abc_TtPrintVarSet( pGraph[v], nVars );
        printf( "    " );
        Abc_TtPrintVarSet( pGraph[v] >> 16, nVars );
        printf( "\n" );
    }
}
static inline int Abc_TtVerifyBiDec( word * pTruth, int nVars, int This, int That, int nSuppLim, word wThis, word wThat )
{
    int pVarsThis[12], pVarsThat[12], pVarsAll[12];
    int nThis = Abc_TtBitCount16(This);
    int nThat = Abc_TtBitCount16(That);
    int i, k, nWords = Abc_TtWordNum(nVars);
    word pThis[64] = {wThis}, pThat[64] = {wThat};
    
# 3464 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3464 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 12
# 3464 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3464 "/app/abc/src/misc/util/utilTruth.h"
   nVars <= 12
# 3464 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3464 "/app/abc/src/misc/util/utilTruth.h"
   "nVars <= 12"
# 3464 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3464, __extension__ __PRETTY_FUNCTION__); }))
# 3464 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    for ( i = 0; i < nVars; i++ )
        pVarsAll[i] = i;
    for ( i = k = 0; i < nVars; i++ )
        if ( (This >> i) & 1 )
            pVarsThis[k++] = i;
    
# 3470 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3470 "/app/abc/src/misc/util/utilTruth.h"
   k == nThis
# 3470 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3470 "/app/abc/src/misc/util/utilTruth.h"
   k == nThis
# 3470 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3470 "/app/abc/src/misc/util/utilTruth.h"
   "k == nThis"
# 3470 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3470, __extension__ __PRETTY_FUNCTION__); }))
# 3470 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    for ( i = k = 0; i < nVars; i++ )
        if ( (That >> i) & 1 )
            pVarsThat[k++] = i;
    
# 3474 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3474 "/app/abc/src/misc/util/utilTruth.h"
   k == nThat
# 3474 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3474 "/app/abc/src/misc/util/utilTruth.h"
   k == nThat
# 3474 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3474 "/app/abc/src/misc/util/utilTruth.h"
   "k == nThat"
# 3474 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3474, __extension__ __PRETTY_FUNCTION__); }))
# 3474 "/app/abc/src/misc/util/utilTruth.h"
                       ;
    Abc_TtStretch6( pThis, nThis, nVars );
    Abc_TtStretch6( pThat, nThat, nVars );
    Abc_TtExpand( pThis, nVars, pVarsThis, nThis, pVarsAll, nVars );
    Abc_TtExpand( pThat, nVars, pVarsThat, nThat, pVarsAll, nVars );
    for ( k = 0; k < nWords; k++ )
        if ( pTruth[k] != (pThis[k] & pThat[k]) )
            return 0;
    return 1;
}
static inline void Abc_TtExist( word * pTruth, int iVar, int nWords )
{
    word Cof0[64], Cof1[64];
    Abc_TtCofactor0p( Cof0, pTruth, nWords, iVar );
    Abc_TtCofactor1p( Cof1, pTruth, nWords, iVar );
    Abc_TtOr( pTruth, Cof0, Cof1, nWords );
}
static inline int Abc_TtCheckBiDec( word * pTruth, int nVars, int This, int That )
{
    int VarMask[2] = {This & ~That, That & ~This};
    int v, c, nWords = Abc_TtWordNum(nVars);
    word pTempR[2][64];
    for ( c = 0; c < 2; c++ )
    {
        Abc_TtCopy( pTempR[c], pTruth, nWords, 0 );
        for ( v = 0; v < nVars; v++ )
            if ( ((VarMask[c] >> v) & 1) )
                Abc_TtExist( pTempR[c], v, nWords );
    }
    for ( v = 0; v < nWords; v++ )
        if ( ~pTruth[v] & pTempR[0][v] & pTempR[1][v] )
            return 0;
    return 1;
}
static inline word Abc_TtDeriveBiDecOne( word * pTruth, int nVars, int This )
{
    word pTemp[64];
    int nThis = Abc_TtBitCount16(This);
    int v, nWords = Abc_TtWordNum(nVars);
    Abc_TtCopy( pTemp, pTruth, nWords, 0 );
    for ( v = 0; v < nVars; v++ )
        if ( !((This >> v) & 1) )
            Abc_TtExist( pTemp, v, nWords );
    Abc_TtShrink( pTemp, nThis, nVars, This );
    return Abc_Tt6Stretch( pTemp[0], nThis );
}
static inline void Abc_TtDeriveBiDec( word * pTruth, int nVars, int This, int That, int nSuppLim, word * pThis, word * pThat )
{
    
# 3522 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3522 "/app/abc/src/misc/util/utilTruth.h"
   Abc_TtBitCount16(This) <= nSuppLim
# 3522 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3522 "/app/abc/src/misc/util/utilTruth.h"
   Abc_TtBitCount16(This) <= nSuppLim
# 3522 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3522 "/app/abc/src/misc/util/utilTruth.h"
   "Abc_TtBitCount16(This) <= nSuppLim"
# 3522 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3522, __extension__ __PRETTY_FUNCTION__); }))
# 3522 "/app/abc/src/misc/util/utilTruth.h"
                                               ;
    
# 3523 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3523 "/app/abc/src/misc/util/utilTruth.h"
   Abc_TtBitCount16(That) <= nSuppLim
# 3523 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3523 "/app/abc/src/misc/util/utilTruth.h"
   Abc_TtBitCount16(That) <= nSuppLim
# 3523 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3523 "/app/abc/src/misc/util/utilTruth.h"
   "Abc_TtBitCount16(That) <= nSuppLim"
# 3523 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3523, __extension__ __PRETTY_FUNCTION__); }))
# 3523 "/app/abc/src/misc/util/utilTruth.h"
                                               ;
    pThis[0] = Abc_TtDeriveBiDecOne( pTruth, nVars, This );
    pThat[0] = Abc_TtDeriveBiDecOne( pTruth, nVars, That );
    if ( !Abc_TtVerifyBiDec(pTruth, nVars, This, That, nSuppLim, pThis[0], pThat[0] ) )
        printf( "Bi-decomposition verification failed.\n" );
}

static inline int Abc_TtCheckBiDecSimple( word * pTruth, int nVars, int nSuppLim )
{
    word Cof0[64], Cof1[64];
    int v, Res = 0, nDecVars = 0, nWords = Abc_TtWordNum(nVars);
    for ( v = 0; v < nVars; v++ )
    {
        Abc_TtCofactor0p( Cof0, pTruth, nWords, v );
        Abc_TtCofactor1p( Cof1, pTruth, nWords, v );
        if ( !Abc_TtIsConst0(Cof0, nWords) && !Abc_TtIsConst0(Cof1, nWords) )
            continue;
        nDecVars++;
        Res |= 1 << v;
        if ( nDecVars >= nVars - nSuppLim )
            return ((Res ^ (int)Abc_Tt6Mask(nVars)) << 16) | Res;
    }
    return 0;
}
static inline int Abc_TtProcessBiDecInt( word * pTruth, int nVars, int nSuppLim )
{
    int i, v, Res, nSupp, CountShared = 0, pGraph[12] = {0};
    
# 3550 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3550 "/app/abc/src/misc/util/utilTruth.h"
   nSuppLim < nVars && nVars <= 2 * nSuppLim && nVars <= 12
# 3550 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3550 "/app/abc/src/misc/util/utilTruth.h"
   nSuppLim < nVars && nVars <= 2 * nSuppLim && nVars <= 12
# 3550 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3550 "/app/abc/src/misc/util/utilTruth.h"
   "nSuppLim < nVars && nVars <= 2 * nSuppLim && nVars <= 12"
# 3550 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3550, __extension__ __PRETTY_FUNCTION__); }))
# 3550 "/app/abc/src/misc/util/utilTruth.h"
                                                                     ;
    
# 3551 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3551 "/app/abc/src/misc/util/utilTruth.h"
   2 <= nSuppLim && nSuppLim <= 6
# 3551 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3551 "/app/abc/src/misc/util/utilTruth.h"
   2 <= nSuppLim && nSuppLim <= 6
# 3551 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3551 "/app/abc/src/misc/util/utilTruth.h"
   "2 <= nSuppLim && nSuppLim <= 6"
# 3551 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3551, __extension__ __PRETTY_FUNCTION__); }))
# 3551 "/app/abc/src/misc/util/utilTruth.h"
                                           ;
    Res = Abc_TtCheckBiDecSimple( pTruth, nVars, nSuppLim );
    if ( Res )
        return Res;
    for ( v = 0; v < nVars; v++ )
    {
        Abc_TtComputeGraph( pTruth, v, nVars, pGraph );
        nSupp = Abc_TtBitCount16(pGraph[v] & 0xFFFF);
        if ( nSupp > nSuppLim )
        {

            if ( ++CountShared > 2*nSuppLim - nVars )
                return 0;
        }
        else if ( nVars - nSupp <= nSuppLim )
        {
            int This = pGraph[v] & 0xFFFF;
            int That = This ^ (int)Abc_Tt6Mask(nVars);

            int Graph = That;
            for ( i = 0; i < nVars; i++ )
                if ( (That >> i) & 1 )
                    Graph |= pGraph[i] & 0xFFFF;

            if ( Abc_TtBitCount16(Graph) > nSuppLim )
                continue;

            if ( Abc_TtCheckBiDec(pTruth, nVars, This, Graph) )
                return (Graph << 16) | This;
        }
    }
    return 0;
}
static inline int Abc_TtProcessBiDec( word * pTruth, int nVars, int nSuppLim )
{
    word pFunc[64];
    int Res, nWords = Abc_TtWordNum(nVars);
    Abc_TtCopy( pFunc, pTruth, nWords, 0 );
    Res = Abc_TtProcessBiDecInt( pFunc, nVars, nSuppLim );
    if ( Res )
        return Res;
    Abc_TtCopy( pFunc, pTruth, nWords, 1 );
    Res = Abc_TtProcessBiDecInt( pFunc, nVars, nSuppLim );
    if ( Res )
        return Res | (1 << 30);
    return 0;
}
# 3610 "/app/abc/src/misc/util/utilTruth.h"
static inline void Abc_TtProcessBiDecTest( word * pTruth, int nVars, int nSuppLim )
{
    word This, That, pTemp[64];
    int Res, resThis, resThat;
    int nWords = Abc_TtWordNum(nVars);
    Abc_TtCopy( pTemp, pTruth, nWords, 0 );
    Res = Abc_TtProcessBiDec( pTemp, nVars, nSuppLim );
    if ( Res == 0 )
    {


        return;
    }

    resThis = Res & 0xFFFF;
    resThat = Res >> 16;

    Abc_TtDeriveBiDec( pTemp, nVars, resThis, resThat, nSuppLim, &This, &That );
    return;
# 3638 "/app/abc/src/misc/util/utilTruth.h"
    printf( "Variable sets:    " );
    Abc_TtPrintVarSet( resThis, nVars );
    printf( "    " );
    Abc_TtPrintVarSet( resThat, nVars );
    printf( "\n" );
    Abc_TtDeriveBiDec( pTemp, nVars, resThis, resThat, nSuppLim, &This, &That );


    printf( "\n" );
}
static inline void Abc_TtProcessBiDecExperiment()
{
    int nVars = 3;
    int nSuppLim = 2;
    int Res, resThis, resThat;
    word This, That;



    word t = ((s_Truths6[0] | s_Truths6[1]) & (s_Truths6[1] | s_Truths6[2]));
    Abc_TtPrintBiDec( &t, nVars );
    Res = Abc_TtProcessBiDec( &t, nVars, nSuppLim );
    resThis = Res & 0xFFFF;
    resThat = Res >> 16;
    Abc_TtDeriveBiDec( &t, nVars, resThis, resThat, nSuppLim, &This, &That );


    nVars = nSuppLim;
}
# 3679 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt4Equal3( int c0, int c1, int c2, int c3 )
{
    if ( c0 == c1 && c0 == c2 ) return 3;
    if ( c0 == c1 && c0 == c3 ) return 2;
    if ( c0 == c3 && c0 == c2 ) return 1;
    if ( c3 == c1 && c3 == c2 ) return 0;
    return -1;
}
static inline int Abc_Tt4Check2( int t, int i, int j, int * f, int * r )
{
    int c0 = t & r[j];
    int c1 = (t & f[j]) >> (1 << j);
    int c00 = c0 & r[i];
    int c01 = (c0 & f[i]) >> (1 << i);
    int c10 = c1 & r[i];
    int c11 = (c1 & f[i]) >> (1 << i);
    return Abc_Tt4Equal3( c00, c01, c10, c11 );
}
static inline int Abc_Tt4CheckTwoLevel( int t )
{
    int pair1, pair2;
    int f[4] = { 0xAAAA, 0xCCCC, 0xF0F0, 0xFF00 };
    int r[4] = { 0x5555, 0x3333, 0x0F0F, 0x00FF };
    if ( (pair1 = Abc_Tt4Check2(t, 0, 1, f, r)) >= 0 && (pair2 = Abc_Tt4Check2(t, 2, 3, f, r)) >= 0 ) return (1 << 4) | (pair2 << 2) | pair1;
    if ( (pair1 = Abc_Tt4Check2(t, 0, 2, f, r)) >= 0 && (pair2 = Abc_Tt4Check2(t, 1, 3, f, r)) >= 0 ) return (2 << 4) | (pair2 << 2) | pair1;
    if ( (pair1 = Abc_Tt4Check2(t, 0, 3, f, r)) >= 0 && (pair2 = Abc_Tt4Check2(t, 1, 2, f, r)) >= 0 ) return (3 << 4) | (pair2 << 2) | pair1;
    return -1;
}
static inline int Abc_Tt4CountOnes( int t )
{
    t = (t & (0x5555)) + ((t >> 1) & (0x5555));
    t = (t & (0x3333)) + ((t >> 2) & (0x3333));
    t = (t & (0x0f0f)) + ((t >> 4) & (0x0f0f));
    t = (t & (0x00ff)) + ((t >> 8) & (0x00ff));
    return t;
}
static inline int Abc_Tt4FirstBit( int t )
{
    int n = 0;
    if ( t == 0 ) return -1;
    if ( (t & 0x00FF) == 0 ) { n += 8; t >>= 8; }
    if ( (t & 0x000F) == 0 ) { n += 4; t >>= 4; }
    if ( (t & 0x0003) == 0 ) { n += 2; t >>= 2; }
    if ( (t & 0x0001) == 0 ) { n++; }
    return n;
}
static inline int Abc_Tt4Check( int t )
{
    int Count, tn = 0xFFFF & ~t;
    if ( t == 0x6996 || tn == 0x6996 ) return 1;
    if ( (t & (t-1)) == 0 ) return 1;
    if ( (tn & (tn-1)) == 0 ) return 1;
    Count = Abc_Tt4CountOnes( t );
    if ( Count == 7 && Abc_Tt4CheckTwoLevel(t) > 0 ) return 1;
    if ( Count == 9 && Abc_Tt4CheckTwoLevel(tn) > 0 ) return 1;
    return 0;
}
# 3749 "/app/abc/src/misc/util/utilTruth.h"
static inline int Abc_Tt6VarsAreSymmetric( word t, int iVar, int jVar )
{
    word * s_PMasks = s_PPMasks[iVar][jVar];
    int shift = (1 << jVar) - (1 << iVar);
    
# 3753 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3753 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 3753 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3753 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 3753 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3753 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < jVar"
# 3753 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3753, __extension__ __PRETTY_FUNCTION__); }))
# 3753 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    return ((t & s_PMasks[1]) << shift) == (t & s_PMasks[2]);
}
static inline int Abc_Tt6VarsAreAntiSymmetric( word t, int iVar, int jVar )
{
    word * s_PMasks = s_PPMasks[iVar][jVar];
    int shift = (1 << jVar) + (1 << iVar);
    
# 3760 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3760 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 3760 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3760 "/app/abc/src/misc/util/utilTruth.h"
   iVar < jVar
# 3760 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3760 "/app/abc/src/misc/util/utilTruth.h"
   "iVar < jVar"
# 3760 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3760, __extension__ __PRETTY_FUNCTION__); }))
# 3760 "/app/abc/src/misc/util/utilTruth.h"
                        ;
    return ((t & (s_PMasks[1] >> (1 << iVar))) << shift) == (t & (s_PMasks[2] << (1 << iVar)));
}
static inline int Abc_TtVarsAreSymmetric( word * pTruth, int nVars, int i, int j, word * pCof0, word * pCof1 )
{
    int nWords = Abc_TtWordNum( nVars );
    
# 3766 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3766 "/app/abc/src/misc/util/utilTruth.h"
   i < nVars && j < nVars
# 3766 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3766 "/app/abc/src/misc/util/utilTruth.h"
   i < nVars && j < nVars
# 3766 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3766 "/app/abc/src/misc/util/utilTruth.h"
   "i < nVars && j < nVars"
# 3766 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3766, __extension__ __PRETTY_FUNCTION__); }))
# 3766 "/app/abc/src/misc/util/utilTruth.h"
                                   ;
    Abc_TtCofactor0p( pCof0, pTruth, nWords, i );
    Abc_TtCofactor1p( pCof1, pTruth, nWords, i );
    Abc_TtCofactor1( pCof0, nWords, j );
    Abc_TtCofactor0( pCof1, nWords, j );
    return Abc_TtEqual( pCof0, pCof1, nWords );
}
static inline int Abc_TtVarsAreAntiSymmetric( word * pTruth, int nVars, int i, int j, word * pCof0, word * pCof1 )
{
    int nWords = Abc_TtWordNum( nVars );
    
# 3776 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3776 "/app/abc/src/misc/util/utilTruth.h"
   i < nVars && j < nVars
# 3776 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3776 "/app/abc/src/misc/util/utilTruth.h"
   i < nVars && j < nVars
# 3776 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3776 "/app/abc/src/misc/util/utilTruth.h"
   "i < nVars && j < nVars"
# 3776 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3776, __extension__ __PRETTY_FUNCTION__); }))
# 3776 "/app/abc/src/misc/util/utilTruth.h"
                                   ;
    Abc_TtCofactor0p( pCof0, pTruth, nWords, i );
    Abc_TtCofactor1p( pCof1, pTruth, nWords, i );
    Abc_TtCofactor0( pCof0, nWords, j );
    Abc_TtCofactor1( pCof1, nWords, j );
    return Abc_TtEqual( pCof0, pCof1, nWords );
}
static inline int Abc_TtIsFullySymmetric( word * pTruth, int nVars )
{
    int m, v, Polar = 0, Seen = 0;
    for ( m = 0; m < (1<<nVars); m++ )
    {
        int Count = 0;
        int Value = Abc_TtGetBit( pTruth, m );
        for ( v = 0; v < nVars; v++ )
            Count += ((m >> v) & 1);
        if ( (Seen >> Count) & 1 )
        {
            if ( Value != ((Polar >> Count) & 1) )
                return -1;
        }
        else
        {
            Seen |= 1 << Count;
            if ( Value )
                Polar |= 1 << Count;
        }
    }
    return Polar;
}
static inline void Abc_TtGenFullySymmetric( word * pTruth, int nVars, int Polar )
{
    int m, v, nWords = Abc_TtWordNum( nVars );
    Abc_TtClear( pTruth, nWords );
    for ( m = 0; m < (1<<nVars); m++ )
    {
        int Count = 0;
        for ( v = 0; v < nVars; v++ )
            Count += ((m >> v) & 1);
        if ( (Polar >> Count) & 1 )
            Abc_TtSetBit( pTruth, m );
    }
}
static inline void Abc_TtTestFullySymmetric()
{
    word pTruth[4];
    int PolarOut, PolarIn = 271;
    Abc_TtGenFullySymmetric( pTruth, 8, PolarIn );

    PolarOut = Abc_TtIsFullySymmetric( pTruth, 8 );
    
# 3826 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3826 "/app/abc/src/misc/util/utilTruth.h"
   PolarIn == PolarOut
# 3826 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3826 "/app/abc/src/misc/util/utilTruth.h"
   PolarIn == PolarOut
# 3826 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3826 "/app/abc/src/misc/util/utilTruth.h"
   "PolarIn == PolarOut"
# 3826 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3826, __extension__ __PRETTY_FUNCTION__); }))
# 3826 "/app/abc/src/misc/util/utilTruth.h"
                                ;
}
# 3841 "/app/abc/src/misc/util/utilTruth.h"
static inline word * Abc_TtSymFunGenerate( char * pOnes, int nVars )
{
    int m, k, Count;
    word * pTruth = ((word *) calloc((size_t)(Abc_TtWordNum(nVars)), sizeof(word)));
    
# 3845 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ((void) sizeof ((
# 3845 "/app/abc/src/misc/util/utilTruth.h"
   (int)strlen(pOnes) == nVars + 1
# 3845 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3845 "/app/abc/src/misc/util/utilTruth.h"
   (int)strlen(pOnes) == nVars + 1
# 3845 "/app/abc/src/misc/util/utilTruth.h" 3 4
   ) ; else __assert_fail (
# 3845 "/app/abc/src/misc/util/utilTruth.h"
   "(int)strlen(pOnes) == nVars + 1"
# 3845 "/app/abc/src/misc/util/utilTruth.h" 3 4
   , "/app/abc/src/misc/util/utilTruth.h", 3845, __extension__ __PRETTY_FUNCTION__); }))
# 3845 "/app/abc/src/misc/util/utilTruth.h"
                                            ;
    for ( m = 0; m < (1 << nVars); m++ )
    {
        Count = 0;
        for ( k = 0; k < nVars; k++ )
            Count += (m >> k) & 1;
        if ( pOnes[Count] == '1' )
            Abc_TtXorBit( pTruth, m );
    }
    return pTruth;
}



# 40 "/app/abc/src/map/if/if.h" 2
# 1 "/app/abc/src/opt/dau/dau.h" 1
# 32 "/app/abc/src/opt/dau/dau.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/opt/dau/dau.h" 2








# 51 "/app/abc/src/opt/dau/dau.h"
typedef enum {
    DAU_DSD_NONE = 0,
    DAU_DSD_CONST0,
    DAU_DSD_VAR,
    DAU_DSD_AND,
    DAU_DSD_XOR,
    DAU_DSD_MUX,
    DAU_DSD_PRIME
} Dau_DsdType_t;

typedef struct Dss_Man_t_ Dss_Man_t;
typedef struct Abc_TtHieMan_t_ Abc_TtHieMan_t;
typedef unsigned(*TtCanonicizeFunc)(Abc_TtHieMan_t * p, word * pTruth, int nVars, char * pCanonPerm, int flag);





static inline int Dau_DsdIsConst( char * p ) { return (p[0] == '0' || p[0] == '1') && p[1] == 0; }
static inline int Dau_DsdIsConst0( char * p ) { return p[0] == '0' && p[1] == 0; }
static inline int Dau_DsdIsConst1( char * p ) { return p[0] == '1' && p[1] == 0; }
static inline int Dau_DsdIsVar( char * p ) { if ( *p == '!' ) p++; return *p >= 'a' && *p <= 'z'; }
static inline int Dau_DsdReadVar( char * p ) { if ( *p == '!' ) p++; return *p - 'a'; }






extern unsigned Abc_TtCanonicize( word * pTruth, int nVars, char * pCanonPerm );
extern unsigned Abc_TtCanonicizePerm( word * pTruth, int nVars, char * pCanonPerm );
extern unsigned Abc_TtCanonicizePhase( word * pTruth, int nVars );
extern int Abc_TtCountOnesInCofsSimple( word * pTruth, int nVars, int * pStore );
extern unsigned Abc_TtCanonicizeHie(Abc_TtHieMan_t * p, word * pTruth, int nVars, char * pCanonPerm, int fExact );
extern Abc_TtHieMan_t * Abc_TtHieManStart( int nVars, int nLevels );
extern void Abc_TtHieManStop(Abc_TtHieMan_t * p );
extern unsigned Abc_TtCanonicizeWrap(TtCanonicizeFunc func, Abc_TtHieMan_t * p, word * pTruth, int nVars, char * pCanonPerm, int flag);
extern unsigned Abc_TtCanonicizeAda(Abc_TtHieMan_t * p, word * pTruth, int nVars, char * pCanonPerm, int iThres);
extern unsigned Abc_TtCanonicizeHie(Abc_TtHieMan_t * p, word * pTruthInit, int nVars, char * pCanonPerm, int fExact);

extern int Abc_TtCountOnesInCofsQuick( word * pTruth, int nVars, int * pStore );

extern int * Dau_DsdComputeMatches( char * p );
extern int Dau_DsdDecompose( word * pTruth, int nVarsInit, int fSplitPrime, int fWriteTruth, char * pRes );
extern int Dau_DsdDecomposeLevel( word * pTruth, int nVarsInit, int fSplitPrime, int fWriteTruth, char * pRes, int * pVarLevels );
extern void Dau_DsdPrintFromTruthFile( FILE * pFile, word * pTruth, int nVarsInit );
extern void Dau_DsdPrintFromTruth( word * pTruth, int nVarsInit );
extern word * Dau_DsdToTruth( char * p, int nVars );
extern word Dau_Dsd6ToTruth( char * p );
extern void Dau_DsdNormalize( char * p );
extern int Dau_DsdCountAnds( char * pDsd );
extern void Dau_DsdTruthCompose_rec( word * pFunc, word pFanins[12][(1<<(12 -6))], word * pRes, int nVars, int nWordsR );
extern int Dau_DsdCheck1Step( void * p, word * pTruth, int nVarsInit, int * pVarLevels );


extern int Dsm_ManTruthToGia( void * p, word * pTruth, Vec_Int_t * vLeaves, Vec_Int_t * vCover );
extern void * Dsm_ManDeriveGia( void * p, int fUseMuxes );


extern void Dau_DsdRemoveBraces( char * pDsd, int * pMatches );
extern char * Dau_DsdMerge( char * pDsd0i, int * pPerm0, char * pDsd1i, int * pPerm1, int fCompl0, int fCompl1, int nVars );


extern Vec_Int_t * Dau_DecFindSets_int( word * pInit, int nVars, int * pSched[16] );
extern Vec_Int_t * Dau_DecFindSets( word * pInit, int nVars );
extern void Dau_DecSortSet( unsigned set, int nVars, int * pnUnique, int * pnShared, int * pnFree );
extern void Dau_DecPrintSets( Vec_Int_t * vSets, int nVars );
extern void Dau_DecPrintSet( unsigned set, int nVars, int fNewLine );


extern Dss_Man_t * Dss_ManAlloc( int nVars, int nNonDecLimit );
extern void Dss_ManFree( Dss_Man_t * p );
extern int Dss_ManMerge( Dss_Man_t * p, int * iDsd, int * nFans, int ** pFans, unsigned uSharedMask, int nKLutSize, unsigned char * pPerm, word * pTruth );
extern void Dss_ManPrint( char * pFileName, Dss_Man_t * p );



# 41 "/app/abc/src/map/if/if.h" 2
# 1 "/app/abc/src/misc/vec/vecHash.h" 1
# 31 "/app/abc/src/misc/vec/vecHash.h"

# 42 "/app/abc/src/misc/vec/vecHash.h"
typedef struct Hash_IntObj_t_ Hash_IntObj_t;
struct Hash_IntObj_t_
{
    int iData0;
    int iData1;
    int iData2;
    int iNext;
};

typedef struct Hash_IntMan_t_ Hash_IntMan_t;
struct Hash_IntMan_t_
{
    Vec_Int_t * vTable;
    Vec_Int_t * vObjs;
    int nRefs;
};





static inline Hash_IntObj_t * Hash_IntObj( Hash_IntMan_t * p, int i ) { return i ? (Hash_IntObj_t *)Vec_IntEntryP(p->vObjs, 4*i) : 
# 63 "/app/abc/src/misc/vec/vecHash.h" 3 4
                                                                                                                                            ((void *)0)
# 63 "/app/abc/src/misc/vec/vecHash.h"
                                                                                                                                                ; }
static inline int Hash_IntObjData0( Hash_IntMan_t * p, int i ) { return Hash_IntObj(p, i)->iData0; }
static inline int Hash_IntObjData1( Hash_IntMan_t * p, int i ) { return Hash_IntObj(p, i)->iData1; }
static inline int Hash_IntObjData2( Hash_IntMan_t * p, int i ) { return Hash_IntObj(p, i)->iData2; }

static inline int Hash_Int2ObjInc( Hash_IntMan_t * p, int i ) { return Hash_IntObj(p, i)->iData2++; }
static inline int Hash_Int2ObjDec( Hash_IntMan_t * p, int i ) { return --Hash_IntObj(p, i)->iData2; }
static inline void Hash_Int2ObjSetData2( Hash_IntMan_t * p, int i, int d ) { Hash_IntObj(p, i)->iData2 = d; }
# 87 "/app/abc/src/misc/vec/vecHash.h"
static inline Hash_IntMan_t * Hash_IntManStart( int nSize )
{
    Hash_IntMan_t * p; nSize += 100;
    p = ((Hash_IntMan_t *) calloc((size_t)(1), sizeof(Hash_IntMan_t)));
    p->vTable = Vec_IntStart( Abc_PrimeCudd(nSize) );
    p->vObjs = Vec_IntAlloc( 4*nSize );
    Vec_IntFill( p->vObjs, 4, 0 );
    p->nRefs = 1;
    return p;
}
static inline void Hash_IntManStop( Hash_IntMan_t * p )
{
    Vec_IntFree( p->vObjs );
    Vec_IntFree( p->vTable );
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
static inline Hash_IntMan_t * Hash_IntManRef( Hash_IntMan_t * p )
{
    p->nRefs++;
    return p;
}
static inline void Hash_IntManDeref( Hash_IntMan_t * p )
{
    if ( p == 
# 110 "/app/abc/src/misc/vec/vecHash.h" 3 4
             ((void *)0) 
# 110 "/app/abc/src/misc/vec/vecHash.h"
                  )
        return;
    if ( --p->nRefs == 0 )
        Hash_IntManStop( p );
}
static inline int Hash_IntManEntryNum( Hash_IntMan_t * p )
{
    return Vec_IntSize(p->vObjs)/4 - 1;
}
static inline void Hash_IntManProfile( Hash_IntMan_t * p )
{
    Hash_IntObj_t * pObj;
    int i, Count, Entry;
    for ( i = 0; (i < Vec_IntSize(p->vTable)) && (((Entry) = Vec_IntEntry(p->vTable, i)), 1); i++ )
    {
        Count = 0;
        for ( pObj = Hash_IntObj( p, Entry ); pObj; pObj = Hash_IntObj( p, pObj->iNext ) )
            Count++;
        printf( "%d ", Count );
    }
    printf( "\n" );
}
# 144 "/app/abc/src/misc/vec/vecHash.h"
static inline int Hash_Int2ManHash( int iData0, int iData1, int nTableSize )
{
    return (4177 * (unsigned)iData0 + 7873 * (unsigned)iData1) % (unsigned)nTableSize;
}
static inline int * Hash_Int2ManLookup( Hash_IntMan_t * p, int iData0, int iData1 )
{
    Hash_IntObj_t * pObj;
    int * pPlace = Vec_IntEntryP( p->vTable, Hash_Int2ManHash(iData0, iData1, Vec_IntSize(p->vTable)) );
    for ( ; (pObj = Hash_IntObj(p, *pPlace)); pPlace = &pObj->iNext )
        if ( pObj->iData0 == iData0 && pObj->iData1 == iData1 )
            return pPlace;
    
# 155 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ((void) sizeof ((
# 155 "/app/abc/src/misc/vec/vecHash.h"
   *pPlace == 0
# 155 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 155 "/app/abc/src/misc/vec/vecHash.h"
   *pPlace == 0
# 155 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ; else __assert_fail (
# 155 "/app/abc/src/misc/vec/vecHash.h"
   "*pPlace == 0"
# 155 "/app/abc/src/misc/vec/vecHash.h" 3 4
   , "/app/abc/src/misc/vec/vecHash.h", 155, __extension__ __PRETTY_FUNCTION__); }))
# 155 "/app/abc/src/misc/vec/vecHash.h"
                         ;
    return pPlace;
}
static inline int Hash_Int2ManInsert( Hash_IntMan_t * p, int iData0, int iData1, int iData2 )
{
    Hash_IntObj_t * pObj;
    int i, nObjs, * pPlace;
    nObjs = Vec_IntSize(p->vObjs)/4;
    if ( nObjs > Vec_IntSize(p->vTable) )
    {

        Vec_IntFill( p->vTable, Abc_PrimeCudd(2*Vec_IntSize(p->vTable)), 0 );
        for ( i = 1; i < nObjs; i++ )
        {
            pObj = Hash_IntObj( p, i );
            pObj->iNext = 0;
            pPlace = Hash_Int2ManLookup( p, pObj->iData0, pObj->iData1 );
            
# 172 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ((void) sizeof ((
# 172 "/app/abc/src/misc/vec/vecHash.h"
           *pPlace == 0
# 172 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 172 "/app/abc/src/misc/vec/vecHash.h"
           *pPlace == 0
# 172 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ) ; else __assert_fail (
# 172 "/app/abc/src/misc/vec/vecHash.h"
           "*pPlace == 0"
# 172 "/app/abc/src/misc/vec/vecHash.h" 3 4
           , "/app/abc/src/misc/vec/vecHash.h", 172, __extension__ __PRETTY_FUNCTION__); }))
# 172 "/app/abc/src/misc/vec/vecHash.h"
                                 ;
            *pPlace = i;
        }
    }
    pPlace = Hash_Int2ManLookup( p, iData0, iData1 );
    if ( *pPlace )
        return *pPlace;
    *pPlace = nObjs;
    Vec_IntPush( p->vObjs, iData0 );
    Vec_IntPush( p->vObjs, iData1 );
    Vec_IntPush( p->vObjs, iData2 );
    Vec_IntPush( p->vObjs, 0 );
    return nObjs;
}
# 198 "/app/abc/src/misc/vec/vecHash.h"
static inline int Hsh_Int3ManHash( int iData0, int iData1, int iData2, int nTableSize )
{
    return (4177 * (unsigned)iData0 + 7873 * (unsigned)iData1 + 1699 * (unsigned)iData2) % (unsigned)nTableSize;
}
static inline int * Hsh_Int3ManLookup( Hash_IntMan_t * p, int iData0, int iData1, int iData2 )
{
    Hash_IntObj_t * pObj;
    int * pPlace = Vec_IntEntryP( p->vTable, Hsh_Int3ManHash(iData0, iData1, iData2, Vec_IntSize(p->vTable)) );
    for ( ; (pObj = Hash_IntObj(p, *pPlace)); pPlace = &pObj->iNext )
        if ( pObj->iData0 == iData0 && pObj->iData1 == iData1 && pObj->iData2 == iData2 )
            return pPlace;
    
# 209 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ((void) sizeof ((
# 209 "/app/abc/src/misc/vec/vecHash.h"
   *pPlace == 0
# 209 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 209 "/app/abc/src/misc/vec/vecHash.h"
   *pPlace == 0
# 209 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ; else __assert_fail (
# 209 "/app/abc/src/misc/vec/vecHash.h"
   "*pPlace == 0"
# 209 "/app/abc/src/misc/vec/vecHash.h" 3 4
   , "/app/abc/src/misc/vec/vecHash.h", 209, __extension__ __PRETTY_FUNCTION__); }))
# 209 "/app/abc/src/misc/vec/vecHash.h"
                         ;
    return pPlace;
}
static inline int Hsh_Int3ManInsert( Hash_IntMan_t * p, int iData0, int iData1, int iData2 )
{
    Hash_IntObj_t * pObj;
    int i, nObjs, * pPlace;
    nObjs = Vec_IntSize(p->vObjs)/4;
    if ( nObjs > Vec_IntSize(p->vTable) )
    {

        Vec_IntFill( p->vTable, Abc_PrimeCudd(2*Vec_IntSize(p->vTable)), 0 );
        for ( i = 1; i < nObjs; i++ )
        {
            pObj = Hash_IntObj( p, i );
            pObj->iNext = 0;
            pPlace = Hsh_Int3ManLookup( p, pObj->iData0, pObj->iData1, pObj->iData2 );
            
# 226 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ((void) sizeof ((
# 226 "/app/abc/src/misc/vec/vecHash.h"
           *pPlace == 0
# 226 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 226 "/app/abc/src/misc/vec/vecHash.h"
           *pPlace == 0
# 226 "/app/abc/src/misc/vec/vecHash.h" 3 4
           ) ; else __assert_fail (
# 226 "/app/abc/src/misc/vec/vecHash.h"
           "*pPlace == 0"
# 226 "/app/abc/src/misc/vec/vecHash.h" 3 4
           , "/app/abc/src/misc/vec/vecHash.h", 226, __extension__ __PRETTY_FUNCTION__); }))
# 226 "/app/abc/src/misc/vec/vecHash.h"
                                 ;
            *pPlace = i;
        }
    }
    pPlace = Hsh_Int3ManLookup( p, iData0, iData1, iData2 );
    if ( *pPlace )
        return *pPlace;
    *pPlace = nObjs;
    Vec_IntPush( p->vObjs, iData0 );
    Vec_IntPush( p->vObjs, iData1 );
    Vec_IntPush( p->vObjs, iData2 );
    Vec_IntPush( p->vObjs, 0 );
    return nObjs;
}
# 252 "/app/abc/src/misc/vec/vecHash.h"
static inline void Hash_IntManHashArrayTest()
{
    Hash_IntMan_t * p;
    int RetValue;

    p = Hash_IntManStart( 10 );

    RetValue = Hash_Int2ManInsert( p, 10, 11, 12 );
    
# 260 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ((void) sizeof ((
# 260 "/app/abc/src/misc/vec/vecHash.h"
   RetValue
# 260 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 260 "/app/abc/src/misc/vec/vecHash.h"
   RetValue
# 260 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ; else __assert_fail (
# 260 "/app/abc/src/misc/vec/vecHash.h"
   "RetValue"
# 260 "/app/abc/src/misc/vec/vecHash.h" 3 4
   , "/app/abc/src/misc/vec/vecHash.h", 260, __extension__ __PRETTY_FUNCTION__); }))
# 260 "/app/abc/src/misc/vec/vecHash.h"
                     ;

    RetValue = Hash_Int2ManInsert( p, 20, 21, 22 );
    
# 263 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ((void) sizeof ((
# 263 "/app/abc/src/misc/vec/vecHash.h"
   RetValue
# 263 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 263 "/app/abc/src/misc/vec/vecHash.h"
   RetValue
# 263 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ; else __assert_fail (
# 263 "/app/abc/src/misc/vec/vecHash.h"
   "RetValue"
# 263 "/app/abc/src/misc/vec/vecHash.h" 3 4
   , "/app/abc/src/misc/vec/vecHash.h", 263, __extension__ __PRETTY_FUNCTION__); }))
# 263 "/app/abc/src/misc/vec/vecHash.h"
                     ;

    RetValue = Hash_Int2ManInsert( p, 10, 11, 12 );
    
# 266 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ((void) sizeof ((
# 266 "/app/abc/src/misc/vec/vecHash.h"
   !RetValue
# 266 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 266 "/app/abc/src/misc/vec/vecHash.h"
   !RetValue
# 266 "/app/abc/src/misc/vec/vecHash.h" 3 4
   ) ; else __assert_fail (
# 266 "/app/abc/src/misc/vec/vecHash.h"
   "!RetValue"
# 266 "/app/abc/src/misc/vec/vecHash.h" 3 4
   , "/app/abc/src/misc/vec/vecHash.h", 266, __extension__ __PRETTY_FUNCTION__); }))
# 266 "/app/abc/src/misc/vec/vecHash.h"
                      ;

    Hash_IntManStop( p );
}








# 42 "/app/abc/src/map/if/if.h" 2

# 1 "/app/abc/src/map/if/acd/ac_wrapper.h" 1
# 19 "/app/abc/src/map/if/acd/ac_wrapper.h"
       
# 31 "/app/abc/src/map/if/acd/ac_wrapper.h"
# 1 "/app/abc/src/map/if/if.h" 1
# 32 "/app/abc/src/map/if/acd/ac_wrapper.h" 2



int acd_evaluate( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned *cost, int try_no_late_arrival );
int acd_decompose( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned char *decomposition );
int acd2_evaluate( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned *cost, int try_no_late_arrival );
int acd2_decompose( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned char *decomposition );

int acdXX_evaluate( word * pTruth, unsigned lutSize, unsigned nVars );
int acdXX_decompose( word * pTruth, unsigned lutSize, unsigned nVars, unsigned char *decomposition );


# 44 "/app/abc/src/map/if/if.h" 2


# 64 "/app/abc/src/map/if/if.h"
typedef enum {
    IF_NONE,
    IF_CONST1,
    IF_CI,
    IF_CO,
    IF_AND,
    IF_VOID
} If_Type_t;





typedef struct If_Man_t_ If_Man_t;
typedef struct If_Par_t_ If_Par_t;
typedef struct If_Obj_t_ If_Obj_t;
typedef struct If_Cut_t_ If_Cut_t;
typedef struct If_Set_t_ If_Set_t;
typedef struct If_LibLut_t_ If_LibLut_t;
typedef struct If_LibBox_t_ If_LibBox_t;
typedef struct If_DsdMan_t_ If_DsdMan_t;
typedef struct Ifn_Ntk_t_ Ifn_Ntk_t;

typedef struct Ifif_Par_t_ Ifif_Par_t;
struct Ifif_Par_t_
{
    int nLutSize;
    If_LibLut_t * pLutLib;
    float pLutDelays[32];
    float DelayWire;
    int nDegree;
    int fCascade;
    int fVerbose;
    int fVeryVerbose;
};


struct If_Par_t_
{

    int nLutSize;
    int nCutsMax;
    int nFlowIters;
    int nAreaIters;
    int nGateSize;
    int nNonDecLimit;
    float DelayTarget;
    float Epsilon;
    int nRelaxRatio;
    int nStructType;
    int nAndDelay;
    int nAndArea;
    int nLutDecSize;
    int fPreprocess;
    int fArea;
    int fFancy;
    int fExpRed;
    int fLatchPaths;
    int fLut6Filter;
    int fEdge;
    int fPower;
    int fCutMin;
    int fDelayOpt;
    int fDelayOptLut;
    int fDsdBalance;
    int fUserRecLib;
    int fUserSesLib;
    int fBidec;
    int fUse34Spec;
    int fUseBat;
    int fUseBuffs;
    int fEnableCheck07;
    int fEnableCheck08;
    int fEnableCheck10;
    int fEnableCheck75;
    int fEnableCheck75u;
    int fUseDsd;
    int fUseDsdTune;
    int fUseCofVars;
    int fUseAndVars;
    int fUseTtPerm;
    int fUseCheck1;
    int fUseCheck2;
    int fDeriveLuts;
    int fDoAverage;
    int fHashMapping;
    int fUserLutDec;
    int fUserLut2D;
    int fVerbose;
    int fVerboseTrace;
    char * pLutStruct;
    int fEnableStructN;
    float WireDelay;

    int fSkipCutFilter;
    int fAreaOnly;
    int fTruth;
    int fUsePerm;
    int fUseBdds;
    int fUseSops;
    int fUseCnfs;
    int fUseMv;
    int nLatchesCi;
    int nLatchesCo;
    int nLatchesCiBox;
    int nLatchesCoBox;
    int fLiftLeaves;
    int fUseCoAttrs;
    float DelayTargetNew;
    float FinalDelay;
    float FinalArea;
    If_LibLut_t * pLutLib;
    float * pTimesArr;
    float * pTimesReq;
    int (* pFuncCost) (If_Man_t *, If_Cut_t *);
    int (* pFuncUser) (If_Man_t *, If_Obj_t *, If_Cut_t *);
    int (* pFuncCell) (If_Man_t *, unsigned *, int, int, char *);
    int (* pFuncCell2) (If_Man_t *, word *, int, Vec_Str_t *, char **);
    int (* pFuncWrite) (If_Man_t *);
    void * pReoMan;
};


struct If_LibLut_t_
{
    char * pName;
    int LutMax;
    int fVarPinDelays;
    float pLutAreas[32 +1];
    float pLutDelays[32 +1][32 +1];
};


struct If_Man_t_
{
    char * pName;

    If_Par_t * pPars;

    If_Obj_t * pConst1;
    Vec_Ptr_t * vCis;
    Vec_Ptr_t * vCos;
    Vec_Ptr_t * vObjs;
    Vec_Ptr_t * vObjsRev;
    Vec_Ptr_t * vTemp;
    int nObjs[IF_VOID];

    int nLevelMax;
    float fEpsilon;
    float RequiredGlo;
    float RequiredGlo2;
    float AreaGlo;
    int nNets;
    float dPower;
    int nCutsUsed;
    int nCutsMerged;
    unsigned * puTemp[4];
    word * puTempW;
    int SortMode;
    int fNextRound;
    int nChoices;
    Vec_Int_t * vSwitching;
    int pPerm[3][32];
    unsigned uSharedMask;
    int nShared;
    int fReqTimeWarn;

    Vec_Int_t * vCover;
    Vec_Int_t * vArray;
    Vec_Wrd_t * vAnds;
    Vec_Wrd_t * vOrGate;
    Vec_Wrd_t * vAndGate;

    Vec_Ptr_t * vLatchOrder;
    Vec_Int_t * vLags;
    int nAttempts;
    int nMaxIters;
    int Period;

    int nTruth6Words[15 +1];
    int nPermWords;
    int nObjBytes;
    int nCutBytes;
    int nSetBytes;
    Mem_Fixed_t * pMemObj;
    Mem_Fixed_t * pMemSet;
    If_Set_t * pMemCi;
    If_Set_t * pMemAnd;
    If_Set_t * pFreeList;
    int nSmallSupp;
    int nCutsTotal;
    int nCutsUseless[32];
    int nCutsCount[32];
    int nCutsCountAll;
    int nCutsUselessAll;
    int nCuts5, nCuts5a;
    If_DsdMan_t * pIfDsdMan;
    Vec_Mem_t * vTtMem[15 +1];
    Vec_Wec_t * vTtIsops[15 +1];
    Vec_Int_t * vTtDsds[15 +1];
    Vec_Str_t * vTtPerms[15 +1];
    Vec_Str_t * vTtVars[15 +1];
    Vec_Int_t * vTtDecs[15 +1];
    Vec_Int_t * vTtOccurs[15 +1];
    Hash_IntMan_t * vPairHash;
    Vec_Int_t * vPairRes;
    Vec_Str_t * vPairPerms;
    Vec_Mem_t * vTtMem6;
    char pCanonPerm[32];
    unsigned uCanonPhase;
    int nCacheHits;
    int nCacheMisses;
    abctime timeCache[6];
    int nBestCutSmall[2];
    int nCountNonDec[2];
    Vec_Int_t * vCutData;
    int pArrTimeProfile[15];
    Vec_Ptr_t * vVisited;
    void * pUserMan;
    Vec_Int_t * vDump;
    int pDumpIns[16];
    Vec_Str_t * vMarks;
    Vec_Int_t * vVisited2;


    Tim_Man_t * pManTim;
    Vec_Int_t * vCoAttrs;

    int nTableSize[2];
    int nTableEntries[2];
    void ** pHashTable[2];
    Mem_Fixed_t * pMemEntries;


};


struct If_Cut_t_
{
    float Area;
    float Edge;
    float Power;
    float Delay;
    int iCutFunc;
    int uMaskFunc;
    unsigned uSign;
    unsigned Cost : 12;
    unsigned fCompl : 1;
    unsigned fUser : 1;
    unsigned fUseless: 1;
    unsigned fAndCut : 1;
    unsigned nLimit : 8;
    unsigned nLeaves : 8;
    unsigned decDelay: 16;
    int pLeaves[0];
};


struct If_Set_t_
{
    short nCutsMax;
    short nCuts;
    If_Set_t * pNext;
    If_Cut_t ** ppCuts;
};


struct If_Obj_t_
{
    unsigned Type : 4;
    unsigned fCompl0 : 1;
    unsigned fCompl1 : 1;
    unsigned fPhase : 1;
    unsigned fRepr : 1;
    unsigned fMark : 1;
    unsigned fVisit : 1;
    unsigned fSpec : 1;
    unsigned fDriver : 1;
    unsigned fSkipCut: 1;
    unsigned Level : 19;
    int Id;
    int IdPio;
    int nRefs;
    int nVisits;
    int nVisitsCopy;
    If_Obj_t * pFanin0;
    If_Obj_t * pFanin1;
    If_Obj_t * pEquiv;
    float EstRefs;
    float Required;
    float LValue;
    union{
    void * pCopy;
    int iCopy;
    };

    If_Set_t * pCutSet;
    If_Cut_t CutBest;
};

typedef struct If_Box_t_ If_Box_t;
struct If_Box_t_
{
    char * pName;
    char fSeq;
    char fBlack;
    char fOuter;
    char fUnused;
    int Id;
    int nPis;
    int nPos;
    int * pDelays;
};

struct If_LibBox_t_
{
    int nBoxes;
    Vec_Ptr_t * vBoxes;
};

static inline If_Obj_t * If_Regular( If_Obj_t * p ) { return (If_Obj_t *)((ABC_PTRUINT_T)(p) & ~01); }
static inline If_Obj_t * If_Not( If_Obj_t * p ) { return (If_Obj_t *)((ABC_PTRUINT_T)(p) ^ 01); }
static inline If_Obj_t * If_NotCond( If_Obj_t * p, int c ) { return (If_Obj_t *)((ABC_PTRUINT_T)(p) ^ (c)); }
static inline int If_IsComplement( If_Obj_t * p ) { return (int )(((ABC_PTRUINT_T)p) & 01); }

static inline int If_ManCiNum( If_Man_t * p ) { return p->nObjs[IF_CI]; }
static inline int If_ManCoNum( If_Man_t * p ) { return p->nObjs[IF_CO]; }
static inline int If_ManAndNum( If_Man_t * p ) { return p->nObjs[IF_AND]; }
static inline int If_ManObjNum( If_Man_t * p ) { return Vec_PtrSize(p->vObjs); }

static inline If_Obj_t * If_ManConst1( If_Man_t * p ) { return p->pConst1; }
static inline If_Obj_t * If_ManCi( If_Man_t * p, int i ) { return (If_Obj_t *)Vec_PtrEntry( p->vCis, i ); }
static inline If_Obj_t * If_ManCo( If_Man_t * p, int i ) { return (If_Obj_t *)Vec_PtrEntry( p->vCos, i ); }
static inline If_Obj_t * If_ManLi( If_Man_t * p, int i ) { return (If_Obj_t *)Vec_PtrEntry( p->vCos, If_ManCoNum(p) - p->pPars->nLatchesCo + i ); }
static inline If_Obj_t * If_ManLo( If_Man_t * p, int i ) { return (If_Obj_t *)Vec_PtrEntry( p->vCis, If_ManCiNum(p) - p->pPars->nLatchesCi + i ); }
static inline If_Obj_t * If_ManObj( If_Man_t * p, int i ) { return (If_Obj_t *)Vec_PtrEntry( p->vObjs, i ); }

static inline int If_ObjIsConst1( If_Obj_t * pObj ) { return pObj->Type == IF_CONST1; }
static inline int If_ObjIsCi( If_Obj_t * pObj ) { return pObj->Type == IF_CI; }
static inline int If_ObjIsCo( If_Obj_t * pObj ) { return pObj->Type == IF_CO; }
static inline int If_ObjIsTerm( If_Obj_t * pObj ) { return pObj->Type == IF_CI || pObj->Type == IF_CO; }
static inline int If_ObjIsLatch( If_Obj_t * pObj ) { return If_ObjIsCi(pObj) && pObj->pFanin0 != 
# 405 "/app/abc/src/map/if/if.h" 3 4
                                                                                                                          ((void *)0)
# 405 "/app/abc/src/map/if/if.h"
                                                                                                                              ; }
static inline int If_ObjIsAnd( If_Obj_t * pObj ) { return pObj->Type == IF_AND; }

static inline int If_ObjId( If_Obj_t * pObj ) { return pObj->Id; }
static inline If_Obj_t * If_ObjFanin0( If_Obj_t * pObj ) { return pObj->pFanin0; }
static inline If_Obj_t * If_ObjFanin1( If_Obj_t * pObj ) { return pObj->pFanin1; }
static inline int If_ObjFaninC0( If_Obj_t * pObj ) { return pObj->fCompl0; }
static inline int If_ObjFaninC1( If_Obj_t * pObj ) { return pObj->fCompl1; }
static inline void * If_ObjCopy( If_Obj_t * pObj ) { return pObj->pCopy; }
static inline int If_ObjLevel( If_Obj_t * pObj ) { return pObj->Level; }
static inline void If_ObjSetLevel( If_Obj_t * pObj, int Level ) { pObj->Level = Level; }
static inline void If_ObjSetCopy( If_Obj_t * pObj, void * pCopy ) { pObj->pCopy = pCopy; }
static inline void If_ObjSetChoice( If_Obj_t * pObj, If_Obj_t * pEqu ) { pObj->pEquiv = pEqu; }

static inline int If_CutLeaveNum( If_Cut_t * pCut ) { return pCut->nLeaves; }
static inline int * If_CutLeaves( If_Cut_t * pCut ) { return pCut->pLeaves; }
static inline If_Obj_t * If_CutLeaf( If_Man_t * p, If_Cut_t * pCut, int i ) { 
# 421 "/app/abc/src/map/if/if.h" 3 4
                                                                              ((void) sizeof ((
# 421 "/app/abc/src/map/if/if.h"
                                                                              i >= 0 && i < (int)pCut->nLeaves
# 421 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 421 "/app/abc/src/map/if/if.h"
                                                                              i >= 0 && i < (int)pCut->nLeaves
# 421 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ; else __assert_fail (
# 421 "/app/abc/src/map/if/if.h"
                                                                              "i >= 0 && i < (int)pCut->nLeaves"
# 421 "/app/abc/src/map/if/if.h" 3 4
                                                                              , "/app/abc/src/map/if/if.h", 421, __extension__ __PRETTY_FUNCTION__); }))
# 421 "/app/abc/src/map/if/if.h"
                                                                                                                      ; return If_ManObj(p, pCut->pLeaves[i]); }
static inline unsigned If_CutSuppMask( If_Cut_t * pCut ) { return (~(unsigned)0) >> (32-pCut->nLeaves); }
static inline int If_CutTruthWords( int nVarsMax ) { return nVarsMax <= 5 ? 2 : (1 << (nVarsMax - 5)); }
static inline int If_CutPermWords( int nVarsMax ) { return nVarsMax / sizeof(int) + ((nVarsMax % sizeof(int)) > 0); }
static inline int If_CutLeafBit( If_Cut_t * pCut, int i ) { return (pCut->uMaskFunc >> i) & 1; }
static inline char * If_CutPerm( If_Cut_t * pCut ) { return (char *)(pCut->pLeaves + pCut->nLeaves); }
static inline void If_CutCopy( If_Man_t * p, If_Cut_t * pDst, If_Cut_t * pSrc ) { memcpy( pDst, pSrc, (size_t)p->nCutBytes ); }
static inline void If_CutSetup( If_Man_t * p, If_Cut_t * pCut ) { memset(pCut, 0, (size_t)p->nCutBytes); pCut->nLimit = p->pPars->nLutSize; }

static inline If_Cut_t * If_ObjCutBest( If_Obj_t * pObj ) { return &pObj->CutBest; }
static inline unsigned If_ObjCutSign( unsigned ObjId ) { return (1 << (ObjId % 31)); }
static inline unsigned If_ObjCutSignCompute( If_Cut_t * p ) { unsigned s = 0; int i; for ( i = 0; i < If_CutLeaveNum(p); i++ ) s |= If_ObjCutSign(p->pLeaves[i]); return s; }

static inline float If_ObjArrTime( If_Obj_t * pObj ) { return If_ObjCutBest(pObj)->Delay; }
static inline void If_ObjSetArrTime( If_Obj_t * pObj, float ArrTime ) { If_ObjCutBest(pObj)->Delay = ArrTime; }

static inline float If_ObjLValue( If_Obj_t * pObj ) { return pObj->LValue; }
static inline void If_ObjSetLValue( If_Obj_t * pObj, float LValue ) { pObj->LValue = LValue; }

static inline void * If_CutData( If_Cut_t * pCut ) { return *(void **)pCut; }
static inline void If_CutSetData( If_Cut_t * pCut, void * pData ) { *(void **)pCut = pData; }

static inline int If_CutDataInt( If_Cut_t * pCut ) { return *(int *)pCut; }
static inline void If_CutSetDataInt( If_Cut_t * pCut, int Data ) { *(int *)pCut = Data; }

static inline int If_CutTruthLit( If_Cut_t * pCut ) { 
# 446 "/app/abc/src/map/if/if.h" 3 4
                                                                              ((void) sizeof ((
# 446 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 446 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 446 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 446 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ; else __assert_fail (
# 446 "/app/abc/src/map/if/if.h"
                                                                              "pCut->iCutFunc >= 0"
# 446 "/app/abc/src/map/if/if.h" 3 4
                                                                              , "/app/abc/src/map/if/if.h", 446, __extension__ __PRETTY_FUNCTION__); }))
# 446 "/app/abc/src/map/if/if.h"
                                                                                                           ; return pCut->iCutFunc; }
static inline int If_CutTruthIsCompl( If_Cut_t * pCut ) { 
# 447 "/app/abc/src/map/if/if.h" 3 4
                                                                              ((void) sizeof ((
# 447 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 447 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 447 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 447 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ; else __assert_fail (
# 447 "/app/abc/src/map/if/if.h"
                                                                              "pCut->iCutFunc >= 0"
# 447 "/app/abc/src/map/if/if.h" 3 4
                                                                              , "/app/abc/src/map/if/if.h", 447, __extension__ __PRETTY_FUNCTION__); }))
# 447 "/app/abc/src/map/if/if.h"
                                                                                                           ; return Abc_LitIsCompl(pCut->iCutFunc); }
static inline word * If_CutTruthWR( If_Man_t * p, If_Cut_t * pCut ) { return p->vTtMem[pCut->nLeaves] ? Vec_MemReadEntry(p->vTtMem[pCut->nLeaves], Abc_Lit2Var(pCut->iCutFunc)) : 
# 448 "/app/abc/src/map/if/if.h" 3 4
                                                                                                                                                                                          ((void *)0)
# 448 "/app/abc/src/map/if/if.h"
                                                                                                                                                                                              ; }
static inline unsigned * If_CutTruthUR( If_Man_t * p, If_Cut_t * pCut) { return (unsigned *)If_CutTruthWR(p, pCut); }
static inline word * If_CutTruthW( If_Man_t * p, If_Cut_t * pCut ) { 
# 450 "/app/abc/src/map/if/if.h" 3 4
                                                                              ((void) sizeof ((
# 450 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 450 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ? 1 : 0), __extension__ ({ if (
# 450 "/app/abc/src/map/if/if.h"
                                                                              pCut->iCutFunc >= 0
# 450 "/app/abc/src/map/if/if.h" 3 4
                                                                              ) ; else __assert_fail (
# 450 "/app/abc/src/map/if/if.h"
                                                                              "pCut->iCutFunc >= 0"
# 450 "/app/abc/src/map/if/if.h" 3 4
                                                                              , "/app/abc/src/map/if/if.h", 450, __extension__ __PRETTY_FUNCTION__); }))
# 450 "/app/abc/src/map/if/if.h"
                                                                                                           ; Abc_TtCopy( p->puTempW, If_CutTruthWR(p, pCut), p->nTruth6Words[pCut->nLeaves], If_CutTruthIsCompl(pCut) ); return p->puTempW; }
static inline unsigned * If_CutTruth( If_Man_t * p, If_Cut_t * pCut ) { return (unsigned *)If_CutTruthW(p, pCut); }

static inline int If_CutDsdLit( If_Man_t * p, If_Cut_t * pCut ) { return Abc_Lit2LitL( Vec_IntArray(p->vTtDsds[pCut->nLeaves]), If_CutTruthLit(pCut) ); }
static inline int If_CutDsdIsCompl( If_Man_t * p, If_Cut_t * pCut ) { return Abc_LitIsCompl( If_CutDsdLit(p, pCut) ); }
static inline char * If_CutDsdPerm( If_Man_t * p, If_Cut_t * pCut ) { return Vec_StrEntryP( p->vTtPerms[pCut->nLeaves], Abc_Lit2Var(pCut->iCutFunc) * Abc_MaxInt(6, pCut->nLeaves) ); }

static inline float If_CutLutArea( If_Man_t * p, If_Cut_t * pCut ) { return pCut->fAndCut ? p->pPars->nAndArea : (pCut->fUser? (float)pCut->Cost : (p->pPars->pLutLib? p->pPars->pLutLib->pLutAreas[pCut->nLeaves] : (float)1.0)); }
static inline float If_CutLutDelay( If_LibLut_t * p, int Size, int iPin ) { return p ? (p->fVarPinDelays ? p->pLutDelays[Size][iPin] : p->pLutDelays[Size][0]) : 1.0; }
# 518 "/app/abc/src/map/if/if.h"
extern void If_ManSetDefaultPars( If_Par_t * pPars );
extern int If_ManPerformMapping( If_Man_t * p );
extern int If_ManPerformMappingComb( If_Man_t * p );
extern void If_ManComputeSwitching( If_Man_t * p );

extern int If_CutVerifyCuts( If_Set_t * pCutSet, int fOrdered );
extern int If_CutFilter( If_Set_t * pCutSet, If_Cut_t * pCut, int fSaveCut0 );
extern void If_CutSort( If_Man_t * p, If_Set_t * pCutSet, If_Cut_t * pCut );
extern void If_CutOrder( If_Cut_t * pCut );
extern int If_CutMergeOrdered( If_Man_t * p, If_Cut_t * pCut0, If_Cut_t * pCut1, If_Cut_t * pCut );
extern int If_CutMerge( If_Man_t * p, If_Cut_t * pCut0, If_Cut_t * pCut1, If_Cut_t * pCut );
extern int If_CutCheck( If_Cut_t * pCut );
extern void If_CutPrint( If_Cut_t * pCut );
extern void If_CutPrintTiming( If_Man_t * p, If_Cut_t * pCut );
extern void If_CutLift( If_Cut_t * pCut );
extern void If_CutCopy( If_Man_t * p, If_Cut_t * pCutDest, If_Cut_t * pCutSrc );
extern float If_CutAreaFlow( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutEdgeFlow( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutPowerFlow( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pRoot );
extern float If_CutAverageRefs( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutAreaDeref( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutAreaRef( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutAreaDerefed( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutAreaRefed( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutEdgeDeref( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutEdgeRef( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutEdgeDerefed( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutEdgeRefed( If_Man_t * p, If_Cut_t * pCut );
extern float If_CutPowerDeref( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pRoot );
extern float If_CutPowerRef( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pRoot );
extern float If_CutPowerDerefed( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pRoot );
extern float If_CutPowerRefed( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pRoot );

extern word If_CutPerformDerive07( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck07( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck08( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck10( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck16( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheckXX( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck45( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck54( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_CutPerformCheck75( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern float If_CutDelayLutStruct( If_Man_t * p, If_Cut_t * pCut, char * pStr, float WireDelay );

extern int If_CluCheckExt( void * p, word * pTruth, int nVars, int nLutLeaf, int nLutRoot,
                           char * pLut0, char * pLut1, word * pFunc0, word * pFunc1 );
extern int If_CluCheckExt3( void * p, word * pTruth, int nVars, int nLutLeaf, int nLutLeaf2, int nLutRoot,
                           char * pLut0, char * pLut1, char * pLut2, word * pFunc0, word * pFunc1, word * pFunc2 );
extern int If_CluCheckXXExt( void * p, word * pTruth, int nVars, int nLutLeaf, int nLutRoot,
                           char * pLut0, char * pLut1, word * pFunc0, word * pFunc1 );
extern int If_MatchCheck1( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );
extern int If_MatchCheck2( If_Man_t * p, unsigned * pTruth, int nVars, int nLeaves, char * pStr );

extern int If_CutDelaySop( If_Man_t * p, If_Cut_t * pCut );
extern int If_CutSopBalanceEvalInt( Vec_Int_t * vCover, int * pTimes, int * pFaninLits, Vec_Int_t * vAig, int * piRes, int nSuppAll, int * pArea );
extern int If_CutSopBalanceEval( If_Man_t * p, If_Cut_t * pCut, Vec_Int_t * vAig );
extern int If_CutSopBalancePinDelaysInt( Vec_Int_t * vCover, int * pTimes, word * pFaninRes, int nSuppAll, word * pRes );
extern int If_CutSopBalancePinDelays( If_Man_t * p, If_Cut_t * pCut, char * pPerm );
extern int If_CutLutBalanceEval( If_Man_t * p, If_Cut_t * pCut );
extern int If_CutLutBalancePinDelays( If_Man_t * p, If_Cut_t * pCut, char * pPerm );
extern int If_LutDecEval( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pObj, int optDelay, int fFirst );
extern int If_Lut2DecEval( If_Man_t * p, If_Cut_t * pCut, If_Obj_t * pObj, int optDelay, int fFirst );
extern int If_LutDecReEval( If_Man_t * p, If_Cut_t * pCut );
extern float If_LutDecPinRequired( If_Man_t * p, If_Cut_t * pCut, int i, float required );

extern If_DsdMan_t * If_DsdManAlloc( int nVars, int nLutSize );
extern void If_DsdManAllocIsops( If_DsdMan_t * p, int nLutSize );
extern void If_DsdManPrint( If_DsdMan_t * p, char * pFileName, int Number, int Support, int fOccurs, int fTtDump, int fVerbose );
extern void If_DsdManTune( If_DsdMan_t * p, int LutSize, int fFast, int fAdd, int fSpec, int fVerbose );
extern void Id_DsdManTuneStr( If_DsdMan_t * p, char * pStruct, int nConfls, int nProcs, int nInputs, int fVerbose );
extern void If_DsdManFree( If_DsdMan_t * p, int fVerbose );
extern void If_DsdManSave( If_DsdMan_t * p, char * pFileName );
extern If_DsdMan_t * If_DsdManLoad( char * pFileName );
extern void If_DsdManMerge( If_DsdMan_t * p, If_DsdMan_t * pNew );
extern void If_DsdManCleanOccur( If_DsdMan_t * p, int fVerbose );
extern void If_DsdManCleanMarks( If_DsdMan_t * p, int fVerbose );
extern void If_DsdManInvertMarks( If_DsdMan_t * p, int fVerbose );
extern If_DsdMan_t * If_DsdManFilter( If_DsdMan_t * p, int Limit );
extern int If_DsdManCompute( If_DsdMan_t * p, word * pTruth, int nLeaves, unsigned char * pPerm, char * pLutStruct );
extern char * If_DsdManFileName( If_DsdMan_t * p );
extern int If_DsdManVarNum( If_DsdMan_t * p );
extern int If_DsdManObjNum( If_DsdMan_t * p );
extern int If_DsdManLutSize( If_DsdMan_t * p );
extern int If_DsdManTtBitNum( If_DsdMan_t * p );
extern int If_DsdManPermBitNum( If_DsdMan_t * p );
extern void If_DsdManSetLutSize( If_DsdMan_t * p, int nLutSize );
extern int If_DsdManSuppSize( If_DsdMan_t * p, int iDsd );
extern int If_DsdManCheckDec( If_DsdMan_t * p, int iDsd );
extern int If_DsdManReadMark( If_DsdMan_t * p, int iDsd );
extern void If_DsdManSetNewAsUseless( If_DsdMan_t * p );
extern word * If_DsdManGetFuncConfig( If_DsdMan_t * p, int iDsd );
extern char * If_DsdManGetCellStr( If_DsdMan_t * p );
extern unsigned If_DsdManCheckXY( If_DsdMan_t * p, int iDsd, int LutSize, int fDerive, unsigned uMaskNot, int fHighEffort, int fVerbose );
extern int If_CutDsdBalanceEval( If_Man_t * p, If_Cut_t * pCut, Vec_Int_t * vAig );
extern int If_CutDsdBalancePinDelays( If_Man_t * p, If_Cut_t * pCut, char * pPerm );
extern void Id_DsdManTuneThresh( If_DsdMan_t * p, int fUnate, int fThresh, int fThreshHeuristic, int fVerbose );

extern If_LibLut_t * If_LibLutRead( char * FileName );
extern If_LibLut_t * If_LibLutDup( If_LibLut_t * p );
extern void If_LibLutFree( If_LibLut_t * pLutLib );
extern void If_LibLutPrint( If_LibLut_t * pLutLib );
extern int If_LibLutDelaysAreDiscrete( If_LibLut_t * pLutLib );
extern int If_LibLutDelaysAreDifferent( If_LibLut_t * pLutLib );
extern If_LibLut_t * If_LibLutSetSimple( int nLutSize );
extern float If_LibLutFastestPinDelay( If_LibLut_t * p );
extern float If_LibLutSlowestPinDelay( If_LibLut_t * p );

extern If_LibBox_t * If_LibBoxStart();
extern void If_LibBoxFree( If_LibBox_t * p );
extern int If_LibBoxNum( If_LibBox_t * p );
extern If_Box_t * If_LibBoxReadBox( If_LibBox_t * p, int Id );
extern If_Box_t * If_LibBoxFindBox( If_LibBox_t * p, char * pName );
extern void If_LibBoxAdd( If_LibBox_t * p, If_Box_t * pBox );
extern If_LibBox_t * If_LibBoxRead( char * pFileName );
extern If_LibBox_t * If_LibBoxRead2( char * pFileName );
extern void If_LibBoxPrint( FILE * pFile, If_LibBox_t * p );
extern void If_LibBoxWrite( char * pFileName, If_LibBox_t * p );
extern int If_LibBoxLoad( char * pFileName );
extern If_Box_t * If_BoxStart( char * pName, int Id, int nPis, int nPos, int fSeq, int fBlack, int fOuter );

extern If_Man_t * If_ManStart( If_Par_t * pPars );
extern void If_ManRestart( If_Man_t * p );
extern void If_ManStop( If_Man_t * p );
extern If_Obj_t * If_ManCreateCi( If_Man_t * p );
extern If_Obj_t * If_ManCreateCo( If_Man_t * p, If_Obj_t * pDriver );
extern If_Obj_t * If_ManCreateAnd( If_Man_t * p, If_Obj_t * pFan0, If_Obj_t * pFan1 );
extern If_Obj_t * If_ManCreateXor( If_Man_t * p, If_Obj_t * pFan0, If_Obj_t * pFan1 );
extern If_Obj_t * If_ManCreateMux( If_Man_t * p, If_Obj_t * pFan0, If_Obj_t * pFan1, If_Obj_t * pCtrl );
extern void If_ManCreateChoice( If_Man_t * p, If_Obj_t * pRepr );
extern void If_ManSetupCutTriv( If_Man_t * p, If_Cut_t * pCut, int ObjId );
extern void If_ManSetupCiCutSets( If_Man_t * p );
extern If_Set_t * If_ManSetupNodeCutSet( If_Man_t * p, If_Obj_t * pObj );
extern void If_ManDerefNodeCutSet( If_Man_t * p, If_Obj_t * pObj );
extern void If_ManDerefChoiceCutSet( If_Man_t * p, If_Obj_t * pObj );
extern void If_ManSetupSetAll( If_Man_t * p, int nCrossCut );

extern int * If_CutArrTimeProfile( If_Man_t * p, If_Cut_t * pCut );
extern void If_ObjPerformMappingAnd( If_Man_t * p, If_Obj_t * pObj, int Mode, int fPreprocess, int fFirst );
extern void If_ObjPerformMappingChoice( If_Man_t * p, If_Obj_t * pObj, int Mode, int fPreprocess );
extern int If_ManPerformMappingRound( If_Man_t * p, int nCutsUsed, int Mode, int fPreprocess, int fFirst, char * pLabel );

extern void If_ManImproveMapping( If_Man_t * p );

extern void * If_ManSatBuildXY( int nLutSize );
extern void * If_ManSatBuildXYZ( int nLutSize );
extern void If_ManSatUnbuild( void * p );
extern int If_ManSatCheckXY( void * pSat, int nLutSize, word * pTruth, int nVars, unsigned uSet, word * pTBound, word * pTFree, Vec_Int_t * vLits );
extern unsigned If_ManSatCheckXYall( void * pSat, int nLutSize, word * pTruth, int nVars, Vec_Int_t * vLits );

extern int If_ManPerformMappingSeq( If_Man_t * p );

extern float If_CutDelay( If_Man_t * p, If_Obj_t * pObj, If_Cut_t * pCut );
extern void If_CutPropagateRequired( If_Man_t * p, If_Obj_t * pObj, If_Cut_t * pCut, float Required );
extern float If_ManDelayMax( If_Man_t * p, int fSeq );
extern void If_ManComputeRequired( If_Man_t * p );

extern void If_CutRotatePins( If_Man_t * p, If_Cut_t * pCut );
extern int If_CutComputeTruth( If_Man_t * p, If_Cut_t * pCut, If_Cut_t * pCut0, If_Cut_t * pCut1, int fCompl0, int fCompl1 );
extern int If_CutComputeTruthPerm( If_Man_t * p, If_Cut_t * pCut, If_Cut_t * pCut0, If_Cut_t * pCut1, int fCompl0, int fCompl1 );
extern Vec_Mem_t * If_DeriveHashTable6( int nVars, word Truth );
extern int If_CutCheckTruth6( If_Man_t * p, If_Cut_t * pCut );

extern Ifn_Ntk_t * Ifn_NtkParse( char * pStr );
extern int Ifn_NtkTtBits( char * pStr );
extern int Ifn_NtkMatch( Ifn_Ntk_t * p, word * pTruth, int nVars, int nConfls, int fVerbose, int fVeryVerbose, word * pConfig );
extern void Ifn_NtkPrint( Ifn_Ntk_t * p );
extern int Ifn_NtkLutSizeMax( Ifn_Ntk_t * p );
extern int Ifn_NtkInputNum( Ifn_Ntk_t * p );
extern void * If_ManSatBuildFromCell( char * pStr, Vec_Int_t ** pvPiVars, Vec_Int_t ** pvPoVars, Ifn_Ntk_t ** ppNtk );
extern int If_ManSatFindCofigBits( void * pSat, Vec_Int_t * vPiVars, Vec_Int_t * vPoVars, word * pTruth, int nVars, word Perm, int nInps, Vec_Int_t * vValues );
extern int If_ManSatDeriveGiaFromBits( void * pNew, Ifn_Ntk_t * p, word * pTtData, Vec_Int_t * vLeaves, Vec_Int_t * vValues );
extern void * If_ManDeriveGiaFromCells( void * p );

extern void If_ManCleanNodeCopy( If_Man_t * p );
extern void If_ManCleanCutData( If_Man_t * p );
extern void If_ManCleanMarkV( If_Man_t * p );
extern float If_ManScanMapping( If_Man_t * p );
extern float If_ManScanMappingDirect( If_Man_t * p );
extern float If_ManScanMappingSeq( If_Man_t * p );
extern void If_ManResetOriginalRefs( If_Man_t * p );
extern int If_ManCrossCut( If_Man_t * p );

extern Vec_Ptr_t * If_ManReverseOrder( If_Man_t * p );
extern void If_ManMarkMapping( If_Man_t * p );
extern Vec_Ptr_t * If_ManCollectMappingDirect( If_Man_t * p );
extern Vec_Int_t * If_ManCollectMappingInt( If_Man_t * p );

extern int If_ManCountSpecialPos( If_Man_t * p );
extern void If_CutTraverse( If_Man_t * p, If_Obj_t * pRoot, If_Cut_t * pCut, Vec_Ptr_t * vNodes );
extern void If_ObjPrint( If_Obj_t * pObj );

extern int acd_evaluate( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned *cost, int try_no_late_arrival );
extern int acd_decompose( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned char *decomposition );
extern int acd2_evaluate( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned *cost, int try_no_late_arrival );
extern int acd2_decompose( word * pTruth, unsigned nVars, int lutSize, unsigned *pdelay, unsigned char *decomposition );


# 32 "/app/abc/src/base/main/mainInt.h" 2
# 1 "/app/abc/src/aig/aig/aig.h" 1
# 32 "/app/abc/src/aig/aig/aig.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/aig/aig/aig.h" 2
# 43 "/app/abc/src/aig/aig/aig.h"







typedef struct Aig_Man_t_ Aig_Man_t;
typedef struct Aig_Obj_t_ Aig_Obj_t;
typedef struct Aig_MmFixed_t_ Aig_MmFixed_t;
typedef struct Aig_MmFlex_t_ Aig_MmFlex_t;
typedef struct Aig_MmStep_t_ Aig_MmStep_t;


typedef enum {
    AIG_OBJ_NONE,
    AIG_OBJ_CONST1,
    AIG_OBJ_CI,
    AIG_OBJ_CO,
    AIG_OBJ_BUF,
    AIG_OBJ_AND,
    AIG_OBJ_EXOR,
    AIG_OBJ_VOID
} Aig_Type_t;


struct Aig_Obj_t_
{
    union {
        Aig_Obj_t * pNext;
        int CioId;
    };
    Aig_Obj_t * pFanin0;
    Aig_Obj_t * pFanin1;
    unsigned int Type : 3;
    unsigned int fPhase : 1;
    unsigned int fMarkA : 1;
    unsigned int fMarkB : 1;
    unsigned int nRefs : 26;
    unsigned Level : 24;
    unsigned nCuts : 8;
    int TravId;
    int Id;
    union {
        void * pData;
        int iData;
        float dData;
    };
};


struct Aig_Man_t_
{
    char * pName;
    char * pSpec;

    Vec_Ptr_t * vCis;
    Vec_Ptr_t * vCos;
    Vec_Ptr_t * vObjs;
    Vec_Ptr_t * vBufs;
    Aig_Obj_t * pConst1;
    Aig_Obj_t Ghost;
    int nRegs;
    int nTruePis;
    int nTruePos;
    int nAsserts;
    int nConstrs;
    int nBarBufs;

    int nObjs[AIG_OBJ_VOID];
    int nDeleted;

    Aig_Obj_t ** pTable;
    int nTableSize;

    int * pFanData;
    int nFansAlloc;
    Vec_Vec_t * vLevels;
    int nBufReplaces;
    int nBufFixes;
    int nBufMax;

    unsigned * pOrderData;
    int nOrderAlloc;
    int iPrev;
    int iNext;
    int nAndTotal;
    int nAndPrev;

    Aig_Obj_t ** pEquivs;
    Aig_Obj_t ** pReprs;
    int nReprsAlloc;

    Aig_MmFixed_t * pMemObjs;
    Vec_Int_t * vLevelR;
    int nLevelMax;
    void * pData;
    void * pData2;
    int nTravIds;
    int fCatchExor;
    int fAddStrash;
    Aig_Obj_t ** pObjCopies;
    void (*pImpFunc) (void*, void*);
    void * pImpData;
    void * pManTime;
    void * pManCuts;
    int * pFastSim;
    unsigned * pTerSimData;
    Vec_Ptr_t * vMapped;
    Vec_Int_t * vFlopNums;
    Vec_Int_t * vFlopReprs;
    Abc_Cex_t * pSeqModel;
    Vec_Ptr_t * vSeqModelVec;
    Aig_Man_t * pManExdc;
    Vec_Ptr_t * vOnehots;
    int fCreatePios;
    Vec_Int_t * vEquPairs;
    Vec_Vec_t * vClockDoms;
    Vec_Int_t * vProbs;
    Vec_Int_t * vCiNumsOrig;
    int nComplEdges;
    abctime Time2Quit;

    abctime time1;
    abctime time2;

  Vec_Ptr_t * unfold2_type_I;
  Vec_Ptr_t * unfold2_type_II;

};


typedef struct Aig_ManCut_t_ Aig_ManCut_t;
typedef struct Aig_Cut_t_ Aig_Cut_t;


struct Aig_Cut_t_
{
    Aig_Cut_t * pNext;
    int Cost;
    unsigned uSign;
    int iNode;
    short nCutSize;
    char nLeafMax;
    char nFanins;
    int pFanins[0];
};


struct Aig_ManCut_t_
{

    Aig_Man_t * pAig;
    Aig_Cut_t ** pCuts;

    int nCutsMax;
    int nLeafMax;
    int fTruth;
    int fVerbose;

    int nCutSize;
    int nTruthWords;
    Aig_MmFixed_t * pMemCuts;
    unsigned * puTemp[4];
};

static inline Aig_Cut_t * Aig_ObjCuts( Aig_ManCut_t * p, Aig_Obj_t * pObj ) { return p->pCuts[pObj->Id]; }
static inline void Aig_ObjSetCuts( Aig_ManCut_t * p, Aig_Obj_t * pObj, Aig_Cut_t * pCuts ) { p->pCuts[pObj->Id] = pCuts; }

static inline int Aig_CutLeaveNum( Aig_Cut_t * pCut ) { return pCut->nFanins; }
static inline int * Aig_CutLeaves( Aig_Cut_t * pCut ) { return pCut->pFanins; }
static inline unsigned * Aig_CutTruth( Aig_Cut_t * pCut ) { return (unsigned *)(pCut->pFanins + pCut->nLeafMax); }
static inline Aig_Cut_t * Aig_CutNext( Aig_Cut_t * pCut ) { return (Aig_Cut_t *)(((char *)pCut) + pCut->nCutSize); }
# 228 "/app/abc/src/aig/aig/aig.h"
static inline unsigned Aig_ObjCutSign( unsigned ObjId ) { return (1U << (ObjId & 31)); }
static inline int Aig_WordCountOnes( unsigned uWord )
{
    uWord = (uWord & 0x55555555) + ((uWord>>1) & 0x55555555);
    uWord = (uWord & 0x33333333) + ((uWord>>2) & 0x33333333);
    uWord = (uWord & 0x0F0F0F0F) + ((uWord>>4) & 0x0F0F0F0F);
    uWord = (uWord & 0x00FF00FF) + ((uWord>>8) & 0x00FF00FF);
    return (uWord & 0x0000FFFF) + (uWord>>16);
}
static inline int Aig_WordFindFirstBit( unsigned uWord )
{
    int i;
    for ( i = 0; i < 32; i++ )
        if ( uWord & (1 << i) )
            return i;
    return -1;
}

static inline Aig_Obj_t * Aig_Regular( Aig_Obj_t * p ) { return (Aig_Obj_t *)((ABC_PTRUINT_T)(p) & ~01); }
static inline Aig_Obj_t * Aig_Not( Aig_Obj_t * p ) { return (Aig_Obj_t *)((ABC_PTRUINT_T)(p) ^ 01); }
static inline Aig_Obj_t * Aig_NotCond( Aig_Obj_t * p, int c ) { return (Aig_Obj_t *)((ABC_PTRUINT_T)(p) ^ (c)); }
static inline int Aig_IsComplement( Aig_Obj_t * p ) { return (int)((ABC_PTRUINT_T)(p) & 01); }

static inline int Aig_ManCiNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_CI]; }
static inline int Aig_ManCoNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_CO]; }
static inline int Aig_ManBufNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_BUF]; }
static inline int Aig_ManAndNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_AND]; }
static inline int Aig_ManExorNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_EXOR]; }
static inline int Aig_ManNodeNum( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_AND]+p->nObjs[AIG_OBJ_EXOR]; }
static inline int Aig_ManGetCost( Aig_Man_t * p ) { return p->nObjs[AIG_OBJ_AND]+3*p->nObjs[AIG_OBJ_EXOR]; }
static inline int Aig_ManObjNum( Aig_Man_t * p ) { return Vec_PtrSize(p->vObjs) - p->nDeleted; }
static inline int Aig_ManObjNumMax( Aig_Man_t * p ) { return Vec_PtrSize(p->vObjs); }
static inline int Aig_ManRegNum( Aig_Man_t * p ) { return p->nRegs; }
static inline int Aig_ManConstrNum( Aig_Man_t * p ) { return p->nConstrs; }

static inline Aig_Obj_t * Aig_ManConst0( Aig_Man_t * p ) { return Aig_Not(p->pConst1); }
static inline Aig_Obj_t * Aig_ManConst1( Aig_Man_t * p ) { return p->pConst1; }
static inline Aig_Obj_t * Aig_ManGhost( Aig_Man_t * p ) { return &p->Ghost; }
static inline Aig_Obj_t * Aig_ManCi( Aig_Man_t * p, int i ) { return (Aig_Obj_t *)Vec_PtrEntry(p->vCis, i); }
static inline Aig_Obj_t * Aig_ManCo( Aig_Man_t * p, int i ) { return (Aig_Obj_t *)Vec_PtrEntry(p->vCos, i); }
static inline Aig_Obj_t * Aig_ManLo( Aig_Man_t * p, int i ) { return (Aig_Obj_t *)Vec_PtrEntry(p->vCis, Aig_ManCiNum(p)-Aig_ManRegNum(p)+i); }
static inline Aig_Obj_t * Aig_ManLi( Aig_Man_t * p, int i ) { return (Aig_Obj_t *)Vec_PtrEntry(p->vCos, Aig_ManCoNum(p)-Aig_ManRegNum(p)+i); }
static inline Aig_Obj_t * Aig_ManObj( Aig_Man_t * p, int i ) { return p->vObjs ? (Aig_Obj_t *)Vec_PtrEntry(p->vObjs, i) : 
# 270 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                              ((void *)0)
# 270 "/app/abc/src/aig/aig/aig.h"
                                                                                                                                  ; }

static inline Aig_Type_t Aig_ObjType( Aig_Obj_t * pObj ) { return (Aig_Type_t)pObj->Type; }
static inline int Aig_ObjIsNone( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_NONE; }
static inline int Aig_ObjIsConst1( Aig_Obj_t * pObj ) { 
# 274 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 274 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 274 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 274 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 274 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 274 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 274 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 274, __extension__ __PRETTY_FUNCTION__); }))
# 274 "/app/abc/src/aig/aig/aig.h"
                                                                                                  ; return pObj->Type == AIG_OBJ_CONST1; }
static inline int Aig_ObjIsCi( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_CI; }
static inline int Aig_ObjIsCo( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_CO; }
static inline int Aig_ObjIsBuf( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_BUF; }
static inline int Aig_ObjIsAnd( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_AND; }
static inline int Aig_ObjIsExor( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_EXOR; }
static inline int Aig_ObjIsNode( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_AND || pObj->Type == AIG_OBJ_EXOR; }
static inline int Aig_ObjIsTerm( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_CI || pObj->Type == AIG_OBJ_CO || pObj->Type == AIG_OBJ_CONST1; }
static inline int Aig_ObjIsHash( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_AND || pObj->Type == AIG_OBJ_EXOR; }
static inline int Aig_ObjIsChoice( Aig_Man_t * p, Aig_Obj_t * pObj ) { return p->pEquivs && p->pEquivs[pObj->Id] && pObj->nRefs > 0; }
static inline int Aig_ObjIsCand( Aig_Obj_t * pObj ) { return pObj->Type == AIG_OBJ_CI || pObj->Type == AIG_OBJ_AND || pObj->Type == AIG_OBJ_EXOR; }
static inline int Aig_ObjCioId( Aig_Obj_t * pObj ) { 
# 285 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 285 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_ObjIsNode(pObj)
# 285 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 285 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_ObjIsNode(pObj)
# 285 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 285 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_ObjIsNode(pObj)"
# 285 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 285, __extension__ __PRETTY_FUNCTION__); }))
# 285 "/app/abc/src/aig/aig/aig.h"
                                                                                                 ; return pObj->CioId; }
static inline int Aig_ObjId( Aig_Obj_t * pObj ) { return pObj->Id; }

static inline int Aig_ObjIsMarkA( Aig_Obj_t * pObj ) { return pObj->fMarkA; }
static inline void Aig_ObjSetMarkA( Aig_Obj_t * pObj ) { pObj->fMarkA = 1; }
static inline void Aig_ObjClearMarkA( Aig_Obj_t * pObj ) { pObj->fMarkA = 0; }

static inline void Aig_ObjSetTravId( Aig_Obj_t * pObj, int TravId ) { pObj->TravId = TravId; }
static inline void Aig_ObjSetTravIdCurrent( Aig_Man_t * p, Aig_Obj_t * pObj ) { pObj->TravId = p->nTravIds; }
static inline void Aig_ObjSetTravIdPrevious( Aig_Man_t * p, Aig_Obj_t * pObj ) { pObj->TravId = p->nTravIds - 1; }
static inline int Aig_ObjIsTravIdCurrent( Aig_Man_t * p, Aig_Obj_t * pObj ) { return (int)(pObj->TravId == p->nTravIds); }
static inline int Aig_ObjIsTravIdPrevious( Aig_Man_t * p, Aig_Obj_t * pObj ) { return (int)(pObj->TravId == p->nTravIds - 1); }

static inline int Aig_ObjPhase( Aig_Obj_t * pObj ) { return pObj->fPhase; }
static inline int Aig_ObjPhaseReal( Aig_Obj_t * pObj ) { return pObj? Aig_Regular(pObj)->fPhase ^ Aig_IsComplement(pObj) : 1; }
static inline int Aig_ObjRefs( Aig_Obj_t * pObj ) { return pObj->nRefs; }
static inline void Aig_ObjRef( Aig_Obj_t * pObj ) { pObj->nRefs++; }
static inline void Aig_ObjDeref( Aig_Obj_t * pObj ) { 
# 302 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 302 "/app/abc/src/aig/aig/aig.h"
                                                                   pObj->nRefs > 0
# 302 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 302 "/app/abc/src/aig/aig/aig.h"
                                                                   pObj->nRefs > 0
# 302 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 302 "/app/abc/src/aig/aig/aig.h"
                                                                   "pObj->nRefs > 0"
# 302 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 302, __extension__ __PRETTY_FUNCTION__); }))
# 302 "/app/abc/src/aig/aig/aig.h"
                                                                                            ; pObj->nRefs--; }
static inline void Aig_ObjClearRef( Aig_Obj_t * pObj ) { pObj->nRefs = 0; }
static inline int Aig_ObjFaninId0( Aig_Obj_t * pObj ) { return pObj->pFanin0? Aig_Regular(pObj->pFanin0)->Id : -1; }
static inline int Aig_ObjFaninId1( Aig_Obj_t * pObj ) { return pObj->pFanin1? Aig_Regular(pObj->pFanin1)->Id : -1; }
static inline int Aig_ObjFaninC0( Aig_Obj_t * pObj ) { return Aig_IsComplement(pObj->pFanin0); }
static inline int Aig_ObjFaninC1( Aig_Obj_t * pObj ) { return Aig_IsComplement(pObj->pFanin1); }
static inline Aig_Obj_t * Aig_ObjFanin0( Aig_Obj_t * pObj ) { return Aig_Regular(pObj->pFanin0); }
static inline Aig_Obj_t * Aig_ObjFanin1( Aig_Obj_t * pObj ) { return Aig_Regular(pObj->pFanin1); }
static inline Aig_Obj_t * Aig_ObjChild0( Aig_Obj_t * pObj ) { return pObj->pFanin0; }
static inline Aig_Obj_t * Aig_ObjChild1( Aig_Obj_t * pObj ) { return pObj->pFanin1; }
static inline Aig_Obj_t * Aig_ObjChild0Copy( Aig_Obj_t * pObj ) { 
# 312 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 312 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 312 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 312 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 312 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 312 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 312 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 312, __extension__ __PRETTY_FUNCTION__); }))
# 312 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return Aig_ObjFanin0(pObj)? Aig_NotCond((Aig_Obj_t *)Aig_ObjFanin0(pObj)->pData, Aig_ObjFaninC0(pObj)) : 
# 312 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 312 "/app/abc/src/aig/aig/aig.h"
                                                                                                                                                                                                                   ; }
static inline Aig_Obj_t * Aig_ObjChild1Copy( Aig_Obj_t * pObj ) { 
# 313 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 313 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 313 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 313 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 313 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 313 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 313 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 313, __extension__ __PRETTY_FUNCTION__); }))
# 313 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return Aig_ObjFanin1(pObj)? Aig_NotCond((Aig_Obj_t *)Aig_ObjFanin1(pObj)->pData, Aig_ObjFaninC1(pObj)) : 
# 313 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 313 "/app/abc/src/aig/aig/aig.h"
                                                                                                                                                                                                                   ; }
static inline Aig_Obj_t * Aig_ObjChild0Next( Aig_Obj_t * pObj ) { 
# 314 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 314 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 314 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 314 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 314 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 314 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 314 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 314, __extension__ __PRETTY_FUNCTION__); }))
# 314 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return Aig_ObjFanin0(pObj)? Aig_NotCond((Aig_Obj_t *)Aig_ObjFanin0(pObj)->pNext, Aig_ObjFaninC0(pObj)) : 
# 314 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 314 "/app/abc/src/aig/aig/aig.h"
                                                                                                                                                                                                                   ; }
static inline Aig_Obj_t * Aig_ObjChild1Next( Aig_Obj_t * pObj ) { 
# 315 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 315 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 315 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 315 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 315 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 315 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 315 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 315, __extension__ __PRETTY_FUNCTION__); }))
# 315 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return Aig_ObjFanin1(pObj)? Aig_NotCond((Aig_Obj_t *)Aig_ObjFanin1(pObj)->pNext, Aig_ObjFaninC1(pObj)) : 
# 315 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                                                                                                               ((void *)0)
# 315 "/app/abc/src/aig/aig/aig.h"
                                                                                                                                                                                                                   ; }
static inline void Aig_ObjChild0Flip( Aig_Obj_t * pObj ) { 
# 316 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 316 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 316 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 316 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 316 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 316 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 316 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 316, __extension__ __PRETTY_FUNCTION__); }))
# 316 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; pObj->pFanin0 = Aig_Not(pObj->pFanin0); }
static inline void Aig_ObjChild1Flip( Aig_Obj_t * pObj ) { 
# 317 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 317 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 317 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 317 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 317 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 317 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 317 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 317, __extension__ __PRETTY_FUNCTION__); }))
# 317 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; pObj->pFanin1 = Aig_Not(pObj->pFanin1); }
static inline Aig_Obj_t * Aig_ObjCopy( Aig_Obj_t * pObj ) { 
# 318 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 318 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 318 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 318 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 318 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 318 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 318 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 318, __extension__ __PRETTY_FUNCTION__); }))
# 318 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return (Aig_Obj_t *)pObj->pData; }
static inline void Aig_ObjSetCopy( Aig_Obj_t * pObj, Aig_Obj_t * pCopy ) { 
# 319 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                       ((void) sizeof ((
# 319 "/app/abc/src/aig/aig/aig.h"
                                                                                       !Aig_IsComplement(pObj)
# 319 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                       ) ? 1 : 0), __extension__ ({ if (
# 319 "/app/abc/src/aig/aig/aig.h"
                                                                                       !Aig_IsComplement(pObj)
# 319 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                       ) ; else __assert_fail (
# 319 "/app/abc/src/aig/aig/aig.h"
                                                                                       "!Aig_IsComplement(pObj)"
# 319 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                       , "/app/abc/src/aig/aig/aig.h", 319, __extension__ __PRETTY_FUNCTION__); }))
# 319 "/app/abc/src/aig/aig/aig.h"
                                                                                                                        ; pObj->pData = pCopy; }
static inline Aig_Obj_t * Aig_ObjRealCopy( Aig_Obj_t * pObj ) { return Aig_NotCond((Aig_Obj_t *)Aig_Regular(pObj)->pData, Aig_IsComplement(pObj));}
static inline int Aig_ObjToLit( Aig_Obj_t * pObj ) { return Abc_Var2Lit( Aig_ObjId(Aig_Regular(pObj)), Aig_IsComplement(pObj) ); }
static inline Aig_Obj_t * Aig_ObjFromLit( Aig_Man_t * p,int iLit){ return Aig_NotCond( Aig_ManObj(p, Abc_Lit2Var(iLit)), Abc_LitIsCompl(iLit) ); }
static inline int Aig_ObjLevel( Aig_Obj_t * pObj ) { 
# 323 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 323 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 323 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 323 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 323 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 323 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 323 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 323, __extension__ __PRETTY_FUNCTION__); }))
# 323 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return pObj->Level; }
static inline int Aig_ObjLevelNew( Aig_Obj_t * pObj ) { 
# 324 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ((void) sizeof ((
# 324 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 324 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ? 1 : 0), __extension__ ({ if (
# 324 "/app/abc/src/aig/aig/aig.h"
                                                                   !Aig_IsComplement(pObj)
# 324 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   ) ; else __assert_fail (
# 324 "/app/abc/src/aig/aig/aig.h"
                                                                   "!Aig_IsComplement(pObj)"
# 324 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                   , "/app/abc/src/aig/aig/aig.h", 324, __extension__ __PRETTY_FUNCTION__); }))
# 324 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return Aig_ObjFanin1(pObj)? 1 + Aig_ObjIsExor(pObj) + Abc_MaxInt(Aig_ObjFanin0(pObj)->Level, Aig_ObjFanin1(pObj)->Level) : Aig_ObjFanin0(pObj)->Level; }
static inline int Aig_ObjSetLevel( Aig_Obj_t * pObj, int i ) { 
# 325 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                       ((void) sizeof ((
# 325 "/app/abc/src/aig/aig/aig.h"
                                                                       !Aig_IsComplement(pObj)
# 325 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                       ) ? 1 : 0), __extension__ ({ if (
# 325 "/app/abc/src/aig/aig/aig.h"
                                                                       !Aig_IsComplement(pObj)
# 325 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                       ) ; else __assert_fail (
# 325 "/app/abc/src/aig/aig/aig.h"
                                                                       "!Aig_IsComplement(pObj)"
# 325 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                       , "/app/abc/src/aig/aig/aig.h", 325, __extension__ __PRETTY_FUNCTION__); }))
# 325 "/app/abc/src/aig/aig/aig.h"
                                                                                                        ; return pObj->Level = i; }
static inline void Aig_ObjClean( Aig_Obj_t * pObj ) { memset( pObj, 0, sizeof(Aig_Obj_t) ); }
static inline Aig_Obj_t * Aig_ObjFanout0( Aig_Man_t * p, Aig_Obj_t * pObj ) { 
# 327 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                               ((void) sizeof ((
# 327 "/app/abc/src/aig/aig/aig.h"
                                                                               p->pFanData && pObj->Id < p->nFansAlloc
# 327 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                               ) ? 1 : 0), __extension__ ({ if (
# 327 "/app/abc/src/aig/aig/aig.h"
                                                                               p->pFanData && pObj->Id < p->nFansAlloc
# 327 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                               ) ; else __assert_fail (
# 327 "/app/abc/src/aig/aig/aig.h"
                                                                               "p->pFanData && pObj->Id < p->nFansAlloc"
# 327 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                               , "/app/abc/src/aig/aig/aig.h", 327, __extension__ __PRETTY_FUNCTION__); }))
# 327 "/app/abc/src/aig/aig/aig.h"
                                                                                                                              ; return Aig_ManObj(p, p->pFanData[5*pObj->Id] >> 1); }
static inline Aig_Obj_t * Aig_ObjEquiv( Aig_Man_t * p, Aig_Obj_t * pObj ) { return p->pEquivs? p->pEquivs[pObj->Id] : 
# 328 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                         ((void *)0)
# 328 "/app/abc/src/aig/aig/aig.h"
                                                                                                                             ; }
static inline void Aig_ObjSetEquiv( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pEqu ) { 
# 329 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                 ((void) sizeof ((
# 329 "/app/abc/src/aig/aig/aig.h"
                                                                                                 p->pEquivs
# 329 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                 ) ? 1 : 0), __extension__ ({ if (
# 329 "/app/abc/src/aig/aig/aig.h"
                                                                                                 p->pEquivs
# 329 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                 ) ; else __assert_fail (
# 329 "/app/abc/src/aig/aig/aig.h"
                                                                                                 "p->pEquivs"
# 329 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                 , "/app/abc/src/aig/aig/aig.h", 329, __extension__ __PRETTY_FUNCTION__); }))
# 329 "/app/abc/src/aig/aig/aig.h"
                                                                                                                   ; p->pEquivs[pObj->Id] = pEqu; }
static inline Aig_Obj_t * Aig_ObjRepr( Aig_Man_t * p, Aig_Obj_t * pObj ) { return p->pReprs? p->pReprs[pObj->Id] : 
# 330 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                                       ((void *)0)
# 330 "/app/abc/src/aig/aig/aig.h"
                                                                                                                           ; }
static inline void Aig_ObjSetRepr( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pRepr ) { 
# 331 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                     ((void) sizeof ((
# 331 "/app/abc/src/aig/aig/aig.h"
                                                                                                     p->pReprs
# 331 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                     ) ? 1 : 0), __extension__ ({ if (
# 331 "/app/abc/src/aig/aig/aig.h"
                                                                                                     p->pReprs
# 331 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                     ) ; else __assert_fail (
# 331 "/app/abc/src/aig/aig/aig.h"
                                                                                                     "p->pReprs"
# 331 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                                                     , "/app/abc/src/aig/aig/aig.h", 331, __extension__ __PRETTY_FUNCTION__); }))
# 331 "/app/abc/src/aig/aig/aig.h"
                                                                                                                      ; p->pReprs[pObj->Id] = pRepr; }
static inline int Aig_ObjWhatFanin( Aig_Obj_t * pObj, Aig_Obj_t * pFanin )
{
    if ( Aig_ObjFanin0(pObj) == pFanin ) return 0;
    if ( Aig_ObjFanin1(pObj) == pFanin ) return 1;
    
# 336 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 336 "/app/abc/src/aig/aig/aig.h"
   0
# 336 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 336 "/app/abc/src/aig/aig/aig.h"
   0
# 336 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 336 "/app/abc/src/aig/aig/aig.h"
   "0"
# 336 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 336, __extension__ __PRETTY_FUNCTION__); }))
# 336 "/app/abc/src/aig/aig/aig.h"
            ; return -1;
}
static inline int Aig_ObjFanoutC( Aig_Obj_t * pObj, Aig_Obj_t * pFanout )
{
    if ( Aig_ObjFanin0(pFanout) == pObj ) return Aig_ObjFaninC0(pObj);
    if ( Aig_ObjFanin1(pFanout) == pObj ) return Aig_ObjFaninC1(pObj);
    
# 342 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 342 "/app/abc/src/aig/aig/aig.h"
   0
# 342 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 342 "/app/abc/src/aig/aig/aig.h"
   0
# 342 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 342 "/app/abc/src/aig/aig/aig.h"
   "0"
# 342 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 342, __extension__ __PRETTY_FUNCTION__); }))
# 342 "/app/abc/src/aig/aig/aig.h"
            ; return -1;
}


static inline Aig_Obj_t * Aig_ObjCreateGhost( Aig_Man_t * p, Aig_Obj_t * p0, Aig_Obj_t * p1, Aig_Type_t Type )
{
    Aig_Obj_t * pGhost;
    
# 349 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 349 "/app/abc/src/aig/aig/aig.h"
   Type != AIG_OBJ_AND || !Aig_ObjIsConst1(Aig_Regular(p0))
# 349 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 349 "/app/abc/src/aig/aig/aig.h"
   Type != AIG_OBJ_AND || !Aig_ObjIsConst1(Aig_Regular(p0))
# 349 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 349 "/app/abc/src/aig/aig/aig.h"
   "Type != AIG_OBJ_AND || !Aig_ObjIsConst1(Aig_Regular(p0))"
# 349 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 349, __extension__ __PRETTY_FUNCTION__); }))
# 349 "/app/abc/src/aig/aig/aig.h"
                                                                     ;
    
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 350 "/app/abc/src/aig/aig/aig.h"
   p1 == 
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void *)0) 
# 350 "/app/abc/src/aig/aig/aig.h"
   || !Aig_ObjIsConst1(Aig_Regular(p1))
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 350 "/app/abc/src/aig/aig/aig.h"
   p1 == 
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void *)0) 
# 350 "/app/abc/src/aig/aig/aig.h"
   || !Aig_ObjIsConst1(Aig_Regular(p1))
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 350 "/app/abc/src/aig/aig/aig.h"
   "p1 == NULL || !Aig_ObjIsConst1(Aig_Regular(p1))"
# 350 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 350, __extension__ __PRETTY_FUNCTION__); }))
# 350 "/app/abc/src/aig/aig/aig.h"
                                                            ;
    
# 351 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 351 "/app/abc/src/aig/aig/aig.h"
   Type == AIG_OBJ_CI || Aig_Regular(p0) != Aig_Regular(p1)
# 351 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 351 "/app/abc/src/aig/aig/aig.h"
   Type == AIG_OBJ_CI || Aig_Regular(p0) != Aig_Regular(p1)
# 351 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 351 "/app/abc/src/aig/aig/aig.h"
   "Type == AIG_OBJ_CI || Aig_Regular(p0) != Aig_Regular(p1)"
# 351 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 351, __extension__ __PRETTY_FUNCTION__); }))
# 351 "/app/abc/src/aig/aig/aig.h"
                                                                     ;
    pGhost = Aig_ManGhost(p);
    pGhost->Type = Type;
    if ( p1 == 
# 354 "/app/abc/src/aig/aig/aig.h" 3 4
              ((void *)0) 
# 354 "/app/abc/src/aig/aig/aig.h"
                   || Aig_Regular(p0)->Id < Aig_Regular(p1)->Id )
    {
        pGhost->pFanin0 = p0;
        pGhost->pFanin1 = p1;
    }
    else
    {
        pGhost->pFanin0 = p1;
        pGhost->pFanin1 = p0;
    }
    return pGhost;
}


static inline Aig_Obj_t * Aig_ManFetchMemory( Aig_Man_t * p )
{
    extern char * Aig_MmFixedEntryFetch( Aig_MmFixed_t * p );
    Aig_Obj_t * pTemp;
    pTemp = (Aig_Obj_t *)Aig_MmFixedEntryFetch( p->pMemObjs );
    memset( pTemp, 0, sizeof(Aig_Obj_t) );
    pTemp->Id = Vec_PtrSize(p->vObjs);
    Vec_PtrPush( p->vObjs, pTemp );
    return pTemp;
}
static inline void Aig_ManRecycleMemory( Aig_Man_t * p, Aig_Obj_t * pEntry )
{
    extern void Aig_MmFixedEntryRecycle( Aig_MmFixed_t * p, char * pEntry );
    
# 381 "/app/abc/src/aig/aig/aig.h" 3 4
   ((void) sizeof ((
# 381 "/app/abc/src/aig/aig/aig.h"
   pEntry->nRefs == 0
# 381 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 381 "/app/abc/src/aig/aig/aig.h"
   pEntry->nRefs == 0
# 381 "/app/abc/src/aig/aig/aig.h" 3 4
   ) ; else __assert_fail (
# 381 "/app/abc/src/aig/aig/aig.h"
   "pEntry->nRefs == 0"
# 381 "/app/abc/src/aig/aig/aig.h" 3 4
   , "/app/abc/src/aig/aig/aig.h", 381, __extension__ __PRETTY_FUNCTION__); }))
# 381 "/app/abc/src/aig/aig/aig.h"
                               ;
    pEntry->Type = AIG_OBJ_NONE;
    Aig_MmFixedEntryRecycle( p->pMemObjs, (char *)pEntry );
    p->nDeleted++;
}
# 424 "/app/abc/src/aig/aig/aig.h"
static inline int Aig_ObjFanout0Int( Aig_Man_t * p, int ObjId ) { 
# 424 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ((void) sizeof ((
# 424 "/app/abc/src/aig/aig/aig.h"
                                                                      ObjId < p->nFansAlloc
# 424 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ) ? 1 : 0), __extension__ ({ if (
# 424 "/app/abc/src/aig/aig/aig.h"
                                                                      ObjId < p->nFansAlloc
# 424 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ) ; else __assert_fail (
# 424 "/app/abc/src/aig/aig/aig.h"
                                                                      "ObjId < p->nFansAlloc"
# 424 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      , "/app/abc/src/aig/aig/aig.h", 424, __extension__ __PRETTY_FUNCTION__); }))
# 424 "/app/abc/src/aig/aig/aig.h"
                                                                                                   ; return p->pFanData[5*ObjId]; }
static inline int Aig_ObjFanoutNext( Aig_Man_t * p, int iFan ) { 
# 425 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ((void) sizeof ((
# 425 "/app/abc/src/aig/aig/aig.h"
                                                                      iFan/2 < p->nFansAlloc
# 425 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ) ? 1 : 0), __extension__ ({ if (
# 425 "/app/abc/src/aig/aig/aig.h"
                                                                      iFan/2 < p->nFansAlloc
# 425 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      ) ; else __assert_fail (
# 425 "/app/abc/src/aig/aig/aig.h"
                                                                      "iFan/2 < p->nFansAlloc"
# 425 "/app/abc/src/aig/aig/aig.h" 3 4
                                                                      , "/app/abc/src/aig/aig/aig.h", 425, __extension__ __PRETTY_FUNCTION__); }))
# 425 "/app/abc/src/aig/aig/aig.h"
                                                                                                    ; return p->pFanData[5*(iFan >> 1) + 3 + (iFan & 1)]; }
# 459 "/app/abc/src/aig/aig/aig.h"
extern int Aig_ManCheck( Aig_Man_t * p );
extern void Aig_ManCheckMarkA( Aig_Man_t * p );
extern void Aig_ManCheckPhase( Aig_Man_t * p );

extern Aig_ManCut_t * Aig_ComputeCuts( Aig_Man_t * pAig, int nCutsMax, int nLeafMax, int fTruth, int fVerbose );
extern void Aig_ManCutStop( Aig_ManCut_t * p );

extern int Aig_ManVerifyTopoOrder( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManDfs( Aig_Man_t * p, int fNodesOnly );
extern Vec_Ptr_t * Aig_ManDfsAll( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManDfsPreorder( Aig_Man_t * p, int fNodesOnly );
extern Vec_Vec_t * Aig_ManLevelize( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManDfsNodes( Aig_Man_t * p, Aig_Obj_t ** ppNodes, int nNodes );
extern Vec_Ptr_t * Aig_ManDfsChoices( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManDfsReverse( Aig_Man_t * p );
extern int Aig_ManLevelNum( Aig_Man_t * p );
extern int Aig_ManChoiceLevel( Aig_Man_t * p );
extern int Aig_DagSize( Aig_Obj_t * pObj );
extern int Aig_SupportSize( Aig_Man_t * p, Aig_Obj_t * pObj );
extern Vec_Ptr_t * Aig_Support( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_SupportNodes( Aig_Man_t * p, Aig_Obj_t ** ppObjs, int nObjs, Vec_Ptr_t * vSupp );
extern void Aig_ConeUnmark_rec( Aig_Obj_t * pObj );
extern Aig_Obj_t * Aig_Transfer( Aig_Man_t * pSour, Aig_Man_t * pDest, Aig_Obj_t * pObj, int nVars );
extern Aig_Obj_t * Aig_Compose( Aig_Man_t * p, Aig_Obj_t * pRoot, Aig_Obj_t * pFunc, int iVar );
extern void Aig_ObjCollectCut( Aig_Obj_t * pRoot, Vec_Ptr_t * vLeaves, Vec_Ptr_t * vNodes );
extern int Aig_ObjCollectSuper( Aig_Obj_t * pObj, Vec_Ptr_t * vSuper );

extern Aig_Obj_t * Aig_ManDupSimpleDfs_rec( Aig_Man_t * pNew, Aig_Man_t * p, Aig_Obj_t * pObj );
extern Aig_Man_t * Aig_ManDupSimple( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupSimpleWithHints( Aig_Man_t * p, Vec_Int_t * vHints );
extern Aig_Man_t * Aig_ManDupSimpleDfs( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupSimpleDfsPart( Aig_Man_t * p, Vec_Ptr_t * vPis, Vec_Ptr_t * vCos );
extern Aig_Man_t * Aig_ManDupOrdered( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupCof( Aig_Man_t * p, int iInput, int Value );
extern Aig_Man_t * Aig_ManDupTrim( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupExor( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupDfs( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManOrderPios( Aig_Man_t * p, Aig_Man_t * pOrder );
extern Aig_Man_t * Aig_ManDupDfsGuided( Aig_Man_t * p, Vec_Ptr_t * vPios );
extern Aig_Man_t * Aig_ManDupLevelized( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupWithoutPos( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupFlopsOnly( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupRepres( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupRepresDfs( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManCreateMiter( Aig_Man_t * p1, Aig_Man_t * p2, int fImpl );
extern Aig_Man_t * Aig_ManDupOrpos( Aig_Man_t * p, int fAddRegs );
extern Aig_Man_t * Aig_ManDupOneOutput( Aig_Man_t * p, int iPoNum, int fAddRegs );
extern Aig_Man_t * Aig_ManDupUnsolvedOutputs( Aig_Man_t * p, int fAddRegs );
extern Aig_Man_t * Aig_ManDupArray( Vec_Ptr_t * vArray );
extern Aig_Man_t * Aig_ManDupNodes( Aig_Man_t * pMan, Vec_Ptr_t * vArray );

extern void Aig_ObjAddFanout( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pFanout );
extern void Aig_ObjRemoveFanout( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pFanout );
extern void Aig_ManFanoutStart( Aig_Man_t * p );
extern void Aig_ManFanoutStop( Aig_Man_t * p );

extern Aig_Man_t * Aig_ManFrames( Aig_Man_t * pAig, int nFs, int fInit, int fOuts, int fRegs, int fEnlarge, Aig_Obj_t *** ppObjMap );

extern Aig_Man_t * Aig_ManStart( int nNodesMax );
extern Aig_Man_t * Aig_ManStartFrom( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManExtractMiter( Aig_Man_t * p, Aig_Obj_t * pNode1, Aig_Obj_t * pNode2 );
extern void Aig_ManStop( Aig_Man_t * p );
extern void Aig_ManStopP( Aig_Man_t ** p );
extern int Aig_ManCleanup( Aig_Man_t * p );
extern int Aig_ManAntiCleanup( Aig_Man_t * p );
extern int Aig_ManCiCleanup( Aig_Man_t * p );
extern int Aig_ManCoCleanup( Aig_Man_t * p );
extern void Aig_ManPrintStats( Aig_Man_t * p );
extern void Aig_ManReportImprovement( Aig_Man_t * p, Aig_Man_t * pNew );
extern void Aig_ManSetRegNum( Aig_Man_t * p, int nRegs );
extern void Aig_ManFlipFirstPo( Aig_Man_t * p );
extern void * Aig_ManReleaseData( Aig_Man_t * p );

extern void Aig_ManStartMemory( Aig_Man_t * p );
extern void Aig_ManStopMemory( Aig_Man_t * p );

extern int Aig_NodeRef_rec( Aig_Obj_t * pNode, unsigned LevelMin );
extern int Aig_NodeDeref_rec( Aig_Obj_t * pNode, unsigned LevelMin, float * pPower, float * pProbs );
extern int Aig_NodeMffcSupp( Aig_Man_t * p, Aig_Obj_t * pNode, int LevelMin, Vec_Ptr_t * vSupp );
extern int Aig_NodeMffcLabel( Aig_Man_t * p, Aig_Obj_t * pNode, float * pPower );
extern int Aig_NodeMffcLabelCut( Aig_Man_t * p, Aig_Obj_t * pNode, Vec_Ptr_t * vLeaves );
extern int Aig_NodeMffcExtendCut( Aig_Man_t * p, Aig_Obj_t * pNode, Vec_Ptr_t * vLeaves, Vec_Ptr_t * vResult );

extern Aig_Obj_t * Aig_ObjCreateCi( Aig_Man_t * p );
extern Aig_Obj_t * Aig_ObjCreateCo( Aig_Man_t * p, Aig_Obj_t * pDriver );
extern Aig_Obj_t * Aig_ObjCreate( Aig_Man_t * p, Aig_Obj_t * pGhost );
extern void Aig_ObjConnect( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pFan0, Aig_Obj_t * pFan1 );
extern void Aig_ObjDisconnect( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_ObjDelete( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_ObjDelete_rec( Aig_Man_t * p, Aig_Obj_t * pObj, int fFreeTop );
extern void Aig_ObjDeletePo( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_ObjPrint( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_ObjPatchFanin0( Aig_Man_t * p, Aig_Obj_t * pObj, Aig_Obj_t * pFaninNew );
extern void Aig_ObjReplace( Aig_Man_t * p, Aig_Obj_t * pObjOld, Aig_Obj_t * pObjNew, int fUpdateLevel );

extern Aig_Obj_t * Aig_IthVar( Aig_Man_t * p, int i );
extern Aig_Obj_t * Aig_Oper( Aig_Man_t * p, Aig_Obj_t * p0, Aig_Obj_t * p1, Aig_Type_t Type );
extern Aig_Obj_t * Aig_And( Aig_Man_t * p, Aig_Obj_t * p0, Aig_Obj_t * p1 );
extern Aig_Obj_t * Aig_Or( Aig_Man_t * p, Aig_Obj_t * p0, Aig_Obj_t * p1 );
extern Aig_Obj_t * Aig_Exor( Aig_Man_t * p, Aig_Obj_t * p0, Aig_Obj_t * p1 );
extern Aig_Obj_t * Aig_Mux( Aig_Man_t * p, Aig_Obj_t * pC, Aig_Obj_t * p1, Aig_Obj_t * p0 );
extern Aig_Obj_t * Aig_Maj( Aig_Man_t * p, Aig_Obj_t * pA, Aig_Obj_t * pB, Aig_Obj_t * pC );
extern Aig_Obj_t * Aig_Multi( Aig_Man_t * p, Aig_Obj_t ** pArgs, int nArgs, Aig_Type_t Type );
extern Aig_Obj_t * Aig_Miter( Aig_Man_t * p, Vec_Ptr_t * vPairs );
extern Aig_Obj_t * Aig_MiterTwo( Aig_Man_t * p, Vec_Ptr_t * vNodes1, Vec_Ptr_t * vNodes2 );
extern Aig_Obj_t * Aig_CreateAnd( Aig_Man_t * p, int nVars );
extern Aig_Obj_t * Aig_CreateOr( Aig_Man_t * p, int nVars );
extern Aig_Obj_t * Aig_CreateExor( Aig_Man_t * p, int nVars );

extern void Aig_ManOrderStart( Aig_Man_t * p );
extern void Aig_ManOrderStop( Aig_Man_t * p );
extern void Aig_ObjOrderInsert( Aig_Man_t * p, int ObjId );
extern void Aig_ObjOrderRemove( Aig_Man_t * p, int ObjId );
extern void Aig_ObjOrderAdvance( Aig_Man_t * p );

extern Vec_Ptr_t * Aig_ManSupports( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManSupportsInverse( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManSupportsRegisters( Aig_Man_t * p );
extern Vec_Ptr_t * Aig_ManPartitionSmart( Aig_Man_t * p, int nPartSizeLimit, int fVerbose, Vec_Ptr_t ** pvPartSupps );
extern Vec_Ptr_t * Aig_ManPartitionSmartRegisters( Aig_Man_t * pAig, int nSuppSizeLimit, int fVerbose );
extern Vec_Ptr_t * Aig_ManPartitionNaive( Aig_Man_t * p, int nPartSize );
extern Vec_Ptr_t * Aig_ManMiterPartitioned( Aig_Man_t * p1, Aig_Man_t * p2, int nPartSize, int fSmart );
extern Aig_Man_t * Aig_ManChoicePartitioned( Vec_Ptr_t * vAigs, int nPartSize, int nConfMax, int nLevelMax, int fVerbose );
extern Aig_Man_t * Aig_ManFraigPartitioned( Aig_Man_t * pAig, int nPartSize, int nConfMax, int nLevelMax, int fVerbose );
extern Aig_Man_t * Aig_ManChoiceConstructive( Vec_Ptr_t * vAigs, int fVerbose );

extern Vec_Ptr_t * Aig_ManRegPartitionSimple( Aig_Man_t * pAig, int nPartSize, int nOverSize );
extern void Aig_ManPartDivide( Vec_Ptr_t * vResult, Vec_Int_t * vDomain, int nPartSize, int nOverSize );
extern Vec_Ptr_t * Aig_ManRegPartitionSmart( Aig_Man_t * pAig, int nPartSize );
extern Aig_Man_t * Aig_ManRegCreatePart( Aig_Man_t * pAig, Vec_Int_t * vPart, int * pnCountPis, int * pnCountRegs, int ** ppMapBack );
extern Vec_Ptr_t * Aig_ManRegProjectOnehots( Aig_Man_t * pAig, Aig_Man_t * pPart, Vec_Ptr_t * vOnehots, int fVerbose );

extern void Aig_ManReprStart( Aig_Man_t * p, int nIdMax );
extern void Aig_ManReprStop( Aig_Man_t * p );
extern void Aig_ObjCreateRepr( Aig_Man_t * p, Aig_Obj_t * pNode1, Aig_Obj_t * pNode2 );
extern void Aig_ManTransferRepr( Aig_Man_t * pNew, Aig_Man_t * p );
extern Aig_Man_t * Aig_ManDupRepr( Aig_Man_t * p, int fOrdered );
extern Aig_Man_t * Aig_ManDupReprBasic( Aig_Man_t * p );
extern int Aig_ManCountReprs( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManRehash( Aig_Man_t * p );
extern int Aig_ObjCheckTfi( Aig_Man_t * p, Aig_Obj_t * pNew, Aig_Obj_t * pOld );
extern void Aig_ManMarkValidChoices( Aig_Man_t * p );
extern int Aig_TransferMappedClasses( Aig_Man_t * pAig, Aig_Man_t * pPart, int * pMapBack );

extern Aig_Man_t * Rtm_ManRetime( Aig_Man_t * p, int fForward, int nStepsMax, int fVerbose );

extern Aig_Man_t * Aig_ManRetimeFrontier( Aig_Man_t * p, int nStepsMax );

extern Aig_Man_t * Aig_ManRemap( Aig_Man_t * p, Vec_Ptr_t * vMap );
extern int Aig_ManSeqCleanup( Aig_Man_t * p );
extern int Aig_ManSeqCleanupBasic( Aig_Man_t * p );
extern int Aig_ManCountMergeRegs( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManReduceLaches( Aig_Man_t * p, int fVerbose );
extern void Aig_ManComputeSccs( Aig_Man_t * p );
extern Aig_Man_t * Aig_ManScl( Aig_Man_t * pAig, int fLatchConst, int fLatchEqual, int fUseMvSweep, int nFramesSymb, int nFramesSatur, int fVerbose, int fVeryVerbose );

extern void Aig_ManShow( Aig_Man_t * pMan, int fHaig, Vec_Ptr_t * vBold );

extern Aig_Obj_t * Aig_TableLookup( Aig_Man_t * p, Aig_Obj_t * pGhost );
extern Aig_Obj_t * Aig_TableLookupTwo( Aig_Man_t * p, Aig_Obj_t * pFanin0, Aig_Obj_t * pFanin1 );
extern void Aig_TableInsert( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_TableDelete( Aig_Man_t * p, Aig_Obj_t * pObj );
extern int Aig_TableCountEntries( Aig_Man_t * p );
extern void Aig_TableProfile( Aig_Man_t * p );
extern void Aig_TableClear( Aig_Man_t * p );

extern void Aig_ObjClearReverseLevel( Aig_Man_t * p, Aig_Obj_t * pObj );
extern int Aig_ObjRequiredLevel( Aig_Man_t * p, Aig_Obj_t * pObj );
extern void Aig_ManStartReverseLevels( Aig_Man_t * p, int nMaxLevelIncrease );
extern void Aig_ManStopReverseLevels( Aig_Man_t * p );
extern void Aig_ManUpdateLevel( Aig_Man_t * p, Aig_Obj_t * pObjNew );
extern void Aig_ManUpdateReverseLevel( Aig_Man_t * p, Aig_Obj_t * pObjNew );
extern void Aig_ManVerifyLevel( Aig_Man_t * p );
extern void Aig_ManVerifyReverseLevel( Aig_Man_t * p );

extern unsigned * Aig_ManCutTruth( Aig_Obj_t * pRoot, Vec_Ptr_t * vLeaves, Vec_Ptr_t * vNodes, Vec_Ptr_t * vTruthElem, Vec_Ptr_t * vTruthStore );

extern Aig_Man_t * Aig_ManConstReduce( Aig_Man_t * p, int fUseMvSweep, int nFramesSymb, int nFramesSatur, int fVerbose, int fVeryVerbose );

extern void Aig_ManIncrementTravId( Aig_Man_t * p );
extern char * Aig_TimeStamp();
extern int Aig_ManHasNoGaps( Aig_Man_t * p );
extern int Aig_ManLevels( Aig_Man_t * p );
extern void Aig_ManResetRefs( Aig_Man_t * p );
extern void Aig_ManCleanMarkA( Aig_Man_t * p );
extern void Aig_ManCleanMarkB( Aig_Man_t * p );
extern void Aig_ManCleanMarkAB( Aig_Man_t * p );
extern void Aig_ManCleanData( Aig_Man_t * p );
extern void Aig_ObjCleanData_rec( Aig_Obj_t * pObj );
extern void Aig_ManCleanNext( Aig_Man_t * p );
extern void Aig_ObjCollectMulti( Aig_Obj_t * pFunc, Vec_Ptr_t * vSuper );
extern int Aig_ObjIsMuxType( Aig_Obj_t * pObj );
extern int Aig_ObjRecognizeExor( Aig_Obj_t * pObj, Aig_Obj_t ** ppFan0, Aig_Obj_t ** ppFan1 );
extern Aig_Obj_t * Aig_ObjRecognizeMux( Aig_Obj_t * pObj, Aig_Obj_t ** ppObjT, Aig_Obj_t ** ppObjE );
extern Aig_Obj_t * Aig_ObjReal_rec( Aig_Obj_t * pObj );
extern int Aig_ObjCompareIdIncrease( Aig_Obj_t ** pp1, Aig_Obj_t ** pp2 );
extern void Aig_ObjPrintEqn( FILE * pFile, Aig_Obj_t * pObj, Vec_Vec_t * vLevels, int Level );
extern void Aig_ObjPrintVerilog( FILE * pFile, Aig_Obj_t * pObj, Vec_Vec_t * vLevels, int Level );
extern void Aig_ObjPrintVerbose( Aig_Obj_t * pObj, int fHaig );
extern void Aig_ManPrintVerbose( Aig_Man_t * p, int fHaig );
extern void Aig_ManDump( Aig_Man_t * p );
extern void Aig_ManDumpBlif( Aig_Man_t * p, char * pFileName, Vec_Ptr_t * vPiNames, Vec_Ptr_t * vPoNames );
extern void Aig_ManDumpVerilog( Aig_Man_t * p, char * pFileName );
extern void Aig_ManSetCioIds( Aig_Man_t * p );
extern void Aig_ManCleanCioIds( Aig_Man_t * p );
extern int Aig_ManChoiceNum( Aig_Man_t * p );
extern char * Aig_FileNameGenericAppend( char * pBase, char * pSuffix );
extern unsigned Aig_ManRandom( int fReset );
extern word Aig_ManRandom64( int fReset );
extern void Aig_ManRandomInfo( Vec_Ptr_t * vInfo, int iInputStart, int iWordStart, int iWordStop );
extern void Aig_NodeUnionLists( Vec_Ptr_t * vArr1, Vec_Ptr_t * vArr2, Vec_Ptr_t * vArr );
extern void Aig_NodeIntersectLists( Vec_Ptr_t * vArr1, Vec_Ptr_t * vArr2, Vec_Ptr_t * vArr );
extern void Aig_ManSetPhase( Aig_Man_t * pAig );
extern Vec_Ptr_t * Aig_ManMuxesCollect( Aig_Man_t * pAig );
extern void Aig_ManMuxesDeref( Aig_Man_t * pAig, Vec_Ptr_t * vMuxes );
extern void Aig_ManMuxesRef( Aig_Man_t * pAig, Vec_Ptr_t * vMuxes );
extern void Aig_ManInvertConstraints( Aig_Man_t * pAig );


extern void Aig_ManFindCut( Aig_Obj_t * pRoot, Vec_Ptr_t * vFront, Vec_Ptr_t * vVisited, int nSizeLimit, int nFanoutLimit );



extern Aig_MmFixed_t * Aig_MmFixedStart( int nEntrySize, int nEntriesMax );
extern void Aig_MmFixedStop( Aig_MmFixed_t * p, int fVerbose );
extern char * Aig_MmFixedEntryFetch( Aig_MmFixed_t * p );
extern void Aig_MmFixedEntryRecycle( Aig_MmFixed_t * p, char * pEntry );
extern void Aig_MmFixedRestart( Aig_MmFixed_t * p );
extern int Aig_MmFixedReadMemUsage( Aig_MmFixed_t * p );
extern int Aig_MmFixedReadMaxEntriesUsed( Aig_MmFixed_t * p );

extern Aig_MmFlex_t * Aig_MmFlexStart();
extern void Aig_MmFlexStop( Aig_MmFlex_t * p, int fVerbose );
extern char * Aig_MmFlexEntryFetch( Aig_MmFlex_t * p, int nBytes );
extern void Aig_MmFlexRestart( Aig_MmFlex_t * p );
extern int Aig_MmFlexReadMemUsage( Aig_MmFlex_t * p );

extern Aig_MmStep_t * Aig_MmStepStart( int nSteps );
extern void Aig_MmStepStop( Aig_MmStep_t * p, int fVerbose );
extern char * Aig_MmStepEntryFetch( Aig_MmStep_t * p, int nBytes );
extern void Aig_MmStepEntryRecycle( Aig_MmStep_t * p, char * pEntry, int nBytes );
extern int Aig_MmStepReadMemUsage( Aig_MmStep_t * p );




# 33 "/app/abc/src/base/main/mainInt.h" 2

# 1 "/app/abc/src/proof/ssw/ssw.h" 1
# 33 "/app/abc/src/proof/ssw/ssw.h"







typedef struct Ssw_Pars_t_ Ssw_Pars_t;
struct Ssw_Pars_t_
{
    int nPartSize;
    int nOverSize;
    int nProcs;
    int nFramesK;
    int nFramesAddSim;
    int fConstrs;
    int fMergeFull;
    int nMaxLevs;
    int nBTLimit;
    int nBTLimitGlobal;
    int nMinDomSize;
    int nItersStop;
    int fDumpSRInit;
    int nResimDelta;
    int nStepsMax;
    int TimeLimit;
    int nLimitMax;
    int fPolarFlip;
    int fLatchCorr;
    int fConstCorr;
    int fOutputCorr;
    int fSemiFormal;

    int fDynamic;
    int fLocalSim;
    int fPartSigCorr;
    int nIsleDist;
    int fScorrGia;
    int fUseCSat;
    int fVerbose;
    int fFlopVerbose;
    int fEquivDump;
    int fEquivDump2;
    int fStopWhenGone;
    int nSkip;
    int nSkipLimit;

    int fLatchCorrOpt;
    int nSatVarMax;
    int nRecycleCalls;

    int nSatVarMax2;
    int nRecycleCalls2;

    int nIters;
    int nConflicts;

    void * pData;
    void * pFunc;
};

typedef struct Ssw_RarPars_t_ Ssw_RarPars_t;
struct Ssw_RarPars_t_
{
    int nFrames;
    int nWords;
    int nBinSize;
    int nRounds;
    int nRestart;
    int nRandSeed;
    int TimeOut;
    int TimeOutGap;
    int fSolveAll;
    int fSetLastState;
    int fVerbose;
    int fNotVerbose;
    int fSilent;
    int fDropSatOuts;
    int fMiter;
    int fUseCex;
    int fLatchOnly;
    int fUseFfGrouping;
    int nSolved;
    Abc_Cex_t * pCex;
    int(*pFuncOnFail)(int,Abc_Cex_t*);
};

typedef struct Ssw_Sml_t_ Ssw_Sml_t;
# 131 "/app/abc/src/proof/ssw/ssw.h"
extern int Ssw_BmcDynamic( Aig_Man_t * pAig, int nFramesMax, int nConfLimit, int fVerbose, int * piFrame );

extern int Ssw_ManSetConstrPhases( Aig_Man_t * p, int nFrames, Vec_Int_t ** pvInits );

extern void Ssw_ManSetDefaultParams( Ssw_Pars_t * p );
extern void Ssw_ManSetDefaultParamsLcorr( Ssw_Pars_t * p );
extern Aig_Man_t * Ssw_SignalCorrespondence( Aig_Man_t * pAig, Ssw_Pars_t * pPars );
extern Aig_Man_t * Ssw_LatchCorrespondence( Aig_Man_t * pAig, Ssw_Pars_t * pPars );

extern int Ssw_SecWithSimilarityPairs( Aig_Man_t * p0, Aig_Man_t * p1, Vec_Int_t * vPairs, Ssw_Pars_t * pPars );
extern int Ssw_SecWithSimilarity( Aig_Man_t * p0, Aig_Man_t * p1, Ssw_Pars_t * pPars );


extern Aig_Man_t * Ssw_SignalCorrespondencePart( Aig_Man_t * pAig, Ssw_Pars_t * pPars );

extern int Ssw_MiterStatus( Aig_Man_t * p, int fVerbose );
extern int Ssw_SecWithPairs( Aig_Man_t * pAig1, Aig_Man_t * pAig2, Vec_Int_t * vIds1, Vec_Int_t * vIds2, Ssw_Pars_t * pPars );
extern int Ssw_SecGeneral( Aig_Man_t * pAig1, Aig_Man_t * pAig2, Ssw_Pars_t * pPars );
extern int Ssw_SecGeneralMiter( Aig_Man_t * pMiter, Ssw_Pars_t * pPars );

extern void Ssw_RarSetDefaultParams( Ssw_RarPars_t * p );
extern int Ssw_RarSignalFilter( Aig_Man_t * pAig, Ssw_RarPars_t * pPars );
extern int Ssw_RarSimulate( Aig_Man_t * pAig, Ssw_RarPars_t * pPars );

extern Ssw_Sml_t * Ssw_SmlSimulateComb( Aig_Man_t * pAig, int nWords );
extern Ssw_Sml_t * Ssw_SmlSimulateSeq( Aig_Man_t * pAig, int nPref, int nFrames, int nWords );
extern void Ssw_SmlUnnormalize( Ssw_Sml_t * p );
extern void Ssw_SmlStop( Ssw_Sml_t * p );
extern int Ssw_SmlNumFrames( Ssw_Sml_t * p );
extern int Ssw_SmlNumWordsTotal( Ssw_Sml_t * p );
extern unsigned * Ssw_SmlSimInfo( Ssw_Sml_t * p, Aig_Obj_t * pObj );
extern int Ssw_SmlObjsAreEqualWord( Ssw_Sml_t * p, Aig_Obj_t * pObj0, Aig_Obj_t * pObj1 );
extern void Ssw_SmlInitializeSpecial( Ssw_Sml_t * p, Vec_Int_t * vInit );
extern int Ssw_SmlCheckNonConstOutputs( Ssw_Sml_t * p );
extern Vec_Ptr_t * Ssw_SmlSimDataPointers( Ssw_Sml_t * p );



# 35 "/app/abc/src/base/main/mainInt.h" 2
# 1 "/app/abc/src/proof/fra/fra.h" 1
# 32 "/app/abc/src/proof/fra/fra.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/proof/fra/fra.h" 2



# 1 "/app/abc/src/opt/dar/dar.h" 1
# 35 "/app/abc/src/opt/dar/dar.h"







typedef struct Dar_RwrPar_t_ Dar_RwrPar_t;
typedef struct Dar_RefPar_t_ Dar_RefPar_t;

struct Dar_RwrPar_t_
{
    int nCutsMax;
    int nSubgMax;
    int nMinSaved;
    int fFanout;
    int fUpdateLevel;
    int fUseZeros;
    int fPower;
    int fRecycle;
    int fVerbose;
    int fVeryVerbose;
};

struct Dar_RefPar_t_
{
    int nMffcMin;
    int nLeafMax;
    int nCutsMax;
    int fExtend;
    int fUpdateLevel;
    int fUseZeros;
    int fVerbose;
    int fVeryVerbose;
};
# 84 "/app/abc/src/opt/dar/dar.h"
extern void Dar_LibStart();
extern void Dar_LibStop();
extern void Dar_LibPrepare( int nSubgraphs );
extern int Dar_LibReturnClass( unsigned uTruth );

extern Aig_Man_t * Dar_ManBalance( Aig_Man_t * p, int fUpdateLevel );
extern Aig_Man_t * Dar_ManBalanceXor( Aig_Man_t * pAig, int fExor, int fUpdateLevel, int fVerbose );
extern void Dar_BalancePrintStats( Aig_Man_t * p );

extern void Dar_ManDefaultRwrParams( Dar_RwrPar_t * pPars );
extern int Dar_ManRewrite( Aig_Man_t * pAig, Dar_RwrPar_t * pPars );
extern Aig_MmFixed_t * Dar_ManComputeCuts( Aig_Man_t * pAig, int nCutsMax, int fSkipTtMin, int fVerbose );

extern void Dar_ManDefaultRefParams( Dar_RefPar_t * pPars );
extern int Dar_ManRefactor( Aig_Man_t * pAig, Dar_RefPar_t * pPars );

extern Aig_Man_t * Dar_ManRewriteDefault( Aig_Man_t * pAig );
extern Aig_Man_t * Dar_ManRwsat( Aig_Man_t * pAig, int fBalance, int fVerbose );
extern Aig_Man_t * Dar_ManCompress( Aig_Man_t * pAig, int fBalance, int fUpdateLevel, int fPower, int fVerbose );
extern Aig_Man_t * Dar_ManCompress2( Aig_Man_t * pAig, int fBalance, int fUpdateLevel, int fFanout, int fPower, int fVerbose );
extern Aig_Man_t * Dar_ManChoice( Aig_Man_t * pAig, int fBalance, int fUpdateLevel, int fConstruct, int nConfMax, int nLevelMax, int fVerbose );




# 37 "/app/abc/src/proof/fra/fra.h" 2
# 1 "/app/abc/src/sat/bsat/satSolver.h" 1
# 29 "/app/abc/src/sat/bsat/satSolver.h"
# 1 "/usr/include/assert.h" 1 3 4
# 30 "/app/abc/src/sat/bsat/satSolver.h" 2

# 1 "/app/abc/src/sat/bsat/satVec.h" 1
# 27 "/app/abc/src/sat/bsat/satVec.h"




struct veci_t {
    int cap;
    int size;
    int* ptr;
};
typedef struct veci_t veci;

static inline void veci_new (veci* v) {
    v->cap = 4;
    v->size = 0;
    v->ptr = (int*)((char *) malloc(sizeof(char) * (size_t)(sizeof(int)*v->cap)));
}

static inline void veci_delete (veci* v) { ((v->ptr) ? (free((char *) (v->ptr)), (v->ptr) = 0) : 0); }
static inline int* veci_begin (veci* v) { return v->ptr; }
static inline int veci_size (veci* v) { return v->size; }
static inline void veci_resize (veci* v, int k) {
    
# 48 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ((void) sizeof ((
# 48 "/app/abc/src/sat/bsat/satVec.h"
   k <= v->size
# 48 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 48 "/app/abc/src/sat/bsat/satVec.h"
   k <= v->size
# 48 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ; else __assert_fail (
# 48 "/app/abc/src/sat/bsat/satVec.h"
   "k <= v->size"
# 48 "/app/abc/src/sat/bsat/satVec.h" 3 4
   , "/app/abc/src/sat/bsat/satVec.h", 48, __extension__ __PRETTY_FUNCTION__); }))
# 48 "/app/abc/src/sat/bsat/satVec.h"
                       ;

    v->size = k;
}
static inline int veci_pop (veci* v) { 
# 52 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ((void) sizeof ((
# 52 "/app/abc/src/sat/bsat/satVec.h"
                                                     v->size
# 52 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ) ? 1 : 0), __extension__ ({ if (
# 52 "/app/abc/src/sat/bsat/satVec.h"
                                                     v->size
# 52 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ) ; else __assert_fail (
# 52 "/app/abc/src/sat/bsat/satVec.h"
                                                     "v->size"
# 52 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     , "/app/abc/src/sat/bsat/satVec.h", 52, __extension__ __PRETTY_FUNCTION__); }))
# 52 "/app/abc/src/sat/bsat/satVec.h"
                                                                    ; return v->ptr[--v->size]; }
static inline void veci_push (veci* v, int e)
{
    if (v->size == v->cap) {

        int newsize = (v->cap < 4) ? v->cap * 2 : (v->cap / 2) * 3;
        v->ptr = ((v->ptr) ? ((int *) realloc((char *)(v->ptr), sizeof(int) * (size_t)(newsize))) : ((int *) malloc(sizeof(int) * (size_t)(newsize))));
        if ( v->ptr == 
# 59 "/app/abc/src/sat/bsat/satVec.h" 3 4
                      ((void *)0) 
# 59 "/app/abc/src/sat/bsat/satVec.h"
                           )
        {
            printf( "Failed to realloc memory from %.1f MB to %.1f MB.\n",
                1.0 * v->cap / (1<<20), 1.0 * newsize / (1<<20) );
            fflush( 
# 63 "/app/abc/src/sat/bsat/satVec.h" 3 4
                   stdout 
# 63 "/app/abc/src/sat/bsat/satVec.h"
                          );
        }
        v->cap = newsize; }
    v->ptr[v->size++] = e;
}
static inline void veci_remove(veci* v, int e)
{
    int * ws = (int*)veci_begin(v);
    int j = 0;
    for (; ws[j] != e ; j++);
    
# 73 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ((void) sizeof ((
# 73 "/app/abc/src/sat/bsat/satVec.h"
   j < veci_size(v)
# 73 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 73 "/app/abc/src/sat/bsat/satVec.h"
   j < veci_size(v)
# 73 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ; else __assert_fail (
# 73 "/app/abc/src/sat/bsat/satVec.h"
   "j < veci_size(v)"
# 73 "/app/abc/src/sat/bsat/satVec.h" 3 4
   , "/app/abc/src/sat/bsat/satVec.h", 73, __extension__ __PRETTY_FUNCTION__); }))
# 73 "/app/abc/src/sat/bsat/satVec.h"
                           ;
    for (; j < veci_size(v)-1; j++) ws[j] = ws[j+1];
    veci_resize(v,veci_size(v)-1);
}



struct vecp_t {
    int cap;
    int size;
    void** ptr;
};
typedef struct vecp_t vecp;

static inline void vecp_new (vecp* v) {
    v->size = 0;
    v->cap = 4;
    v->ptr = (void**)((char *) malloc(sizeof(char) * (size_t)(sizeof(void*)*v->cap)));
}

static inline void vecp_delete (vecp* v) { ((v->ptr) ? (free((char *) (v->ptr)), (v->ptr) = 0) : 0); }
static inline void** vecp_begin (vecp* v) { return v->ptr; }
static inline int vecp_size (vecp* v) { return v->size; }
static inline void vecp_resize (vecp* v, int k) { 
# 96 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ((void) sizeof ((
# 96 "/app/abc/src/sat/bsat/satVec.h"
                                                     k <= v->size
# 96 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ) ? 1 : 0), __extension__ ({ if (
# 96 "/app/abc/src/sat/bsat/satVec.h"
                                                     k <= v->size
# 96 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     ) ; else __assert_fail (
# 96 "/app/abc/src/sat/bsat/satVec.h"
                                                     "k <= v->size"
# 96 "/app/abc/src/sat/bsat/satVec.h" 3 4
                                                     , "/app/abc/src/sat/bsat/satVec.h", 96, __extension__ __PRETTY_FUNCTION__); }))
# 96 "/app/abc/src/sat/bsat/satVec.h"
                                                                         ; v->size = k; }
static inline void vecp_push (vecp* v, void* e)
{
    if (v->size == v->cap) {

        int newsize = (v->cap < 4) ? v->cap * 2 : (v->cap / 2) * 3;
        v->ptr = ((v->ptr) ? ((void* *) realloc((char *)(v->ptr), sizeof(void*) * (size_t)(newsize))) : ((void* *) malloc(sizeof(void*) * (size_t)(newsize))));
        v->cap = newsize; }
    v->ptr[v->size++] = e;
}
static inline void vecp_remove(vecp* v, void* e)
{
    void** ws = vecp_begin(v);
    int j = 0;
    for (; ws[j] != e ; j++);
    
# 111 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ((void) sizeof ((
# 111 "/app/abc/src/sat/bsat/satVec.h"
   j < vecp_size(v)
# 111 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 111 "/app/abc/src/sat/bsat/satVec.h"
   j < vecp_size(v)
# 111 "/app/abc/src/sat/bsat/satVec.h" 3 4
   ) ; else __assert_fail (
# 111 "/app/abc/src/sat/bsat/satVec.h"
   "j < vecp_size(v)"
# 111 "/app/abc/src/sat/bsat/satVec.h" 3 4
   , "/app/abc/src/sat/bsat/satVec.h", 111, __extension__ __PRETTY_FUNCTION__); }))
# 111 "/app/abc/src/sat/bsat/satVec.h"
                           ;
    for (; j < vecp_size(v)-1; j++) ws[j] = ws[j+1];
    vecp_resize(v,vecp_size(v)-1);
}
# 130 "/app/abc/src/sat/bsat/satVec.h"
typedef int lit;
typedef int cla;



typedef signed char lbool;

static const int var_Undef = -1;
static const lit lit_Undef = -2;

static const lbool l_Undef = 0;
static const lbool l_True = 1;
static const lbool l_False = -1;

static inline lit toLit (int v) { return v + v; }
static inline lit toLitCond(int v, int c) { return v + v + (c != 0); }
static inline lit lit_neg (lit l) { return l ^ 1; }
static inline int lit_var (lit l) { return l >> 1; }
static inline int lit_sign (lit l) { return l & 1; }
static inline int lit_print(lit l) { return lit_sign(l)? -lit_var(l)-1 : lit_var(l)+1; }
static inline lit lit_read (int s) { return s > 0 ? toLit(s-1) : lit_neg(toLit(-s-1)); }
static inline int lit_check(lit l, int n) { return l >= 0 && lit_var(l) < n; }

struct stats_t
{
    unsigned starts, clauses, learnts;
    ABC_INT64_T decisions, propagations, inspects, conflicts;
    ABC_INT64_T clauses_literals, learnts_literals, tot_literals;
};
typedef struct stats_t stats_t;


# 32 "/app/abc/src/sat/bsat/satSolver.h" 2
# 1 "/app/abc/src/sat/bsat/satClause.h" 1
# 30 "/app/abc/src/sat/bsat/satClause.h"

# 48 "/app/abc/src/sat/bsat/satClause.h"
typedef struct clause_t clause;
struct clause_t
{
    unsigned lrn : 1;
    unsigned mark : 1;
    unsigned partA : 1;
    unsigned lbd : 8;
    unsigned size : 21;
    lit lits[0];
};
# 70 "/app/abc/src/sat/bsat/satClause.h"
typedef struct Sat_Mem_t_ Sat_Mem_t;
struct Sat_Mem_t_
{
    int nEntries[2];
    int BookMarkH[2];
    int BookMarkE[2];
    int iPage[2];
    int nPageSize;
    unsigned uPageMask;
    unsigned uLearnedMask;
    int nPagesAlloc;
    int ** pPages;
};

static inline int Sat_MemLimit( int * p ) { return p[0]; }
static inline int Sat_MemIncLimit( int * p, int nInts ) { return p[0] += nInts; }
static inline void Sat_MemWriteLimit( int * p, int nInts ) { p[0] = nInts; }

static inline int Sat_MemHandPage( Sat_Mem_t * p, cla h ) { return h >> p->nPageSize; }
static inline int Sat_MemHandShift( Sat_Mem_t * p, cla h ) { return h & p->uPageMask; }


static inline int Sat_MemIntSize( int size, int lrn ) { return 2*((size + 2 + lrn)/2); }
static inline int Sat_MemClauseSize( clause * p ) { return Sat_MemIntSize(p->size, p->lrn); }
static inline int Sat_MemClauseSize2( clause * p ) { return Sat_MemIntSize(p->size, 1); }


static inline clause * Sat_MemClause( Sat_Mem_t * p, int i, int k ) { 
# 97 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                                                      ((void) sizeof ((
# 97 "/app/abc/src/sat/bsat/satClause.h"
                                                                      k
# 97 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                                                      ) ? 1 : 0), __extension__ ({ if (
# 97 "/app/abc/src/sat/bsat/satClause.h"
                                                                      k
# 97 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                                                      ) ; else __assert_fail (
# 97 "/app/abc/src/sat/bsat/satClause.h"
                                                                      "k"
# 97 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                                                      , "/app/abc/src/sat/bsat/satClause.h", 97, __extension__ __PRETTY_FUNCTION__); }))
# 97 "/app/abc/src/sat/bsat/satClause.h"
                                                                                 ; return (clause *)(p->pPages[i] + k); }

static inline clause * Sat_MemClauseHand( Sat_Mem_t * p, cla h ) { return h ? Sat_MemClause( p, Sat_MemHandPage(p, h), Sat_MemHandShift(p, h) ) : 
# 99 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                                                                                                                                     ((void *)0)
# 99 "/app/abc/src/sat/bsat/satClause.h"
                                                                                                                                                         ; }
static inline int Sat_MemEntryNum( Sat_Mem_t * p, int lrn ) { return p->nEntries[lrn]; }

static inline cla Sat_MemHand( Sat_Mem_t * p, int i, int k ) { return (i << p->nPageSize) | k; }
static inline cla Sat_MemHandCurrent( Sat_Mem_t * p, int lrn ) { return (p->iPage[lrn] << p->nPageSize) | Sat_MemLimit( p->pPages[p->iPage[lrn]] ); }

static inline int Sat_MemClauseUsed( Sat_Mem_t * p, cla h ) { return h < p->BookMarkH[(h & p->uLearnedMask) > 0]; }

static inline double Sat_MemMemoryHand( Sat_Mem_t * p, cla h ) { return 1.0 * ((Sat_MemHandPage(p, h) + 2)/2 * (1 << (p->nPageSize+2)) + Sat_MemHandShift(p, h) * 4); }
static inline double Sat_MemMemoryUsed( Sat_Mem_t * p, int lrn ) { return Sat_MemMemoryHand( p, Sat_MemHandCurrent(p, lrn) ); }
static inline double Sat_MemMemoryAllUsed( Sat_Mem_t * p ) { return Sat_MemMemoryUsed( p, 0 ) + Sat_MemMemoryUsed( p, 1 ); }
static inline double Sat_MemMemoryAll( Sat_Mem_t * p ) { return 1.0 * (p->iPage[0] + p->iPage[1] + 2) * (1 << (p->nPageSize+2)); }
# 139 "/app/abc/src/sat/bsat/satClause.h"
static inline int clause_from_lit( lit l ) { return l + l + 1; }
static inline int clause_is_lit( cla h ) { return (h & 1); }
static inline lit clause_read_lit( cla h ) { return (lit)(h >> 1); }

static inline int clause_learnt_h( Sat_Mem_t * p, cla h ) { return (h & p->uLearnedMask) > 0; }
static inline int clause_learnt( clause * c ) { return c->lrn; }
static inline int clause_id( clause * c ) { return c->lits[c->size]; }
static inline void clause_set_id( clause * c, int id ) { c->lits[c->size] = id; }
static inline int clause_size( clause * c ) { return c->size; }
static inline lit * clause_begin( clause * c ) { return c->lits; }
static inline lit * clause_end( clause * c ) { return c->lits + c->size; }
static inline void clause_print_( clause * c )
{
    int i;
    printf( "{ " );
    for ( i = 0; i < clause_size(c); i++ )
        printf( "%d ", (clause_begin(c)[i] & 1)? -(clause_begin(c)[i] >> 1) : clause_begin(c)[i] >> 1 );
    printf( "}\n" );
}
# 174 "/app/abc/src/sat/bsat/satClause.h"
static inline int Sat_MemCountL( Sat_Mem_t * p )
{
    clause * c;
    int i, k, Count = 0;
    for ( i = 1; i <= p->iPage[1]; i += 2 ) for ( k = 2; k < Sat_MemLimit(p->pPages[i]) && ((c) = Sat_MemClause( p, i, k )); k += Sat_MemClauseSize(c) )
        Count++;
    return Count;
}
# 194 "/app/abc/src/sat/bsat/satClause.h"
static inline void Sat_MemAlloc_( Sat_Mem_t * p, int nPageSize )
{
    
# 196 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ((void) sizeof ((
# 196 "/app/abc/src/sat/bsat/satClause.h"
   nPageSize > 8 && nPageSize < 32
# 196 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 196 "/app/abc/src/sat/bsat/satClause.h"
   nPageSize > 8 && nPageSize < 32
# 196 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ; else __assert_fail (
# 196 "/app/abc/src/sat/bsat/satClause.h"
   "nPageSize > 8 && nPageSize < 32"
# 196 "/app/abc/src/sat/bsat/satClause.h" 3 4
   , "/app/abc/src/sat/bsat/satClause.h", 196, __extension__ __PRETTY_FUNCTION__); }))
# 196 "/app/abc/src/sat/bsat/satClause.h"
                                            ;
    memset( p, 0, sizeof(Sat_Mem_t) );
    p->nPageSize = nPageSize;
    p->uLearnedMask = (unsigned)(1 << nPageSize);
    p->uPageMask = (unsigned)((1 << nPageSize) - 1);
    p->nPagesAlloc = 256;
    p->pPages = ((int * *) calloc((size_t)(p->nPagesAlloc), sizeof(int *)));
    p->pPages[0] = ((int *) malloc(sizeof(int) * (size_t)((int)(((word)1) << p->nPageSize))));
    p->pPages[1] = ((int *) malloc(sizeof(int) * (size_t)((int)(((word)1) << p->nPageSize))));
    p->iPage[0] = 0;
    p->iPage[1] = 1;
    Sat_MemWriteLimit( p->pPages[0], 2 );
    Sat_MemWriteLimit( p->pPages[1], 2 );
}
static inline Sat_Mem_t * Sat_MemAlloc( int nPageSize )
{
    Sat_Mem_t * p;
    p = ((Sat_Mem_t *) calloc((size_t)(1), sizeof(Sat_Mem_t)));
    Sat_MemAlloc_( p, nPageSize );
    return p;
}
# 229 "/app/abc/src/sat/bsat/satClause.h"
static inline void Sat_MemRestart( Sat_Mem_t * p )
{
    p->nEntries[0] = 0;
    p->nEntries[1] = 0;
    p->iPage[0] = 0;
    p->iPage[1] = 1;
    Sat_MemWriteLimit( p->pPages[0], 2 );
    Sat_MemWriteLimit( p->pPages[1], 2 );
}
# 250 "/app/abc/src/sat/bsat/satClause.h"
static inline void Sat_MemBookMark( Sat_Mem_t * p )
{
    p->BookMarkE[0] = p->nEntries[0];
    p->BookMarkE[1] = p->nEntries[1];
    p->BookMarkH[0] = Sat_MemHandCurrent( p, 0 );
    p->BookMarkH[1] = Sat_MemHandCurrent( p, 1 );
}
static inline void Sat_MemRollBack( Sat_Mem_t * p )
{
    p->nEntries[0] = p->BookMarkE[0];
    p->nEntries[1] = p->BookMarkE[1];
    p->iPage[0] = Sat_MemHandPage( p, p->BookMarkH[0] );
    p->iPage[1] = Sat_MemHandPage( p, p->BookMarkH[1] );
    Sat_MemWriteLimit( p->pPages[p->iPage[0]], Sat_MemHandShift( p, p->BookMarkH[0] ) );
    Sat_MemWriteLimit( p->pPages[p->iPage[1]], Sat_MemHandShift( p, p->BookMarkH[1] ) );
}
# 278 "/app/abc/src/sat/bsat/satClause.h"
static inline void Sat_MemFree_( Sat_Mem_t * p )
{
    int i;
    for ( i = 0; i < p->nPagesAlloc; i++ )
        ((p->pPages[i]) ? (free((char *) (p->pPages[i])), (p->pPages[i]) = 0) : 0);
    ((p->pPages) ? (free((char *) (p->pPages)), (p->pPages) = 0) : 0);
}
static inline void Sat_MemFree( Sat_Mem_t * p )
{
    Sat_MemFree_( p );
    ((p) ? (free((char *) (p)), (p) = 0) : 0);
}
# 302 "/app/abc/src/sat/bsat/satClause.h"
static inline int Sat_MemAppend( Sat_Mem_t * p, int * pArray, int nSize, int lrn, int fPlus1 )
{
    clause * c;
    int * pPage = p->pPages[p->iPage[lrn]];
    int nInts = Sat_MemIntSize( nSize, lrn | fPlus1 );
    
# 307 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ((void) sizeof ((
# 307 "/app/abc/src/sat/bsat/satClause.h"
   nInts + 3 < (1 << p->nPageSize)
# 307 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 307 "/app/abc/src/sat/bsat/satClause.h"
   nInts + 3 < (1 << p->nPageSize)
# 307 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ; else __assert_fail (
# 307 "/app/abc/src/sat/bsat/satClause.h"
   "nInts + 3 < (1 << p->nPageSize)"
# 307 "/app/abc/src/sat/bsat/satClause.h" 3 4
   , "/app/abc/src/sat/bsat/satClause.h", 307, __extension__ __PRETTY_FUNCTION__); }))
# 307 "/app/abc/src/sat/bsat/satClause.h"
                                            ;

    if ( Sat_MemLimit(pPage) + nInts + 2 >= (1 << p->nPageSize) )
    {
        p->iPage[lrn] += 2;
        if ( p->iPage[lrn] >= p->nPagesAlloc )
        {
            p->pPages = ((p->pPages) ? ((int * *) realloc((char *)(p->pPages), sizeof(int *) * (size_t)(p->nPagesAlloc * 2))) : ((int * *) malloc(sizeof(int *) * (size_t)(p->nPagesAlloc * 2))));
            memset( p->pPages + p->nPagesAlloc, 0, sizeof(int *) * p->nPagesAlloc );
            p->nPagesAlloc *= 2;
        }
        if ( p->pPages[p->iPage[lrn]] == 
# 318 "/app/abc/src/sat/bsat/satClause.h" 3 4
                                        ((void *)0) 
# 318 "/app/abc/src/sat/bsat/satClause.h"
                                             )
            p->pPages[p->iPage[lrn]] = ((int *) malloc(sizeof(int) * (size_t)((int)(((word)1) << p->nPageSize))));
        pPage = p->pPages[p->iPage[lrn]];
        Sat_MemWriteLimit( pPage, 2 );
    }
    pPage[Sat_MemLimit(pPage)] = 0;
    c = (clause *)(pPage + Sat_MemLimit(pPage));
    c->size = nSize;
    c->lrn = lrn;
    if ( pArray )
        memcpy( c->lits, pArray, sizeof(int) * nSize );
    if ( lrn | fPlus1 )
        c->lits[c->size] = p->nEntries[lrn];
    p->nEntries[lrn]++;
    Sat_MemIncLimit( pPage, nInts );
    return Sat_MemHandCurrent(p, lrn) - nInts;
}
# 347 "/app/abc/src/sat/bsat/satClause.h"
static inline void Sat_MemShrink( Sat_Mem_t * p, int h, int lrn )
{
    
# 349 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ((void) sizeof ((
# 349 "/app/abc/src/sat/bsat/satClause.h"
   clause_learnt_h(p, h) == lrn
# 349 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 349 "/app/abc/src/sat/bsat/satClause.h"
   clause_learnt_h(p, h) == lrn
# 349 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ; else __assert_fail (
# 349 "/app/abc/src/sat/bsat/satClause.h"
   "clause_learnt_h(p, h) == lrn"
# 349 "/app/abc/src/sat/bsat/satClause.h" 3 4
   , "/app/abc/src/sat/bsat/satClause.h", 349, __extension__ __PRETTY_FUNCTION__); }))
# 349 "/app/abc/src/sat/bsat/satClause.h"
                                         ;
    
# 350 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ((void) sizeof ((
# 350 "/app/abc/src/sat/bsat/satClause.h"
   h && h <= Sat_MemHandCurrent(p, lrn)
# 350 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 350 "/app/abc/src/sat/bsat/satClause.h"
   h && h <= Sat_MemHandCurrent(p, lrn)
# 350 "/app/abc/src/sat/bsat/satClause.h" 3 4
   ) ; else __assert_fail (
# 350 "/app/abc/src/sat/bsat/satClause.h"
   "h && h <= Sat_MemHandCurrent(p, lrn)"
# 350 "/app/abc/src/sat/bsat/satClause.h" 3 4
   , "/app/abc/src/sat/bsat/satClause.h", 350, __extension__ __PRETTY_FUNCTION__); }))
# 350 "/app/abc/src/sat/bsat/satClause.h"
                                                 ;
    p->iPage[lrn] = Sat_MemHandPage(p, h);
    Sat_MemWriteLimit( p->pPages[p->iPage[lrn]], Sat_MemHandShift(p, h) );
}
# 367 "/app/abc/src/sat/bsat/satClause.h"
static inline int Sat_MemCompactLearned( Sat_Mem_t * p, int fDoMove )
{
    clause * c, * cPivot = 
# 369 "/app/abc/src/sat/bsat/satClause.h" 3 4
                          ((void *)0)
# 369 "/app/abc/src/sat/bsat/satClause.h"
                              ;
    int i, k, iNew = 1, kNew = 2, nInts, fStartLooking, Counter = 0;
    int hLimit = Sat_MemHandCurrent(p, 1);
    if ( hLimit == Sat_MemHand(p, 1, 2) )
        return 0;
    if ( fDoMove && p->BookMarkH[1] )
    {

        
# 377 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ((void) sizeof ((
# 377 "/app/abc/src/sat/bsat/satClause.h"
       p->BookMarkH[1] >= Sat_MemHand(p, 1, 2) && p->BookMarkH[1] <= hLimit
# 377 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 377 "/app/abc/src/sat/bsat/satClause.h"
       p->BookMarkH[1] >= Sat_MemHand(p, 1, 2) && p->BookMarkH[1] <= hLimit
# 377 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ; else __assert_fail (
# 377 "/app/abc/src/sat/bsat/satClause.h"
       "p->BookMarkH[1] >= Sat_MemHand(p, 1, 2) && p->BookMarkH[1] <= hLimit"
# 377 "/app/abc/src/sat/bsat/satClause.h" 3 4
       , "/app/abc/src/sat/bsat/satClause.h", 377, __extension__ __PRETTY_FUNCTION__); }))
# 377 "/app/abc/src/sat/bsat/satClause.h"
                                                                                     ;

        cPivot = Sat_MemClauseHand( p, p->BookMarkH[1] );
        if ( p->BookMarkH[1] < hLimit && !cPivot->mark )
        {
            p->BookMarkH[1] = cPivot->lits[cPivot->size];
            cPivot = 
# 383 "/app/abc/src/sat/bsat/satClause.h" 3 4
                    ((void *)0)
# 383 "/app/abc/src/sat/bsat/satClause.h"
                        ;
        }

    }

    fStartLooking = 0;
    for ( i = 1; i <= p->iPage[1]; i += 2 ) for ( k = 2; k < Sat_MemLimit(p->pPages[i]) && ((c) = Sat_MemClause( p, i, k )); k += Sat_MemClauseSize(c) )
    {
        
# 391 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ((void) sizeof ((
# 391 "/app/abc/src/sat/bsat/satClause.h"
       c->lrn
# 391 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 391 "/app/abc/src/sat/bsat/satClause.h"
       c->lrn
# 391 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ; else __assert_fail (
# 391 "/app/abc/src/sat/bsat/satClause.h"
       "c->lrn"
# 391 "/app/abc/src/sat/bsat/satClause.h" 3 4
       , "/app/abc/src/sat/bsat/satClause.h", 391, __extension__ __PRETTY_FUNCTION__); }))
# 391 "/app/abc/src/sat/bsat/satClause.h"
                       ;

        if ( c->mark )
        {

            if ( cPivot && cPivot == c )
            {
                fStartLooking = 1;
                cPivot = 
# 399 "/app/abc/src/sat/bsat/satClause.h" 3 4
                        ((void *)0)
# 399 "/app/abc/src/sat/bsat/satClause.h"
                            ;
            }
            continue;
        }

        if ( fStartLooking )
        {
            fStartLooking = 0;
            p->BookMarkH[1] = c->lits[c->size];
        }

        nInts = Sat_MemClauseSize(c);
        
# 411 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ((void) sizeof ((
# 411 "/app/abc/src/sat/bsat/satClause.h"
       !(nInts & 1)
# 411 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 411 "/app/abc/src/sat/bsat/satClause.h"
       !(nInts & 1)
# 411 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ; else __assert_fail (
# 411 "/app/abc/src/sat/bsat/satClause.h"
       "!(nInts & 1)"
# 411 "/app/abc/src/sat/bsat/satClause.h" 3 4
       , "/app/abc/src/sat/bsat/satClause.h", 411, __extension__ __PRETTY_FUNCTION__); }))
# 411 "/app/abc/src/sat/bsat/satClause.h"
                             ;

        if ( kNew + nInts >= (1 << p->nPageSize) )
        {

            if ( fDoMove )
                Sat_MemWriteLimit( p->pPages[iNew], kNew );

            iNew += 2;
            kNew = 2;
        }
        if ( fDoMove )
        {

            
# 425 "/app/abc/src/sat/bsat/satClause.h" 3 4
           ((void) sizeof ((
# 425 "/app/abc/src/sat/bsat/satClause.h"
           c->lits[c->size] == Sat_MemHand(p, iNew, kNew)
# 425 "/app/abc/src/sat/bsat/satClause.h" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 425 "/app/abc/src/sat/bsat/satClause.h"
           c->lits[c->size] == Sat_MemHand(p, iNew, kNew)
# 425 "/app/abc/src/sat/bsat/satClause.h" 3 4
           ) ; else __assert_fail (
# 425 "/app/abc/src/sat/bsat/satClause.h"
           "c->lits[c->size] == Sat_MemHand(p, iNew, kNew)"
# 425 "/app/abc/src/sat/bsat/satClause.h" 3 4
           , "/app/abc/src/sat/bsat/satClause.h", 425, __extension__ __PRETTY_FUNCTION__); }))
# 425 "/app/abc/src/sat/bsat/satClause.h"
                                                                   ;

            if ( i != iNew || k != kNew )
            {
                memmove( p->pPages[iNew] + kNew, c, sizeof(int) * nInts );

                c = (clause *)(p->pPages[iNew] + kNew);
                
# 432 "/app/abc/src/sat/bsat/satClause.h" 3 4
               ((void) sizeof ((
# 432 "/app/abc/src/sat/bsat/satClause.h"
               nInts == Sat_MemClauseSize(c)
# 432 "/app/abc/src/sat/bsat/satClause.h" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 432 "/app/abc/src/sat/bsat/satClause.h"
               nInts == Sat_MemClauseSize(c)
# 432 "/app/abc/src/sat/bsat/satClause.h" 3 4
               ) ; else __assert_fail (
# 432 "/app/abc/src/sat/bsat/satClause.h"
               "nInts == Sat_MemClauseSize(c)"
# 432 "/app/abc/src/sat/bsat/satClause.h" 3 4
               , "/app/abc/src/sat/bsat/satClause.h", 432, __extension__ __PRETTY_FUNCTION__); }))
# 432 "/app/abc/src/sat/bsat/satClause.h"
                                                      ;
            }

            c->lits[c->size] = Counter;
        }
        else
            c->lits[c->size] = Sat_MemHand(p, iNew, kNew);

        kNew += nInts;
        
# 441 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ((void) sizeof ((
# 441 "/app/abc/src/sat/bsat/satClause.h"
       iNew <= i && kNew < (1 << p->nPageSize)
# 441 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 441 "/app/abc/src/sat/bsat/satClause.h"
       iNew <= i && kNew < (1 << p->nPageSize)
# 441 "/app/abc/src/sat/bsat/satClause.h" 3 4
       ) ; else __assert_fail (
# 441 "/app/abc/src/sat/bsat/satClause.h"
       "iNew <= i && kNew < (1 << p->nPageSize)"
# 441 "/app/abc/src/sat/bsat/satClause.h" 3 4
       , "/app/abc/src/sat/bsat/satClause.h", 441, __extension__ __PRETTY_FUNCTION__); }))
# 441 "/app/abc/src/sat/bsat/satClause.h"
                                                        ;

        Counter++;
    }
    if ( fDoMove )
    {

        p->nEntries[1] = Counter;

        p->iPage[1] = iNew;

        Sat_MemWriteLimit( p->pPages[iNew], kNew );

        if ( p->BookMarkH[1] )
        {
            if ( cPivot )
            {
                p->BookMarkH[1] = Sat_MemHandCurrent(p, 1);
                p->BookMarkE[1] = p->nEntries[1];
            }
            else
                p->BookMarkE[1] = clause_id(Sat_MemClauseHand( p, p->BookMarkH[1] ));
        }

    }
    return Counter;
}



# 33 "/app/abc/src/sat/bsat/satSolver.h" 2
# 1 "/app/abc/src/misc/util/utilDouble.h" 1
# 26 "/app/abc/src/misc/util/utilDouble.h"

# 49 "/app/abc/src/misc/util/utilDouble.h"
typedef word xdbl;

static inline word Xdbl_Exp( xdbl a ) { return a >> 48; }
static inline word Xdbl_Mnt( xdbl a ) { return (a << 16) >> 16; }

static inline xdbl Xdbl_Create( word Exp, word Mnt ) { 
# 54 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ((void) sizeof ((
# 54 "/app/abc/src/misc/util/utilDouble.h"
                                                         !(Exp>>16) && (Mnt>>47)==(word)1
# 54 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ) ? 1 : 0), __extension__ ({ if (
# 54 "/app/abc/src/misc/util/utilDouble.h"
                                                         !(Exp>>16) && (Mnt>>47)==(word)1
# 54 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ) ; else __assert_fail (
# 54 "/app/abc/src/misc/util/utilDouble.h"
                                                         "!(Exp>>16) && (Mnt>>47)==(word)1"
# 54 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         , "/app/abc/src/misc/util/utilDouble.h", 54, __extension__ __PRETTY_FUNCTION__); }))
# 54 "/app/abc/src/misc/util/utilDouble.h"
                                                                                                 ; return (Exp<<48) | Mnt; }

static inline xdbl Xdbl_Const1() { return Xdbl_Create( (word)0, (word)1 << 47 ); }
static inline xdbl Xdbl_Const2() { return Xdbl_Create( (word)1, (word)1 << 47 ); }
static inline xdbl Xdbl_Const3() { return Xdbl_Create( (word)1, (word)3 << 46 ); }
static inline xdbl Xdbl_Const12() { return Xdbl_Create( (word)3, (word)3 << 46 ); }
static inline xdbl Xdbl_Const1point5() { return Xdbl_Create( (word)0, (word)3 << 46 ); }
static inline xdbl Xdbl_Const2point5() { return Xdbl_Create( (word)1, (word)5 << 45 ); }
static inline xdbl Xdbl_Maximum() { return ~(word)0; }

static inline double Xdbl_ToDouble( xdbl a ) { 
# 64 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ((void) sizeof ((
# 64 "/app/abc/src/misc/util/utilDouble.h"
                                                         Xdbl_Exp(a) < 1023
# 64 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ) ? 1 : 0), __extension__ ({ if (
# 64 "/app/abc/src/misc/util/utilDouble.h"
                                                         Xdbl_Exp(a) < 1023
# 64 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         ) ; else __assert_fail (
# 64 "/app/abc/src/misc/util/utilDouble.h"
                                                         "Xdbl_Exp(a) < 1023"
# 64 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                         , "/app/abc/src/misc/util/utilDouble.h", 64, __extension__ __PRETTY_FUNCTION__); }))
# 64 "/app/abc/src/misc/util/utilDouble.h"
                                                                                   ; return Abc_Word2Dbl(((Xdbl_Exp(a) + 1023) << 52) | (((a<<17)>>17) << 5)); }
static inline xdbl Xdbl_FromDouble( double a ) { word A = Abc_Dbl2Word(a); 
# 65 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                                                   ((void) sizeof ((
# 65 "/app/abc/src/misc/util/utilDouble.h"
                                                                                   a >= 1.0
# 65 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                                                   ) ? 1 : 0), __extension__ ({ if (
# 65 "/app/abc/src/misc/util/utilDouble.h"
                                                                                   a >= 1.0
# 65 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                                                   ) ; else __assert_fail (
# 65 "/app/abc/src/misc/util/utilDouble.h"
                                                                                   "a >= 1.0"
# 65 "/app/abc/src/misc/util/utilDouble.h" 3 4
                                                                                   , "/app/abc/src/misc/util/utilDouble.h", 65, __extension__ __PRETTY_FUNCTION__); }))
# 65 "/app/abc/src/misc/util/utilDouble.h"
                                                                                                   ; return Xdbl_Create((A >> 52)-1023, (((word)1) << 47) | ((A << 12) >> 17)); }
# 82 "/app/abc/src/misc/util/utilDouble.h"
static inline xdbl Xdbl_Add( xdbl a, xdbl b )
{
    word Exp, Mnt;
    if ( a < b ) a ^= b, b ^= a, a ^= b;
    
# 86 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ((void) sizeof ((
# 86 "/app/abc/src/misc/util/utilDouble.h"
   a >= b
# 86 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 86 "/app/abc/src/misc/util/utilDouble.h"
   a >= b
# 86 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ; else __assert_fail (
# 86 "/app/abc/src/misc/util/utilDouble.h"
   "a >= b"
# 86 "/app/abc/src/misc/util/utilDouble.h" 3 4
   , "/app/abc/src/misc/util/utilDouble.h", 86, __extension__ __PRETTY_FUNCTION__); }))
# 86 "/app/abc/src/misc/util/utilDouble.h"
                   ;
    Mnt = Xdbl_Mnt(a) + (Xdbl_Mnt(b) >> (Xdbl_Exp(a) - Xdbl_Exp(b)));
    Exp = Xdbl_Exp(a);
    if ( Mnt >> 48 )
        Exp++, Mnt >>= 1;
    if ( Exp >> 16 )
        return Xdbl_Maximum();
    return Xdbl_Create( Exp, Mnt );
}
# 107 "/app/abc/src/misc/util/utilDouble.h"
static inline xdbl Xdbl_Mul( xdbl a, xdbl b )
{
    word Exp, Mnt, MntA, MntB, MntAh, MntBh, MntAl, MntBl;
    if ( a < b ) a ^= b, b ^= a, a ^= b;
    
# 111 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ((void) sizeof ((
# 111 "/app/abc/src/misc/util/utilDouble.h"
   a >= b
# 111 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 111 "/app/abc/src/misc/util/utilDouble.h"
   a >= b
# 111 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ; else __assert_fail (
# 111 "/app/abc/src/misc/util/utilDouble.h"
   "a >= b"
# 111 "/app/abc/src/misc/util/utilDouble.h" 3 4
   , "/app/abc/src/misc/util/utilDouble.h", 111, __extension__ __PRETTY_FUNCTION__); }))
# 111 "/app/abc/src/misc/util/utilDouble.h"
                   ;
    MntA = Xdbl_Mnt(a);
    MntB = Xdbl_Mnt(b);
    MntAh = MntA>>32;
    MntBh = MntB>>32;
    MntAl = (MntA<<32)>>32;
    MntBl = (MntB<<32)>>32;
    Mnt = ((MntAh * MntBh) << 17) + ((MntAl * MntBl) >> 47) + ((MntAl * MntBh) >> 15) + ((MntAh * MntBl) >> 15);
    Exp = Xdbl_Exp(a) + Xdbl_Exp(b);
    if ( Mnt >> 48 )
        Exp++, Mnt >>= 1;
    if ( Exp >> 16 )
        return Xdbl_Maximum();
    return Xdbl_Create( Exp, Mnt );
}
# 138 "/app/abc/src/misc/util/utilDouble.h"
static inline xdbl Xdbl_Div( xdbl a, unsigned Deg2 )
{
    if ( Xdbl_Exp(a) >= (word)Deg2 )
        return Xdbl_Create( Xdbl_Exp(a) - Deg2, Xdbl_Mnt(a) );
    return Xdbl_Const1();
}
# 156 "/app/abc/src/misc/util/utilDouble.h"
static inline void Xdbl_Test()
{
    xdbl c1 = Xdbl_Const1();
    xdbl c2 = Xdbl_Const2();
    xdbl c3 = Xdbl_Const3();
    xdbl c12 = Xdbl_Const12();
    xdbl c1p5 = Xdbl_Const1point5();
    xdbl c2p5 = Xdbl_Const2point5();

    xdbl c1_ = Xdbl_FromDouble(1.0);
    xdbl c2_ = Xdbl_FromDouble(2.0);
    xdbl c3_ = Xdbl_FromDouble(3.0);
    xdbl c12_ = Xdbl_FromDouble(12.0);
    xdbl c1p5_ = Xdbl_FromDouble(1.5);
    xdbl c2p5_ = Xdbl_FromDouble(2.5);

    xdbl sum1 = Xdbl_Add(c1, c1p5);
    xdbl mul1 = Xdbl_Mul(c2, c1p5);

    xdbl sum2 = Xdbl_Add(c1p5, c2p5);
    xdbl mul2 = Xdbl_Mul(c1p5, c2p5);

    xdbl a = Xdbl_FromDouble(1.2929725);
    xdbl b = Xdbl_FromDouble(10.28828287);
    xdbl ab = Xdbl_Mul(a, b);

    xdbl ten100 = Xdbl_FromDouble( 1e100 );
    xdbl ten100_ = 0x014c924d692ca61b;

    
# 185 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ((void) sizeof ((
# 185 "/app/abc/src/misc/util/utilDouble.h"
   ten100 == ten100_
# 185 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 185 "/app/abc/src/misc/util/utilDouble.h"
   ten100 == ten100_
# 185 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ; else __assert_fail (
# 185 "/app/abc/src/misc/util/utilDouble.h"
   "ten100 == ten100_"
# 185 "/app/abc/src/misc/util/utilDouble.h" 3 4
   , "/app/abc/src/misc/util/utilDouble.h", 185, __extension__ __PRETTY_FUNCTION__); }))
# 185 "/app/abc/src/misc/util/utilDouble.h"
                              ;





    printf( "1 = %lf\n", Xdbl_ToDouble(c1) );
    printf( "2 = %lf\n", Xdbl_ToDouble(c2) );
    printf( "3 = %lf\n", Xdbl_ToDouble(c3) );
    printf( "12 = %lf\n", Xdbl_ToDouble(c12) );
    printf( "1.5 = %lf\n", Xdbl_ToDouble(c1p5) );
    printf( "2.5 = %lf\n", Xdbl_ToDouble(c2p5) );

    printf( "Converted 1 = %lf\n", Xdbl_ToDouble(c1_) );
    printf( "Converted 2 = %lf\n", Xdbl_ToDouble(c2_) );
    printf( "Converted 3 = %lf\n", Xdbl_ToDouble(c3_) );
    printf( "Converted 12 = %lf\n", Xdbl_ToDouble(c12_) );
    printf( "Converted 1.5 = %lf\n", Xdbl_ToDouble(c1p5_) );
    printf( "Converted 2.5 = %lf\n", Xdbl_ToDouble(c2p5_) );

    printf( "1.0 + 1.5 = %lf\n", Xdbl_ToDouble(sum1) );
    printf( "2.0 * 1.5 = %lf\n", Xdbl_ToDouble(mul1) );

    printf( "1.5 + 2.5 = %lf\n", Xdbl_ToDouble(sum2) );
    printf( "1.5 * 2.5 = %lf\n", Xdbl_ToDouble(mul2) );
    printf( "12 / 2^2  = %lf\n", Xdbl_ToDouble(Xdbl_Div(c12, 2)) );

    printf( "12 / 2^2  = %lf\n", Xdbl_ToDouble(Xdbl_Div(c12, 2)) );

    printf( "%.16lf * %.16lf = %.16lf (%.16lf)\n", Xdbl_ToDouble(a), Xdbl_ToDouble(b), Xdbl_ToDouble(ab), 1.2929725 * 10.28828287 );

    
# 216 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ((void) sizeof ((
# 216 "/app/abc/src/misc/util/utilDouble.h"
   sum1 == c2p5
# 216 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 216 "/app/abc/src/misc/util/utilDouble.h"
   sum1 == c2p5
# 216 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ; else __assert_fail (
# 216 "/app/abc/src/misc/util/utilDouble.h"
   "sum1 == c2p5"
# 216 "/app/abc/src/misc/util/utilDouble.h" 3 4
   , "/app/abc/src/misc/util/utilDouble.h", 216, __extension__ __PRETTY_FUNCTION__); }))
# 216 "/app/abc/src/misc/util/utilDouble.h"
                         ;
    
# 217 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ((void) sizeof ((
# 217 "/app/abc/src/misc/util/utilDouble.h"
   mul1 == c3
# 217 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 217 "/app/abc/src/misc/util/utilDouble.h"
   mul1 == c3
# 217 "/app/abc/src/misc/util/utilDouble.h" 3 4
   ) ; else __assert_fail (
# 217 "/app/abc/src/misc/util/utilDouble.h"
   "mul1 == c3"
# 217 "/app/abc/src/misc/util/utilDouble.h" 3 4
   , "/app/abc/src/misc/util/utilDouble.h", 217, __extension__ __PRETTY_FUNCTION__); }))
# 217 "/app/abc/src/misc/util/utilDouble.h"
                       ;
}


# 34 "/app/abc/src/sat/bsat/satSolver.h" 2






struct sat_solver_t;
typedef struct sat_solver_t sat_solver;

extern sat_solver* sat_solver_new(void);
extern sat_solver* zsat_solver_new_seed(double seed);
extern void sat_solver_delete(sat_solver* s);

extern int sat_solver_addclause(sat_solver* s, lit* begin, lit* end);
extern int sat_solver_clause_new(sat_solver* s, lit* begin, lit* end, int learnt);
extern int sat_solver_simplify(sat_solver* s);
extern int sat_solver_solve(sat_solver* s, lit* begin, lit* end, ABC_INT64_T nConfLimit, ABC_INT64_T nInsLimit, ABC_INT64_T nConfLimitGlobal, ABC_INT64_T nInsLimitGlobal);
extern int sat_solver_solve_internal(sat_solver* s);
extern int sat_solver_solve_lexsat(sat_solver* s, int * pLits, int nLits);
extern int sat_solver_minimize_assumptions( sat_solver* s, int * pLits, int nLits, int nConfLimit );
extern int sat_solver_minimize_assumptions2( sat_solver* s, int * pLits, int nLits, int nConfLimit );
extern int sat_solver_push(sat_solver* s, int p);
extern void sat_solver_pop(sat_solver* s);
extern void sat_solver_set_resource_limits(sat_solver* s, ABC_INT64_T nConfLimit, ABC_INT64_T nInsLimit, ABC_INT64_T nConfLimitGlobal, ABC_INT64_T nInsLimitGlobal);
extern void sat_solver_restart( sat_solver* s );
extern void zsat_solver_restart_seed( sat_solver* s, double seed );
extern void sat_solver_rollback( sat_solver* s );

extern int sat_solver_nvars(sat_solver* s);
extern int sat_solver_nclauses(sat_solver* s);
extern int sat_solver_nconflicts(sat_solver* s);
extern double sat_solver_memory(sat_solver* s);
extern int sat_solver_count_assigned(sat_solver* s);

extern int sat_solver_addvar(sat_solver* s);
extern void sat_solver_setnvars(sat_solver* s,int n);
extern int sat_solver_get_var_value(sat_solver* s, int v);
extern void sat_solver_set_var_activity(sat_solver* s, int * pVars, int nVars);

extern void Sat_SolverWriteDimacs( sat_solver * p, char * pFileName, lit* assumptionsBegin, lit* assumptionsEnd, int incrementVars );
extern void Sat_SolverPrintStats( FILE * pFile, sat_solver * p );
extern int * Sat_SolverGetModel( sat_solver * p, int * pVars, int nVars );
extern void Sat_SolverDoubleClauses( sat_solver * p, int iVar );


extern void Sat_SolverTraceStart( sat_solver * pSat, char * pName );
extern void Sat_SolverTraceStop( sat_solver * pSat );
extern void Sat_SolverTraceWrite( sat_solver * pSat, int * pBeg, int * pEnd, int fRoot );


extern void sat_solver_store_alloc( sat_solver * s );
extern void sat_solver_store_write( sat_solver * s, char * pFileName );
extern void sat_solver_store_free( sat_solver * s );
extern void sat_solver_store_mark_roots( sat_solver * s );
extern void sat_solver_store_mark_clauses_a( sat_solver * s );
extern void * sat_solver_store_release( sat_solver * s );







struct varinfo_t;
typedef struct varinfo_t varinfo;

struct sat_solver_t
{
    int size;
    int cap;
    int qhead;
    int qtail;


    Sat_Mem_t Mem;
    int hLearnts;
    int hBinary;
    clause * binary;
    veci* wlists;


    int iVarPivot;
    int iTrailPivot;
    int hProofPivot;


    int VarActType;
    int ClaActType;
    word var_inc;
    word var_inc2;
    word var_decay;
    word* activity;
    word* activity2;
    unsigned cla_inc;
    unsigned cla_decay;
    veci act_clas;

    char * pFreqs;
    int nVarUsed;


    int* levels;
    char* assigns;
    char* polarity;
    char* tags;
    char* loads;

    int* orderpos;
    int* reasons;
    lit* trail;
    veci tagged;
    veci stack;

    veci order;
    veci trail_lim;

    int * model;
    veci conf_final;


    int root_level;
    int simpdb_assigns;
    int simpdb_props;
    double random_seed;
    double progress_estimate;
    int verbosity;
    int fVerbose;
    int fPrintClause;

    stats_t stats;
    int nLearntMax;
    int nLearntStart;
    int nLearntDelta;
    int nLearntRatio;
    int nDBreduces;

    ABC_INT64_T nConfLimit;
    ABC_INT64_T nInsLimit;
    abctime nRuntimeLimit;

    veci act_vars;
    double* factors;
    int nRestarts;
    int nCalls;
    int nCalls2;
    veci unit_lits;
    veci pivot_vars;

    int fSkipSimplify;
    int fNotUseRandom;
    int fNoRestarts;

    int * pGlobalVars;

    void * pStore;
    int fSolved;


    FILE * pFile;
    int nClauses;
    int nRoots;

    veci temp_clause;


    veci user_vars;
    veci user_values;


    void * pCnfMan;
    int(*pCnfFunc)(void * p, int);


    int RunId;
    int(*pFuncStop)(int);
};

static inline clause * clause_read( sat_solver * s, cla h )
{
    return Sat_MemClauseHand( &s->Mem, h );
}

static inline int sat_solver_var_value( sat_solver* s, int v )
{
    
# 218 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 218 "/app/abc/src/sat/bsat/satSolver.h"
   v >= 0 && v < s->size
# 218 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 218 "/app/abc/src/sat/bsat/satSolver.h"
   v >= 0 && v < s->size
# 218 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 218 "/app/abc/src/sat/bsat/satSolver.h"
   "v >= 0 && v < s->size"
# 218 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 218, __extension__ __PRETTY_FUNCTION__); }))
# 218 "/app/abc/src/sat/bsat/satSolver.h"
                                  ;
    return (int)(s->model[v] == l_True);
}
static inline int sat_solver_var_literal( sat_solver* s, int v )
{
    
# 223 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 223 "/app/abc/src/sat/bsat/satSolver.h"
   v >= 0 && v < s->size
# 223 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 223 "/app/abc/src/sat/bsat/satSolver.h"
   v >= 0 && v < s->size
# 223 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 223 "/app/abc/src/sat/bsat/satSolver.h"
   "v >= 0 && v < s->size"
# 223 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 223, __extension__ __PRETTY_FUNCTION__); }))
# 223 "/app/abc/src/sat/bsat/satSolver.h"
                                  ;
    return toLitCond( v, s->model[v] != l_True );
}
static inline void sat_solver_flip_print_clause( sat_solver* s )
{
    s->fPrintClause ^= 1;
}
static inline void sat_solver_act_var_clear(sat_solver* s)
{
    int i;
    if ( s->VarActType == 0 )
    {
        for (i = 0; i < s->size; i++)
            s->activity[i] = (1 << 10);
        s->var_inc = (1 << 5);
    }
    else if ( s->VarActType == 1 )
    {
        for (i = 0; i < s->size; i++)
            s->activity[i] = 0;
        s->var_inc = 1;
    }
    else if ( s->VarActType == 2 )
    {
        for (i = 0; i < s->size; i++)
            s->activity[i] = Xdbl_Const1();
        s->var_inc = Xdbl_Const1();
    }
    else 
# 251 "/app/abc/src/sat/bsat/satSolver.h" 3 4
        ((void) sizeof ((
# 251 "/app/abc/src/sat/bsat/satSolver.h"
        0
# 251 "/app/abc/src/sat/bsat/satSolver.h" 3 4
        ) ? 1 : 0), __extension__ ({ if (
# 251 "/app/abc/src/sat/bsat/satSolver.h"
        0
# 251 "/app/abc/src/sat/bsat/satSolver.h" 3 4
        ) ; else __assert_fail (
# 251 "/app/abc/src/sat/bsat/satSolver.h"
        "0"
# 251 "/app/abc/src/sat/bsat/satSolver.h" 3 4
        , "/app/abc/src/sat/bsat/satSolver.h", 251, __extension__ __PRETTY_FUNCTION__); }))
# 251 "/app/abc/src/sat/bsat/satSolver.h"
                 ;
}
static inline void sat_solver_compress(sat_solver* s)
{
    if ( s->qtail != s->qhead )
    {
        int RetValue = sat_solver_simplify(s);
        
# 258 "/app/abc/src/sat/bsat/satSolver.h" 3 4
       ((void) sizeof ((
# 258 "/app/abc/src/sat/bsat/satSolver.h"
       RetValue != 0
# 258 "/app/abc/src/sat/bsat/satSolver.h" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 258 "/app/abc/src/sat/bsat/satSolver.h"
       RetValue != 0
# 258 "/app/abc/src/sat/bsat/satSolver.h" 3 4
       ) ; else __assert_fail (
# 258 "/app/abc/src/sat/bsat/satSolver.h"
       "RetValue != 0"
# 258 "/app/abc/src/sat/bsat/satSolver.h" 3 4
       , "/app/abc/src/sat/bsat/satSolver.h", 258, __extension__ __PRETTY_FUNCTION__); }))
# 258 "/app/abc/src/sat/bsat/satSolver.h"
                              ;
        (void) RetValue;
    }
}
static inline void sat_solver_delete_p( sat_solver ** ps )
{
    if ( *ps )
        sat_solver_delete( *ps );
    *ps = 
# 266 "/app/abc/src/sat/bsat/satSolver.h" 3 4
         ((void *)0)
# 266 "/app/abc/src/sat/bsat/satSolver.h"
             ;
}
static inline void sat_solver_clean_polarity(sat_solver* s, int * pVars, int nVars )
{
    int i;
    for ( i = 0; i < nVars; i++ )
        s->polarity[pVars[i]] = 0;
}
static inline void sat_solver_set_polarity(sat_solver* s, int * pVars, int nVars )
{
    int i;
    for ( i = 0; i < s->size; i++ )
        s->polarity[i] = 0;
    for ( i = 0; i < nVars; i++ )
        s->polarity[pVars[i]] = 1;
}
static inline void sat_solver_set_literal_polarity(sat_solver* s, int * pLits, int nLits )
{
    int i;
    for ( i = 0; i < nLits; i++ )
        s->polarity[Abc_Lit2Var(pLits[i])] = !Abc_LitIsCompl(pLits[i]);
}

static inline int sat_solver_final(sat_solver* s, int ** ppArray)
{
    *ppArray = s->conf_final.ptr;
    return s->conf_final.size;
}

static inline void sat_solver_randomize( sat_solver * pSat, int iVar, int nVars )
{
    int i, nPols = 0, * pVars = ((int *) malloc(sizeof(int) * (size_t)(nVars)));
    for ( i = 0; i < nVars; i++ )
        if ( Abc_Random(0) & 1 )
            pVars[nPols++] = iVar + i;
    sat_solver_set_polarity( pSat, pVars, nPols );
    for ( i = 0; i < nVars; i++ )
        pVars[i] = iVar + i;
    for ( i = 0; i < nVars; i++ )
    {
        int j = Abc_Random(0) % nVars;
        { int t = pVars[i]; pVars[i] = pVars[j]; pVars[j] = t; };
    }
    sat_solver_set_var_activity( pSat, pVars, nVars );
    ((pVars) ? (free((char *) (pVars)), (pVars) = 0) : 0);
}

static inline abctime sat_solver_set_runtime_limit(sat_solver* s, abctime Limit)
{
    abctime nRuntimeLimit = s->nRuntimeLimit;
    s->nRuntimeLimit = Limit;
    return nRuntimeLimit;
}

static inline int sat_solver_set_random(sat_solver* s, int fNotUseRandom)
{
    int fNotUseRandomOld = s->fNotUseRandom;
    s->fNotUseRandom = fNotUseRandom;
    return fNotUseRandomOld;
}

static inline void sat_solver_bookmark(sat_solver* s)
{
    
# 329 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 329 "/app/abc/src/sat/bsat/satSolver.h"
   s->qhead == s->qtail
# 329 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 329 "/app/abc/src/sat/bsat/satSolver.h"
   s->qhead == s->qtail
# 329 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 329 "/app/abc/src/sat/bsat/satSolver.h"
   "s->qhead == s->qtail"
# 329 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 329, __extension__ __PRETTY_FUNCTION__); }))
# 329 "/app/abc/src/sat/bsat/satSolver.h"
                                 ;
    s->iVarPivot = s->size;
    s->iTrailPivot = s->qhead;
    Sat_MemBookMark( &s->Mem );
    if ( s->activity2 )
    {
        s->var_inc2 = s->var_inc;
        memcpy( s->activity2, s->activity, sizeof(word) * s->iVarPivot );
    }
}
static inline void sat_solver_set_pivot_variables( sat_solver* s, int * pPivots, int nPivots )
{
    s->pivot_vars.cap = nPivots;
    s->pivot_vars.size = nPivots;
    s->pivot_vars.ptr = pPivots;
}
static inline int sat_solver_count_usedvars(sat_solver* s)
{
    int i, nVars = 0;
    for ( i = 0; i < s->size; i++ )
        if ( s->pFreqs[i] )
        {
            s->pFreqs[i] = 0;
            nVars++;
        }
    return nVars;
}
static inline void sat_solver_set_runid( sat_solver *s, int id )
{
    s->RunId = id;
}
static inline void sat_solver_set_stop_func( sat_solver *s, int (*fnct)(int) )
{
    s->pFuncStop = fnct;
}

static inline int sat_solver_add_const( sat_solver * pSat, int iVar, int fCompl )
{
    lit Lits[1];
    int Cid;
    
# 369 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 369 "/app/abc/src/sat/bsat/satSolver.h"
   iVar >= 0
# 369 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 369 "/app/abc/src/sat/bsat/satSolver.h"
   iVar >= 0
# 369 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 369 "/app/abc/src/sat/bsat/satSolver.h"
   "iVar >= 0"
# 369 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 369, __extension__ __PRETTY_FUNCTION__); }))
# 369 "/app/abc/src/sat/bsat/satSolver.h"
                      ;

    Lits[0] = toLitCond( iVar, fCompl );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 1 );
    
# 373 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 373 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 373 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 373 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 373 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 373 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 373 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 373, __extension__ __PRETTY_FUNCTION__); }))
# 373 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 1;
}
static inline int sat_solver_add_buffer( sat_solver * pSat, int iVarA, int iVarB, int fCompl )
{
    lit Lits[2];
    int Cid;
    
# 380 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 380 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0
# 380 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 380 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0
# 380 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 380 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarA >= 0 && iVarB >= 0"
# 380 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 380, __extension__ __PRETTY_FUNCTION__); }))
# 380 "/app/abc/src/sat/bsat/satSolver.h"
                                     ;

    Lits[0] = toLitCond( iVarA, 0 );
    Lits[1] = toLitCond( iVarB, !fCompl );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    if ( Cid == 0 )
        return 0;
    
# 387 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 387 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 387 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 387 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 387 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 387 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 387 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 387, __extension__ __PRETTY_FUNCTION__); }))
# 387 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, 1 );
    Lits[1] = toLitCond( iVarB, fCompl );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    if ( Cid == 0 )
        return 0;
    
# 394 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 394 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 394 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 394 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 394 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 394 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 394 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 394, __extension__ __PRETTY_FUNCTION__); }))
# 394 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 2;
}
static inline int sat_solver_add_buffer_enable( sat_solver * pSat, int iVarA, int iVarB, int iVarEn, int fCompl )
{
    lit Lits[3];
    int Cid;
    
# 401 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 401 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0 && iVarEn >= 0
# 401 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 401 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0 && iVarEn >= 0
# 401 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 401 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarA >= 0 && iVarB >= 0 && iVarEn >= 0"
# 401 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 401, __extension__ __PRETTY_FUNCTION__); }))
# 401 "/app/abc/src/sat/bsat/satSolver.h"
                                                    ;

    Lits[0] = toLitCond( iVarA, 0 );
    Lits[1] = toLitCond( iVarB, !fCompl );
    Lits[2] = toLitCond( iVarEn, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 407 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 407 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 407 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 407 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 407 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 407 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 407 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 407, __extension__ __PRETTY_FUNCTION__); }))
# 407 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, 1 );
    Lits[1] = toLitCond( iVarB, fCompl );
    Lits[2] = toLitCond( iVarEn, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 413 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 413 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 413 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 413 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 413 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 413 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 413 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 413, __extension__ __PRETTY_FUNCTION__); }))
# 413 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 2;
}
static inline int sat_solver_add_and( sat_solver * pSat, int iVar, int iVar0, int iVar1, int fCompl0, int fCompl1, int fCompl )
{
    lit Lits[3];
    int Cid;

    Lits[0] = toLitCond( iVar, !fCompl );
    Lits[1] = toLitCond( iVar0, fCompl0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 424 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 424 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 424 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 424 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 424 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 424 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 424 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 424, __extension__ __PRETTY_FUNCTION__); }))
# 424 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVar, !fCompl );
    Lits[1] = toLitCond( iVar1, fCompl1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 429 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 429 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 429 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 429 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 429 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 429 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 429 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 429, __extension__ __PRETTY_FUNCTION__); }))
# 429 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVar, fCompl );
    Lits[1] = toLitCond( iVar0, !fCompl0 );
    Lits[2] = toLitCond( iVar1, !fCompl1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 435 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 435 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 435 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 435 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 435 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 435 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 435 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 435, __extension__ __PRETTY_FUNCTION__); }))
# 435 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 3;
}
static inline int sat_solver_add_xor( sat_solver * pSat, int iVarA, int iVarB, int iVarC, int fCompl )
{
    lit Lits[3];
    int Cid;
    
# 442 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 442 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0 && iVarC >= 0
# 442 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 442 "/app/abc/src/sat/bsat/satSolver.h"
   iVarA >= 0 && iVarB >= 0 && iVarC >= 0
# 442 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 442 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarA >= 0 && iVarB >= 0 && iVarC >= 0"
# 442 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 442, __extension__ __PRETTY_FUNCTION__); }))
# 442 "/app/abc/src/sat/bsat/satSolver.h"
                                                   ;

    Lits[0] = toLitCond( iVarA, !fCompl );
    Lits[1] = toLitCond( iVarB, 1 );
    Lits[2] = toLitCond( iVarC, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 448 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 448 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 448 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 448 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 448 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 448 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 448 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 448, __extension__ __PRETTY_FUNCTION__); }))
# 448 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, !fCompl );
    Lits[1] = toLitCond( iVarB, 0 );
    Lits[2] = toLitCond( iVarC, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 454 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 454 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 454 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 454 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 454 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 454 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 454 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 454, __extension__ __PRETTY_FUNCTION__); }))
# 454 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, fCompl );
    Lits[1] = toLitCond( iVarB, 1 );
    Lits[2] = toLitCond( iVarC, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 460 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 460 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 460 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 460 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 460 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 460 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 460 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 460, __extension__ __PRETTY_FUNCTION__); }))
# 460 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, fCompl );
    Lits[1] = toLitCond( iVarB, 0 );
    Lits[2] = toLitCond( iVarC, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 466 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 466 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 466 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 466 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 466 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 466 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 466 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 466, __extension__ __PRETTY_FUNCTION__); }))
# 466 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 4;
}
static inline int sat_solver_add_mux( sat_solver * pSat, int iVarZ, int iVarC, int iVarT, int iVarE, int iComplC, int iComplT, int iComplE, int iComplZ )
{
    lit Lits[3];
    int Cid;
    
# 473 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 473 "/app/abc/src/sat/bsat/satSolver.h"
   iVarC >= 0 && iVarT >= 0 && iVarE >= 0 && iVarZ >= 0
# 473 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 473 "/app/abc/src/sat/bsat/satSolver.h"
   iVarC >= 0 && iVarT >= 0 && iVarE >= 0 && iVarZ >= 0
# 473 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 473 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarC >= 0 && iVarT >= 0 && iVarE >= 0 && iVarZ >= 0"
# 473 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 473, __extension__ __PRETTY_FUNCTION__); }))
# 473 "/app/abc/src/sat/bsat/satSolver.h"
                                                                 ;

    Lits[0] = toLitCond( iVarC, 1 ^ iComplC );
    Lits[1] = toLitCond( iVarT, 1 ^ iComplT );
    Lits[2] = toLitCond( iVarZ, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 479 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 479 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 479 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 479 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 479 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 479 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 479 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 479, __extension__ __PRETTY_FUNCTION__); }))
# 479 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarC, 1 ^ iComplC );
    Lits[1] = toLitCond( iVarT, 0 ^ iComplT );
    Lits[2] = toLitCond( iVarZ, 1 ^ iComplZ );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 485 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 485 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 485 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 485 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 485 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 485 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 485 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 485, __extension__ __PRETTY_FUNCTION__); }))
# 485 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarC, 0 ^ iComplC );
    Lits[1] = toLitCond( iVarE, 1 ^ iComplE );
    Lits[2] = toLitCond( iVarZ, 0 ^ iComplZ );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 491 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 491 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 491 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 491 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 491 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 491 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 491 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 491, __extension__ __PRETTY_FUNCTION__); }))
# 491 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarC, 0 ^ iComplC );
    Lits[1] = toLitCond( iVarE, 0 ^ iComplE );
    Lits[2] = toLitCond( iVarZ, 1 ^ iComplZ );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 497 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 497 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 497 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 497 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 497 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 497 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 497 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 497, __extension__ __PRETTY_FUNCTION__); }))
# 497 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    if ( iVarT == iVarE )
        return 4;

    Lits[0] = toLitCond( iVarT, 0 ^ iComplT );
    Lits[1] = toLitCond( iVarE, 0 ^ iComplE );
    Lits[2] = toLitCond( iVarZ, 1 ^ iComplZ );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 506 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 506 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 506 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 506 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 506 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 506 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 506 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 506, __extension__ __PRETTY_FUNCTION__); }))
# 506 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarT, 1 ^ iComplT );
    Lits[1] = toLitCond( iVarE, 1 ^ iComplE );
    Lits[2] = toLitCond( iVarZ, 0 ^ iComplZ );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 512 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 512 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 512 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 512 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 512 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 512 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 512 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 512, __extension__ __PRETTY_FUNCTION__); }))
# 512 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 6;
}
static inline int sat_solver_add_mux41( sat_solver * pSat, int iVarZ, int iVarC0, int iVarC1, int iVarD0, int iVarD1, int iVarD2, int iVarD3 )
{
    lit Lits[4];
    int Cid;
    
# 519 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 519 "/app/abc/src/sat/bsat/satSolver.h"
   iVarC0 >= 0 && iVarC1 >= 0 && iVarD0 >= 0 && iVarD1 >= 0 && iVarD2 >= 0 && iVarD3 >= 0 && iVarZ >= 0
# 519 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 519 "/app/abc/src/sat/bsat/satSolver.h"
   iVarC0 >= 0 && iVarC1 >= 0 && iVarD0 >= 0 && iVarD1 >= 0 && iVarD2 >= 0 && iVarD3 >= 0 && iVarZ >= 0
# 519 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 519 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarC0 >= 0 && iVarC1 >= 0 && iVarD0 >= 0 && iVarD1 >= 0 && iVarD2 >= 0 && iVarD3 >= 0 && iVarZ >= 0"
# 519 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 519, __extension__ __PRETTY_FUNCTION__); }))
# 519 "/app/abc/src/sat/bsat/satSolver.h"
                                                                                                                 ;

    Lits[0] = toLitCond( iVarD0, 1 );
    Lits[1] = toLitCond( iVarC0, 0 );
    Lits[2] = toLitCond( iVarC1, 0 );
    Lits[3] = toLitCond( iVarZ, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 526 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 526 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 526 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 526 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 526 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 526 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 526 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 526, __extension__ __PRETTY_FUNCTION__); }))
# 526 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD1, 1 );
    Lits[1] = toLitCond( iVarC0, 1 );
    Lits[2] = toLitCond( iVarC1, 0 );
    Lits[3] = toLitCond( iVarZ, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 533 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 533 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 533 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 533 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 533 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 533 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 533 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 533, __extension__ __PRETTY_FUNCTION__); }))
# 533 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD2, 1 );
    Lits[1] = toLitCond( iVarC0, 0 );
    Lits[2] = toLitCond( iVarC1, 1 );
    Lits[3] = toLitCond( iVarZ, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 540 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 540 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 540 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 540 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 540 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 540 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 540 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 540, __extension__ __PRETTY_FUNCTION__); }))
# 540 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD3, 1 );
    Lits[1] = toLitCond( iVarC0, 1 );
    Lits[2] = toLitCond( iVarC1, 1 );
    Lits[3] = toLitCond( iVarZ, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 547 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 547 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 547 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 547 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 547 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 547 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 547 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 547, __extension__ __PRETTY_FUNCTION__); }))
# 547 "/app/abc/src/sat/bsat/satSolver.h"
                ;


    Lits[0] = toLitCond( iVarD0, 0 );
    Lits[1] = toLitCond( iVarC0, 0 );
    Lits[2] = toLitCond( iVarC1, 0 );
    Lits[3] = toLitCond( iVarZ, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 555 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 555 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 555 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 555 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 555 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 555 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 555 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 555, __extension__ __PRETTY_FUNCTION__); }))
# 555 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD1, 0 );
    Lits[1] = toLitCond( iVarC0, 1 );
    Lits[2] = toLitCond( iVarC1, 0 );
    Lits[3] = toLitCond( iVarZ, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 562 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 562 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 562 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 562 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 562 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 562 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 562 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 562, __extension__ __PRETTY_FUNCTION__); }))
# 562 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD2, 0 );
    Lits[1] = toLitCond( iVarC0, 0 );
    Lits[2] = toLitCond( iVarC1, 1 );
    Lits[3] = toLitCond( iVarZ, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 569 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 569 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 569 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 569 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 569 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 569 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 569 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 569, __extension__ __PRETTY_FUNCTION__); }))
# 569 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarD3, 0 );
    Lits[1] = toLitCond( iVarC0, 1 );
    Lits[2] = toLitCond( iVarC1, 1 );
    Lits[3] = toLitCond( iVarZ, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 576 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 576 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 576 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 576 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 576 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 576 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 576 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 576, __extension__ __PRETTY_FUNCTION__); }))
# 576 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 8;
}
static inline int sat_solver_add_xor_and( sat_solver * pSat, int iVarF, int iVarA, int iVarB, int iVarC )
{

    lit Lits[4];
    int Cid;
    
# 584 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 584 "/app/abc/src/sat/bsat/satSolver.h"
   iVarF >= 0 && iVarA >= 0 && iVarB >= 0 && iVarC >= 0
# 584 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 584 "/app/abc/src/sat/bsat/satSolver.h"
   iVarF >= 0 && iVarA >= 0 && iVarB >= 0 && iVarC >= 0
# 584 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 584 "/app/abc/src/sat/bsat/satSolver.h"
   "iVarF >= 0 && iVarA >= 0 && iVarB >= 0 && iVarC >= 0"
# 584 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 584, __extension__ __PRETTY_FUNCTION__); }))
# 584 "/app/abc/src/sat/bsat/satSolver.h"
                                                                 ;

    Lits[0] = toLitCond( iVarF, 1 );
    Lits[1] = toLitCond( iVarA, 1 );
    Lits[2] = toLitCond( iVarB, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 590 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 590 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 590 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 590 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 590 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 590 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 590 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 590, __extension__ __PRETTY_FUNCTION__); }))
# 590 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarF, 1 );
    Lits[1] = toLitCond( iVarA, 0 );
    Lits[2] = toLitCond( iVarB, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 596 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 596 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 596 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 596 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 596 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 596 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 596 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 596, __extension__ __PRETTY_FUNCTION__); }))
# 596 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarF, 1 );
    Lits[1] = toLitCond( iVarC, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 601 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 601 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 601 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 601 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 601 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 601 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 601 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 601, __extension__ __PRETTY_FUNCTION__); }))
# 601 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarF, 0 );
    Lits[1] = toLitCond( iVarA, 1 );
    Lits[2] = toLitCond( iVarB, 0 );
    Lits[3] = toLitCond( iVarC, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 608 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 608 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 608 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 608 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 608 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 608 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 608 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 608, __extension__ __PRETTY_FUNCTION__); }))
# 608 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarF, 0 );
    Lits[1] = toLitCond( iVarA, 0 );
    Lits[2] = toLitCond( iVarB, 1 );
    Lits[3] = toLitCond( iVarC, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 4 );
    
# 615 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 615 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 615 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 615 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 615 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 615 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 615 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 615, __extension__ __PRETTY_FUNCTION__); }))
# 615 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 5;
}
static inline int sat_solver_add_constraint( sat_solver * pSat, int iVar, int iVar2, int fCompl )
{
    lit Lits[2];
    int Cid;
    
# 622 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 622 "/app/abc/src/sat/bsat/satSolver.h"
   iVar >= 0
# 622 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 622 "/app/abc/src/sat/bsat/satSolver.h"
   iVar >= 0
# 622 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 622 "/app/abc/src/sat/bsat/satSolver.h"
   "iVar >= 0"
# 622 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 622, __extension__ __PRETTY_FUNCTION__); }))
# 622 "/app/abc/src/sat/bsat/satSolver.h"
                      ;

    Lits[0] = toLitCond( iVar, fCompl );
    Lits[1] = toLitCond( iVar2, 0 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 627 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 627 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 627 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 627 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 627 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 627 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 627 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 627, __extension__ __PRETTY_FUNCTION__); }))
# 627 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVar, fCompl );
    Lits[1] = toLitCond( iVar2, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 632 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 632 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 632 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 632 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 632 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 632 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 632 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 632, __extension__ __PRETTY_FUNCTION__); }))
# 632 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 2;
}

static inline int sat_solver_add_half_sorter( sat_solver * pSat, int iVarA, int iVarB, int iVar0, int iVar1 )
{
    lit Lits[3];
    int Cid;

    Lits[0] = toLitCond( iVarA, 0 );
    Lits[1] = toLitCond( iVar0, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 644 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 644 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 644 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 644 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 644 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 644 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 644 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 644, __extension__ __PRETTY_FUNCTION__); }))
# 644 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarA, 0 );
    Lits[1] = toLitCond( iVar1, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 2 );
    
# 649 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 649 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 649 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 649 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 649 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 649 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 649 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 649, __extension__ __PRETTY_FUNCTION__); }))
# 649 "/app/abc/src/sat/bsat/satSolver.h"
                ;

    Lits[0] = toLitCond( iVarB, 0 );
    Lits[1] = toLitCond( iVar0, 1 );
    Lits[2] = toLitCond( iVar1, 1 );
    Cid = sat_solver_addclause( pSat, Lits, Lits + 3 );
    
# 655 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ((void) sizeof ((
# 655 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 655 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 655 "/app/abc/src/sat/bsat/satSolver.h"
   Cid
# 655 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   ) ; else __assert_fail (
# 655 "/app/abc/src/sat/bsat/satSolver.h"
   "Cid"
# 655 "/app/abc/src/sat/bsat/satSolver.h" 3 4
   , "/app/abc/src/sat/bsat/satSolver.h", 655, __extension__ __PRETTY_FUNCTION__); }))
# 655 "/app/abc/src/sat/bsat/satSolver.h"
                ;
    return 3;
}



# 38 "/app/abc/src/proof/fra/fra.h" 2
# 1 "/app/abc/src/aig/ioa/ioa.h" 1
# 32 "/app/abc/src/aig/ioa/ioa.h"
# 1 "/usr/include/assert.h" 1 3 4
# 33 "/app/abc/src/aig/ioa/ioa.h" 2
# 44 "/app/abc/src/aig/ioa/ioa.h"

# 64 "/app/abc/src/aig/ioa/ioa.h"
extern Aig_Man_t * Ioa_ReadAigerFromMemory( char * pContents, int nFileSize, int fCheck );
extern Aig_Man_t * Ioa_ReadAiger( char * pFileName, int fCheck );

extern Vec_Str_t * Ioa_WriteAigerIntoMemoryStr( Aig_Man_t * pMan );
extern char * Ioa_WriteAigerIntoMemory( Aig_Man_t * pMan, int * pnSize );
extern void Ioa_WriteAiger( Aig_Man_t * pMan, char * pFileName, int fWriteSymbols, int fCompact );

extern int Ioa_FileSize( char * pFileName );
extern char * Ioa_FileNameGeneric( char * FileName );
extern char * Ioa_FileNameGenericAppend( char * pBase, char * pSuffix );
extern char * Ioa_TimeStamp();




# 39 "/app/abc/src/proof/fra/fra.h" 2














typedef struct Fra_Par_t_ Fra_Par_t;
typedef struct Fra_Ssw_t_ Fra_Ssw_t;
typedef struct Fra_Sec_t_ Fra_Sec_t;
typedef struct Fra_Man_t_ Fra_Man_t;
typedef struct Fra_Cla_t_ Fra_Cla_t;
typedef struct Fra_Sml_t_ Fra_Sml_t;
typedef struct Fra_Bmc_t_ Fra_Bmc_t;


struct Fra_Par_t_
{
    int nSimWords;
    double dSimSatur;
    int fPatScores;
    int MaxScore;
    double dActConeRatio;
    double dActConeBumpMax;
    int fChoicing;
    int fSpeculate;
    int fProve;
    int fVerbose;
    int fDoSparse;
    int fConeBias;
    int nBTLimitNode;
    int nBTLimitMiter;
    int nLevelMax;
    int nFramesP;
    int nFramesK;
    int nMaxImps;
    int nMaxLevs;
    int fRewrite;
    int fLatchCorr;
    int fUseImps;
    int fUse1Hot;
    int fWriteImps;
    int fDontShowBar;
};


struct Fra_Ssw_t_
{
    int nPartSize;
    int nOverSize;
    int nFramesP;
    int nFramesK;
    int nMaxImps;
    int nMaxLevs;
    int nMinDomSize;
    int fUseImps;
    int fRewrite;
    int fFraiging;
    int fLatchCorr;
    int fWriteImps;
    int fUse1Hot;
    int fVerbose;
    int fSilent;
    int nIters;
    float TimeLimit;
};


struct Fra_Sec_t_
{
    int fTryComb;
    int fTryBmc;
    int nFramesMax;
    int nBTLimit;
    int nBTLimitGlobal;
    int nBTLimitInter;
    int nBddVarsMax;
    int nBddMax;
    int nBddIterMax;
    int nPdrTimeout;
    int fPhaseAbstract;
    int fRetimeFirst;
    int fRetimeRegs;
    int fFraiging;
    int fInduction;
    int fInterpolation;
    int fInterSeparate;
    int fReachability;
    int fReorderImage;
    int fStopOnFirstFail;
    int fUseNewProver;
    int fUsePdr;
    int fSilent;
    int fVerbose;
    int fVeryVerbose;
    int TimeLimit;
    int fReadUnsolved;
    int nSMnumber;

    int fRecursive;
    int fReportSolution;
};


struct Fra_Cla_t_
{
    Aig_Man_t * pAig;
    Aig_Obj_t ** pMemRepr;
    Vec_Ptr_t * vClasses;
    Vec_Ptr_t * vClasses1;
    Vec_Ptr_t * vClassesTemp;
    Aig_Obj_t ** pMemClasses;
    Aig_Obj_t ** pMemClassesFree;
    Vec_Ptr_t * vClassOld;
    Vec_Ptr_t * vClassNew;
    int nPairs;
    int fRefinement;
    Vec_Int_t * vImps;

    int (*pFuncNodeHash) (Aig_Obj_t *, int);
    int (*pFuncNodeIsConst) (Aig_Obj_t *);
    int (*pFuncNodesAreEqual)(Aig_Obj_t *, Aig_Obj_t *);
};


struct Fra_Sml_t_
{
    Aig_Man_t * pAig;
    int nPref;
    int nFrames;
    int nWordsFrame;
    int nWordsTotal;
    int nWordsPref;
    int fNonConstOut;
    int nSimRounds;
    int timeSim;
    unsigned pData[0];
};


struct Fra_Man_t_
{

    Fra_Par_t * pPars;

    Aig_Man_t * pManAig;
    Aig_Man_t * pManFraig;

    int nFramesAll;
    Aig_Obj_t ** pMemFraig;
    int nSizeAlloc;

    Fra_Cla_t * pCla;

    Fra_Sml_t * pSml;

    Fra_Bmc_t * pBmc;

    int nPatWords;
    unsigned * pPatWords;
    Vec_Int_t * vCex;

    Vec_Int_t * vOneHots;

    sat_solver * pSat;
    int nSatVars;
    Vec_Ptr_t * vPiVars;
    ABC_INT64_T nBTLimitGlobal;
    ABC_INT64_T nInsLimitGlobal;
    Vec_Ptr_t ** pMemFanins;
    int * pMemSatNums;
    int nMemAlloc;
    Vec_Ptr_t * vTimeouts;

    int nSimRounds;
    int nNodesMiter;
    int nLitsBeg;
    int nLitsEnd;
    int nNodesBeg;
    int nNodesEnd;
    int nRegsBeg;
    int nRegsEnd;
    int nSatCalls;
    int nSatCallsSat;
    int nSatCallsUnsat;
    int nSatProof;
    int nSatFails;
    int nSatFailsReal;
    int nSpeculs;
    int nChoices;
    int nChoicesFake;
    int nSatCallsRecent;
    int nSatCallsSkipped;

    abctime timeSim;
    abctime timeTrav;
    abctime timeRwr;
    abctime timeSat;
    abctime timeSatUnsat;
    abctime timeSatSat;
    abctime timeSatFail;
    abctime timeRef;
    abctime timeTotal;
    abctime time1;
    abctime time2;
};





static inline unsigned * Fra_ObjSim( Fra_Sml_t * p, int Id ) { return p->pData + p->nWordsTotal * Id; }
static inline unsigned Fra_ObjRandomSim() { return Aig_ManRandom(0); }

static inline Aig_Obj_t * Fra_ObjFraig( Aig_Obj_t * pObj, int i ) { return ((Fra_Man_t *)pObj->pData)->pMemFraig[((Fra_Man_t *)pObj->pData)->nFramesAll*pObj->Id + i]; }
static inline void Fra_ObjSetFraig( Aig_Obj_t * pObj, int i, Aig_Obj_t * pNode ) { ((Fra_Man_t *)pObj->pData)->pMemFraig[((Fra_Man_t *)pObj->pData)->nFramesAll*pObj->Id + i] = pNode; }

static inline Vec_Ptr_t * Fra_ObjFaninVec( Aig_Obj_t * pObj ) { return ((Fra_Man_t *)pObj->pData)->pMemFanins[pObj->Id]; }
static inline void Fra_ObjSetFaninVec( Aig_Obj_t * pObj, Vec_Ptr_t * vFanins ) { ((Fra_Man_t *)pObj->pData)->pMemFanins[pObj->Id] = vFanins; }

static inline int Fra_ObjSatNum( Aig_Obj_t * pObj ) { return ((Fra_Man_t *)pObj->pData)->pMemSatNums[pObj->Id]; }
static inline void Fra_ObjSetSatNum( Aig_Obj_t * pObj, int Num ) { ((Fra_Man_t *)pObj->pData)->pMemSatNums[pObj->Id] = Num; }

static inline Aig_Obj_t * Fra_ClassObjRepr( Aig_Obj_t * pObj ) { return ((Fra_Man_t *)pObj->pData)->pCla->pMemRepr[pObj->Id]; }
static inline void Fra_ClassObjSetRepr( Aig_Obj_t * pObj, Aig_Obj_t * pNode ) { ((Fra_Man_t *)pObj->pData)->pCla->pMemRepr[pObj->Id] = pNode; }

static inline Aig_Obj_t * Fra_ObjChild0Fra( Aig_Obj_t * pObj, int i ) { 
# 272 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ((void) sizeof ((
# 272 "/app/abc/src/proof/fra/fra.h"
                                                                        !Aig_IsComplement(pObj)
# 272 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ) ? 1 : 0), __extension__ ({ if (
# 272 "/app/abc/src/proof/fra/fra.h"
                                                                        !Aig_IsComplement(pObj)
# 272 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ) ; else __assert_fail (
# 272 "/app/abc/src/proof/fra/fra.h"
                                                                        "!Aig_IsComplement(pObj)"
# 272 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        , "/app/abc/src/proof/fra/fra.h", 272, __extension__ __PRETTY_FUNCTION__); }))
# 272 "/app/abc/src/proof/fra/fra.h"
                                                                                                         ; return Aig_ObjFanin0(pObj)? Aig_NotCond(Fra_ObjFraig(Aig_ObjFanin0(pObj),i), Aig_ObjFaninC0(pObj)) : 
# 272 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                                                                                                                                                                ((void *)0)
# 272 "/app/abc/src/proof/fra/fra.h"
                                                                                                                                                                                                                    ; }
static inline Aig_Obj_t * Fra_ObjChild1Fra( Aig_Obj_t * pObj, int i ) { 
# 273 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ((void) sizeof ((
# 273 "/app/abc/src/proof/fra/fra.h"
                                                                        !Aig_IsComplement(pObj)
# 273 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ) ? 1 : 0), __extension__ ({ if (
# 273 "/app/abc/src/proof/fra/fra.h"
                                                                        !Aig_IsComplement(pObj)
# 273 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        ) ; else __assert_fail (
# 273 "/app/abc/src/proof/fra/fra.h"
                                                                        "!Aig_IsComplement(pObj)"
# 273 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                        , "/app/abc/src/proof/fra/fra.h", 273, __extension__ __PRETTY_FUNCTION__); }))
# 273 "/app/abc/src/proof/fra/fra.h"
                                                                                                         ; return Aig_ObjFanin1(pObj)? Aig_NotCond(Fra_ObjFraig(Aig_ObjFanin1(pObj),i), Aig_ObjFaninC1(pObj)) : 
# 273 "/app/abc/src/proof/fra/fra.h" 3 4
                                                                                                                                                                                                                ((void *)0)
# 273 "/app/abc/src/proof/fra/fra.h"
                                                                                                                                                                                                                    ; }

static inline int Fra_ImpLeft( int Imp ) { return Imp & 0xFFFF; }
static inline int Fra_ImpRight( int Imp ) { return Imp >> 16; }
static inline int Fra_ImpCreate( int Left, int Right ) { return (Right << 16) | Left; }
# 288 "/app/abc/src/proof/fra/fra.h"
extern int Fra_FraigSat( Aig_Man_t * pMan, ABC_INT64_T nConfLimit, ABC_INT64_T nInsLimit, int nLearnedStart, int nLearnedDelta, int nLearnedPerce, int fFlipBits, int fAndOuts, int fNewSolver, int fVerbose );
extern int Fra_FraigCec( Aig_Man_t ** ppAig, int nConfLimit, int fVerbose );
extern int Fra_FraigCecPartitioned( Aig_Man_t * pMan1, Aig_Man_t * pMan2, int nConfLimit, int nPartSize, int fSmart, int fVerbose );

extern int Fra_BmcNodeIsConst( Aig_Obj_t * pObj );
extern int Fra_BmcNodesAreEqual( Aig_Obj_t * pObj0, Aig_Obj_t * pObj1 );
extern void Fra_BmcStop( Fra_Bmc_t * p );
extern void Fra_BmcPerform( Fra_Man_t * p, int nPref, int nDepth );
extern void Fra_BmcPerformSimple( Aig_Man_t * pAig, int nFrames, int nBTLimit, int fRewrite, int fVerbose );

extern Fra_Cla_t * Fra_ClassesStart( Aig_Man_t * pAig );
extern void Fra_ClassesStop( Fra_Cla_t * p );
extern void Fra_ClassesCopyReprs( Fra_Cla_t * p, Vec_Ptr_t * vFailed );
extern void Fra_ClassesPrint( Fra_Cla_t * p, int fVeryVerbose );
extern void Fra_ClassesPrepare( Fra_Cla_t * p, int fLatchCorr, int nMaxLevs );
extern int Fra_ClassesRefine( Fra_Cla_t * p );
extern int Fra_ClassesRefine1( Fra_Cla_t * p, int fRefineNewClass, int * pSkipped );
extern int Fra_ClassesCountLits( Fra_Cla_t * p );
extern int Fra_ClassesCountPairs( Fra_Cla_t * p );
extern void Fra_ClassesTest( Fra_Cla_t * p, int Id1, int Id2 );
extern void Fra_ClassesLatchCorr( Fra_Man_t * p );
extern void Fra_ClassesPostprocess( Fra_Cla_t * p );
extern void Fra_ClassesSelectRepr( Fra_Cla_t * p );
extern Aig_Man_t * Fra_ClassesDeriveAig( Fra_Cla_t * p, int nFramesK );

extern void Fra_CnfNodeAddToSolver( Fra_Man_t * p, Aig_Obj_t * pOld, Aig_Obj_t * pNew );

extern void Fra_FraigSweep( Fra_Man_t * pManAig );
extern int Fra_FraigMiterStatus( Aig_Man_t * p );
extern int Fra_FraigMiterAssertedOutput( Aig_Man_t * p );
extern Aig_Man_t * Fra_FraigPerform( Aig_Man_t * pManAig, Fra_Par_t * pPars );
extern Aig_Man_t * Fra_FraigChoice( Aig_Man_t * pManAig, int nConfMax, int nLevelMax );
extern Aig_Man_t * Fra_FraigEquivence( Aig_Man_t * pManAig, int nConfMax, int fProve );

extern Vec_Int_t * Fra_OneHotCompute( Fra_Man_t * p, Fra_Sml_t * pSim );
extern void Fra_OneHotAssume( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern void Fra_OneHotCheck( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern int Fra_OneHotRefineUsingCex( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern int Fra_OneHotCount( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern void Fra_OneHotEstimateCoverage( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern Aig_Man_t * Fra_OneHotCreateExdc( Fra_Man_t * p, Vec_Int_t * vOneHots );
extern void Fra_OneHotAddKnownConstraint( Fra_Man_t * p, Vec_Ptr_t * vOnehots );

extern Vec_Int_t * Fra_ImpDerive( Fra_Man_t * p, int nImpMaxLimit, int nImpUseLimit, int fLatchCorr );
extern void Fra_ImpAddToSolver( Fra_Man_t * p, Vec_Int_t * vImps, int * pSatVarNums );
extern int Fra_ImpCheckForNode( Fra_Man_t * p, Vec_Int_t * vImps, Aig_Obj_t * pNode, int Pos );
extern int Fra_ImpRefineUsingCex( Fra_Man_t * p, Vec_Int_t * vImps );
extern void Fra_ImpCompactArray( Vec_Int_t * vImps );
extern double Fra_ImpComputeStateSpaceRatio( Fra_Man_t * p );
extern int Fra_ImpVerifyUsingSimulation( Fra_Man_t * p );
extern void Fra_ImpRecordInManager( Fra_Man_t * p, Aig_Man_t * pNew );

extern Aig_Man_t * Fra_FraigInduction( Aig_Man_t * p, Fra_Ssw_t * pPars );

extern int Fra_InvariantVerify( Aig_Man_t * p, int nFrames, Vec_Int_t * vClauses, Vec_Int_t * vLits );

extern Aig_Man_t * Fra_FraigLatchCorrespondence( Aig_Man_t * pAig, int nFramesP, int nConfMax, int fProve, int fVerbose, int * pnIter, float TimeLimit );

extern void Fra_ParamsDefault( Fra_Par_t * pParams );
extern void Fra_ParamsDefaultSeq( Fra_Par_t * pParams );
extern Fra_Man_t * Fra_ManStart( Aig_Man_t * pManAig, Fra_Par_t * pParams );
extern void Fra_ManClean( Fra_Man_t * p, int nNodesMax );
extern Aig_Man_t * Fra_ManPrepareComb( Fra_Man_t * p );
extern void Fra_ManFinalizeComb( Fra_Man_t * p );
extern void Fra_ManStop( Fra_Man_t * p );
extern void Fra_ManPrint( Fra_Man_t * p );

extern int Fra_NodesAreEquiv( Fra_Man_t * p, Aig_Obj_t * pOld, Aig_Obj_t * pNew );
extern int Fra_NodesAreImp( Fra_Man_t * p, Aig_Obj_t * pOld, Aig_Obj_t * pNew, int fComplL, int fComplR );
extern int Fra_NodesAreClause( Fra_Man_t * p, Aig_Obj_t * pOld, Aig_Obj_t * pNew, int fComplL, int fComplR );
extern int Fra_NodeIsConst( Fra_Man_t * p, Aig_Obj_t * pNew );

extern void Fra_SecSetDefaultParams( Fra_Sec_t * p );
extern int Fra_FraigSec( Aig_Man_t * p, Fra_Sec_t * pParSec, Aig_Man_t ** ppResult );

extern int Fra_SmlNodeHash( Aig_Obj_t * pObj, int nTableSize );
extern int Fra_SmlNodeIsConst( Aig_Obj_t * pObj );
extern int Fra_SmlNodesAreEqual( Aig_Obj_t * pObj0, Aig_Obj_t * pObj1 );
extern int Fra_SmlNodeNotEquWeight( Fra_Sml_t * p, int Left, int Right );
extern int Fra_SmlNodeCountOnes( Fra_Sml_t * p, Aig_Obj_t * pObj );
extern int Fra_SmlCheckOutput( Fra_Man_t * p );
extern void Fra_SmlSavePattern( Fra_Man_t * p );
extern void Fra_SmlSimulate( Fra_Man_t * p, int fInit );
extern void Fra_SmlResimulate( Fra_Man_t * p );
extern Fra_Sml_t * Fra_SmlStart( Aig_Man_t * pAig, int nPref, int nFrames, int nWordsFrame );
extern void Fra_SmlStop( Fra_Sml_t * p );
extern Fra_Sml_t * Fra_SmlSimulateComb( Aig_Man_t * pAig, int nWords, int fCheckMiter );
extern Fra_Sml_t * Fra_SmlSimulateCombGiven( Aig_Man_t * pAig, char * pFileName, int fCheckMiter, int fVerbose );
extern Fra_Sml_t * Fra_SmlSimulateSeq( Aig_Man_t * pAig, int nPref, int nFrames, int nWords, int fCheckMiter );
extern Abc_Cex_t * Fra_SmlGetCounterExample( Fra_Sml_t * p );
extern Abc_Cex_t * Fra_SmlCopyCounterExample( Aig_Man_t * pAig, Aig_Man_t * pFrames, int * pModel );


# 36 "/app/abc/src/base/main/mainInt.h" 2


# 1 "/app/abc/src/bdd/extrab/extraBdd.h" 1
# 44 "/app/abc/src/bdd/extrab/extraBdd.h"
# 1 "/usr/include/assert.h" 1 3 4
# 45 "/app/abc/src/bdd/extrab/extraBdd.h" 2


# 1 "/app/abc/src/bdd/cudd/cuddInt.h" 1
# 72 "/app/abc/src/bdd/cudd/cuddInt.h"
# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4












# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4

# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));




extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));







extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));
# 396 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));





 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));







extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));
# 396 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));







extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));
# 396 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 351 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1263 "/usr/include/math.h" 3 4

# 73 "/app/abc/src/bdd/cudd/cuddInt.h" 2
# 1 "/app/abc/src/bdd/cudd/cudd.h" 1
# 65 "/app/abc/src/bdd/cudd/cudd.h"
# 1 "/app/abc/src/bdd/mtr/mtr.h" 1
# 66 "/app/abc/src/bdd/mtr/mtr.h"

# 126 "/app/abc/src/bdd/mtr/mtr.h"

# 126 "/app/abc/src/bdd/mtr/mtr.h"
typedef unsigned int MtrHalfWord;




typedef struct MtrNode {
    MtrHalfWord flags;
    MtrHalfWord low;
    MtrHalfWord size;
    MtrHalfWord index;
    struct MtrNode *parent;
    struct MtrNode *child;
    struct MtrNode *elder;
    struct MtrNode *younger;
} MtrNode;
# 164 "/app/abc/src/bdd/mtr/mtr.h"
extern MtrNode * Mtr_AllocNode (void);
extern void Mtr_DeallocNode (MtrNode *node);
extern MtrNode * Mtr_InitTree (void);
extern void Mtr_FreeTree (MtrNode *node);
extern MtrNode * Mtr_CopyTree (MtrNode *node, int expansion);
extern void Mtr_MakeFirstChild (MtrNode *parent, MtrNode *child);
extern void Mtr_MakeLastChild (MtrNode *parent, MtrNode *child);
extern MtrNode * Mtr_CreateFirstChild (MtrNode *parent);
extern MtrNode * Mtr_CreateLastChild (MtrNode *parent);
extern void Mtr_MakeNextSibling (MtrNode *first, MtrNode *second);
extern void Mtr_PrintTree (MtrNode *node);
extern MtrNode * Mtr_InitGroupTree (int lower, int size);
extern MtrNode * Mtr_MakeGroup (MtrNode *root, unsigned int low, unsigned int high, unsigned int flags);
extern MtrNode * Mtr_DissolveGroup (MtrNode *group);
extern MtrNode * Mtr_FindGroup (MtrNode *root, unsigned int low, unsigned int high);
extern int Mtr_SwapGroups (MtrNode *first, MtrNode *second);
extern void Mtr_PrintGroups (MtrNode *root, int silent);
extern MtrNode * Mtr_ReadGroups (FILE *fp, int nleaves);




# 66 "/app/abc/src/bdd/cudd/cudd.h" 2
# 1 "/app/abc/src/bdd/epd/epd.h" 1
# 54 "/app/abc/src/bdd/epd/epd.h"

# 85 "/app/abc/src/bdd/epd/epd.h"
struct IeeeDoubleStruct {
  unsigned int mantissa1: 32;
  unsigned int mantissa0: 20;
  unsigned int exponent: 11;
  unsigned int sign: 1;
};
# 111 "/app/abc/src/bdd/epd/epd.h"
struct IeeeNanStruct {
  unsigned int mantissa1: 32;
  unsigned int mantissa0: 19;
  unsigned int quiet_bit: 1;
  unsigned int exponent: 11;
  unsigned int sign: 1;
};
# 129 "/app/abc/src/bdd/epd/epd.h"
union EpTypeUnion {
  double value;
  struct IeeeDoubleStruct bits;
  struct IeeeNanStruct nan;
};

struct EpDoubleStruct {
  union EpTypeUnion type;
  int exponent;
};




typedef struct EpDoubleStruct EpDouble;
typedef struct IeeeDoubleStruct IeeeDouble;
typedef struct IeeeNanStruct IeeeNan;
typedef union EpTypeUnion EpType;







extern EpDouble *EpdAlloc(void);
extern int EpdCmp(const char *key1, const char *key2);
extern void EpdFree(EpDouble *epd);
extern void EpdGetString(EpDouble *epd, char *str);
extern void EpdConvert(double value, EpDouble *epd);
extern void EpdMultiply(EpDouble *epd1, double value);
extern void EpdMultiply2(EpDouble *epd1, EpDouble *epd2);
extern void EpdMultiply2Decimal(EpDouble *epd1, EpDouble *epd2);
extern void EpdMultiply3(EpDouble *epd1, EpDouble *epd2, EpDouble *epd3);
extern void EpdMultiply3Decimal(EpDouble *epd1, EpDouble *epd2, EpDouble *epd3);
extern void EpdDivide(EpDouble *epd1, double value);
extern void EpdDivide2(EpDouble *epd1, EpDouble *epd2);
extern void EpdDivide3(EpDouble *epd1, EpDouble *epd2, EpDouble *epd3);
extern void EpdAdd(EpDouble *epd1, double value);
extern void EpdAdd2(EpDouble *epd1, EpDouble *epd2);
extern void EpdAdd3(EpDouble *epd1, EpDouble *epd2, EpDouble *epd3);
extern void EpdSubtract(EpDouble *epd1, double value);
extern void EpdSubtract2(EpDouble *epd1, EpDouble *epd2);
extern void EpdSubtract3(EpDouble *epd1, EpDouble *epd2, EpDouble *epd3);
extern void EpdPow2(int n, EpDouble *epd);
extern void EpdPow2Decimal(int n, EpDouble *epd);
extern void EpdNormalize(EpDouble *epd);
extern void EpdNormalizeDecimal(EpDouble *epd);
extern void EpdGetValueAndDecimalExponent(EpDouble *epd, double *value, int *exponent);
extern int EpdGetExponent(double value);
extern int EpdGetExponentDecimal(double value);
extern void EpdMakeInf(EpDouble *epd, int sign);
extern void EpdMakeZero(EpDouble *epd, int sign);
extern void EpdMakeNan(EpDouble *epd);
extern void EpdCopy(EpDouble *from, EpDouble *to);
extern int EpdIsInf(EpDouble *epd);
extern int EpdIsZero(EpDouble *epd);
extern int EpdIsNan(EpDouble *epd);
extern int EpdIsNanOrInf(EpDouble *epd);
extern int IsInfDouble(double value);
extern int IsNanDouble(double value);
extern int IsNanOrInfDouble(double value);




# 67 "/app/abc/src/bdd/cudd/cudd.h" 2


# 151 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_REORDER_SAME,
    CUDD_REORDER_NONE,
    CUDD_REORDER_RANDOM,
    CUDD_REORDER_RANDOM_PIVOT,
    CUDD_REORDER_SIFT,
    CUDD_REORDER_SIFT_CONVERGE,
    CUDD_REORDER_SYMM_SIFT,
    CUDD_REORDER_SYMM_SIFT_CONV,
    CUDD_REORDER_WINDOW2,
    CUDD_REORDER_WINDOW3,
    CUDD_REORDER_WINDOW4,
    CUDD_REORDER_WINDOW2_CONV,
    CUDD_REORDER_WINDOW3_CONV,
    CUDD_REORDER_WINDOW4_CONV,
    CUDD_REORDER_GROUP_SIFT,
    CUDD_REORDER_GROUP_SIFT_CONV,
    CUDD_REORDER_ANNEALING,
    CUDD_REORDER_GENETIC,
    CUDD_REORDER_LINEAR,
    CUDD_REORDER_LINEAR_CONVERGE,
    CUDD_REORDER_LAZY_SIFT,
    CUDD_REORDER_EXACT
} Cudd_ReorderingType;
# 184 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_NO_CHECK,
    CUDD_GROUP_CHECK,
    CUDD_GROUP_CHECK2,
    CUDD_GROUP_CHECK3,
    CUDD_GROUP_CHECK4,
    CUDD_GROUP_CHECK5,
    CUDD_GROUP_CHECK6,
    CUDD_GROUP_CHECK7,
    CUDD_GROUP_CHECK8,
    CUDD_GROUP_CHECK9
} Cudd_AggregationType;
# 205 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_PRE_GC_HOOK,
    CUDD_POST_GC_HOOK,
    CUDD_PRE_REORDERING_HOOK,
    CUDD_POST_REORDERING_HOOK
} Cudd_HookType;
# 220 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_NO_ERROR,
    CUDD_MEMORY_OUT,
    CUDD_TOO_MANY_NODES,
    CUDD_MAX_MEM_EXCEEDED,
    CUDD_INVALID_ARG,
    CUDD_INTERNAL_ERROR
} Cudd_ErrorType;
# 237 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_LAZY_NONE,
    CUDD_LAZY_SOFT_GROUP,
    CUDD_LAZY_HARD_GROUP,
    CUDD_LAZY_UNGROUP
} Cudd_LazyGroupType;
# 252 "/app/abc/src/bdd/cudd/cudd.h"
typedef enum {
    CUDD_VAR_PRIMARY_INPUT,
    CUDD_VAR_PRESENT_STATE,
    CUDD_VAR_NEXT_STATE
} Cudd_VariableType;



typedef unsigned int DdHalfWord;
# 270 "/app/abc/src/bdd/cudd/cudd.h"
typedef struct DdNode DdNode;

typedef struct DdChildren {
    struct DdNode *T;
    struct DdNode *E;
} DdChildren;


struct DdNode {
    DdHalfWord index;
    DdHalfWord ref;
    DdNode *next;
    union {
        double value;
        DdChildren kids;
    } type;
    ABC_INT64_T Id;
};





typedef struct DdManager DdManager;

typedef struct DdGen DdGen;




typedef unsigned int DdApaDigit;
typedef unsigned long int DdApaDoubleDigit;




typedef DdApaDigit * DdApaNumber;


typedef struct DdTlcInfo DdTlcInfo;


typedef int (*DD_HFP)(DdManager *, const char *, void *);

typedef DdNode * (*DD_PRFP)(DdManager * , int, DdNode **, DdNode **,
                            DdNode **);

typedef DdNode * (*DD_AOP)(DdManager *, DdNode **, DdNode **);

typedef DdNode * (*DD_MAOP)(DdManager *, DdNode *);

typedef DdNode * (*DD_CTFP)(DdManager *, DdNode *, DdNode *);
typedef DdNode * (*DD_CTFP1)(DdManager *, DdNode *);

typedef void (*DD_OOMFP)(long);

typedef int (*DD_QSFP)(const void *, const void *);
# 632 "/app/abc/src/bdd/cudd/cudd.h"
extern DdNode * Cudd_addNewVar( DdManager * dd );
extern DdNode * Cudd_addNewVarAtLevel( DdManager * dd, int level );
extern DdNode * Cudd_bddNewVar( DdManager * dd );
extern DdNode * Cudd_bddNewVarAtLevel( DdManager * dd, int level );
extern DdNode * Cudd_addIthVar( DdManager * dd, int i );
extern DdNode * Cudd_bddIthVar( DdManager * dd, int i );
extern DdNode * Cudd_zddIthVar( DdManager * dd, int i );
extern int Cudd_zddVarsFromBddVars( DdManager * dd, int multiplicity );
extern DdNode * Cudd_addConst( DdManager * dd, double c );
extern int Cudd_IsNonConstant( DdNode * f );
extern void Cudd_AutodynEnable( DdManager * unique, Cudd_ReorderingType method );
extern void Cudd_AutodynDisable( DdManager * unique );
extern int Cudd_ReorderingStatus( DdManager * unique, Cudd_ReorderingType * method );
extern void Cudd_AutodynEnableZdd( DdManager * unique, Cudd_ReorderingType method );
extern void Cudd_AutodynDisableZdd( DdManager * unique );
extern int Cudd_ReorderingStatusZdd( DdManager * unique, Cudd_ReorderingType * method );
extern int Cudd_zddRealignmentEnabled( DdManager * unique );
extern void Cudd_zddRealignEnable( DdManager * unique );
extern void Cudd_zddRealignDisable( DdManager * unique );
extern int Cudd_bddRealignmentEnabled( DdManager * unique );
extern void Cudd_bddRealignEnable( DdManager * unique );
extern void Cudd_bddRealignDisable( DdManager * unique );
extern DdNode * Cudd_ReadOne( DdManager * dd );
extern DdNode * Cudd_ReadZddOne( DdManager * dd, int i );
extern DdNode * Cudd_ReadZero( DdManager * dd );
extern DdNode * Cudd_ReadLogicZero( DdManager * dd );
extern DdNode * Cudd_ReadPlusInfinity( DdManager * dd );
extern DdNode * Cudd_ReadMinusInfinity( DdManager * dd );
extern DdNode * Cudd_ReadBackground( DdManager * dd );
extern void Cudd_SetBackground( DdManager * dd, DdNode * bck );
extern unsigned int Cudd_ReadCacheSlots( DdManager * dd );
extern double Cudd_ReadCacheUsedSlots( DdManager * dd );
extern double Cudd_ReadCacheLookUps( DdManager * dd );
extern double Cudd_ReadCacheHits( DdManager * dd );
extern double Cudd_ReadRecursiveCalls( DdManager * dd );
extern unsigned int Cudd_ReadMinHit( DdManager * dd );
extern void Cudd_SetMinHit( DdManager * dd, unsigned int hr );
extern unsigned int Cudd_ReadLooseUpTo( DdManager * dd );
extern void Cudd_SetLooseUpTo( DdManager * dd, unsigned int lut );
extern unsigned int Cudd_ReadMaxCache( DdManager * dd );
extern unsigned int Cudd_ReadMaxCacheHard( DdManager * dd );
extern void Cudd_SetMaxCacheHard( DdManager * dd, unsigned int mc );
extern int Cudd_ReadSize( DdManager * dd );
extern int Cudd_ReadZddSize( DdManager * dd );
extern unsigned int Cudd_ReadSlots( DdManager * dd );
extern double Cudd_ReadUsedSlots( DdManager * dd );
extern double Cudd_ExpectedUsedSlots( DdManager * dd );
extern unsigned int Cudd_ReadKeys( DdManager * dd );
extern unsigned int Cudd_ReadDead( DdManager * dd );
extern unsigned int Cudd_ReadMinDead( DdManager * dd );
extern int Cudd_ReadReorderings( DdManager * dd );
extern long Cudd_ReadReorderingTime( DdManager * dd );
extern int Cudd_ReadGarbageCollections( DdManager * dd );
extern long Cudd_ReadGarbageCollectionTime( DdManager * dd );
extern double Cudd_ReadNodesFreed( DdManager * dd );
extern double Cudd_ReadNodesDropped( DdManager * dd );
extern double Cudd_ReadUniqueLookUps( DdManager * dd );
extern double Cudd_ReadUniqueLinks( DdManager * dd );
extern int Cudd_ReadSiftMaxVar( DdManager * dd );
extern void Cudd_SetSiftMaxVar( DdManager * dd, int smv );
extern int Cudd_ReadSiftMaxSwap( DdManager * dd );
extern void Cudd_SetSiftMaxSwap( DdManager * dd, int sms );
extern double Cudd_ReadMaxGrowth( DdManager * dd );
extern void Cudd_SetMaxGrowth( DdManager * dd, double mg );
extern double Cudd_ReadMaxGrowthAlternate( DdManager * dd );
extern void Cudd_SetMaxGrowthAlternate( DdManager * dd, double mg );
extern int Cudd_ReadReorderingCycle( DdManager * dd );
extern void Cudd_SetReorderingCycle( DdManager * dd, int cycle );
extern MtrNode * Cudd_ReadTree( DdManager * dd );
extern void Cudd_SetTree( DdManager * dd, MtrNode * tree );
extern void Cudd_FreeTree( DdManager * dd );
extern MtrNode * Cudd_ReadZddTree( DdManager * dd );
extern void Cudd_SetZddTree( DdManager * dd, MtrNode * tree );
extern void Cudd_FreeZddTree( DdManager * dd );
extern unsigned int Cudd_NodeReadIndex( DdNode * node );
extern int Cudd_ReadPerm( DdManager * dd, int i );
extern int Cudd_ReadPermZdd( DdManager * dd, int i );
extern int Cudd_ReadInvPerm( DdManager * dd, int i );
extern int Cudd_ReadInvPermZdd( DdManager * dd, int i );
extern DdNode * Cudd_ReadVars( DdManager * dd, int i );
extern double Cudd_ReadEpsilon( DdManager * dd );
extern void Cudd_SetEpsilon( DdManager * dd, double ep );
extern Cudd_AggregationType Cudd_ReadGroupcheck( DdManager * dd );
extern void Cudd_SetGroupcheck( DdManager * dd, Cudd_AggregationType gc );
extern int Cudd_GarbageCollectionEnabled( DdManager * dd );
extern void Cudd_EnableGarbageCollection( DdManager * dd );
extern void Cudd_DisableGarbageCollection( DdManager * dd );
extern int Cudd_DeadAreCounted( DdManager * dd );
extern void Cudd_TurnOnCountDead( DdManager * dd );
extern void Cudd_TurnOffCountDead( DdManager * dd );
extern int Cudd_ReadRecomb( DdManager * dd );
extern void Cudd_SetRecomb( DdManager * dd, int recomb );
extern int Cudd_ReadSymmviolation( DdManager * dd );
extern void Cudd_SetSymmviolation( DdManager * dd, int symmviolation );
extern int Cudd_ReadArcviolation( DdManager * dd );
extern void Cudd_SetArcviolation( DdManager * dd, int arcviolation );
extern int Cudd_ReadPopulationSize( DdManager * dd );
extern void Cudd_SetPopulationSize( DdManager * dd, int populationSize );
extern int Cudd_ReadNumberXovers( DdManager * dd );
extern void Cudd_SetNumberXovers( DdManager * dd, int numberXovers );
extern unsigned long Cudd_ReadMemoryInUse( DdManager * dd );
extern int Cudd_PrintInfo( DdManager * dd, FILE * fp );
extern long Cudd_ReadPeakNodeCount( DdManager * dd );
extern int Cudd_ReadPeakLiveNodeCount( DdManager * dd );
extern long Cudd_ReadNodeCount( DdManager * dd );
extern long Cudd_zddReadNodeCount( DdManager * dd );
extern int Cudd_AddHook( DdManager * dd, DD_HFP f, Cudd_HookType where );
extern int Cudd_RemoveHook( DdManager * dd, DD_HFP f, Cudd_HookType where );
extern int Cudd_IsInHook( DdManager * dd, DD_HFP f, Cudd_HookType where );
extern int Cudd_StdPreReordHook( DdManager * dd, const char * str, void * data );
extern int Cudd_StdPostReordHook( DdManager * dd, const char * str, void * data );
extern int Cudd_EnableReorderingReporting( DdManager * dd );
extern int Cudd_DisableReorderingReporting( DdManager * dd );
extern int Cudd_ReorderingReporting( DdManager * dd );
extern Cudd_ErrorType Cudd_ReadErrorCode( DdManager * dd );
extern void Cudd_ClearErrorCode( DdManager * dd );
extern FILE * Cudd_ReadStdout( DdManager * dd );
extern void Cudd_SetStdout( DdManager * dd, FILE * fp );
extern FILE * Cudd_ReadStderr( DdManager * dd );
extern void Cudd_SetStderr( DdManager * dd, FILE * fp );
extern unsigned int Cudd_ReadNextReordering( DdManager * dd );
extern void Cudd_SetNextReordering( DdManager * dd, unsigned int next );
extern double Cudd_ReadSwapSteps( DdManager * dd );
extern unsigned int Cudd_ReadMaxLive( DdManager * dd );
extern void Cudd_SetMaxLive( DdManager * dd, unsigned int maxLive );
extern unsigned long Cudd_ReadMaxMemory( DdManager * dd );
extern void Cudd_SetMaxMemory( DdManager * dd, unsigned long maxMemory );
extern int Cudd_bddBindVar( DdManager * dd, int index );
extern int Cudd_bddUnbindVar( DdManager * dd, int index );
extern int Cudd_bddVarIsBound( DdManager * dd, int index );
extern DdNode * Cudd_addExistAbstract( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * Cudd_addUnivAbstract( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * Cudd_addOrAbstract( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * Cudd_addApply( DdManager * dd, DdNode * ( * )(DdManager * , DdNode ** , DdNode ** ), DdNode * f, DdNode * g );
extern DdNode * Cudd_addPlus( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addTimes( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addThreshold( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addSetNZ( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addDivide( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addMinus( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addMinimum( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addMaximum( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addOneZeroMaximum( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addDiff( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addAgreement( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addOr( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addNand( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addNor( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addXor( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addXnor( DdManager * dd, DdNode ** f, DdNode ** g );
extern DdNode * Cudd_addMonadicApply( DdManager * dd, DdNode * ( * op)(DdManager * , DdNode * ), DdNode * f );
extern DdNode * Cudd_addLog( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addFindMax( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addFindMin( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addIthBit( DdManager * dd, DdNode * f, int bit );
extern DdNode * Cudd_addScalarInverse( DdManager * dd, DdNode * f, DdNode * epsilon );
extern DdNode * Cudd_addIte( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * Cudd_addIteConstant( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * Cudd_addEvalConst( DdManager * dd, DdNode * f, DdNode * g );
extern int Cudd_addLeq( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_addCmpl( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addNegate( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addRoundOff( DdManager * dd, DdNode * f, int N );
extern DdNode * Cudd_addWalsh( DdManager * dd, DdNode ** x, DdNode ** y, int n );
extern DdNode * Cudd_addResidue( DdManager * dd, int n, int m, int options, int top );
extern DdNode * Cudd_bddAndAbstract( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube );
extern DdNode * Cudd_bddAndAbstractLimit( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube, unsigned int limit );
extern int Cudd_ApaNumberOfDigits( int binaryDigits );
extern DdApaNumber Cudd_NewApaNumber( int digits );
extern void Cudd_ApaCopy( int digits, DdApaNumber source, DdApaNumber dest );
extern DdApaDigit Cudd_ApaAdd( int digits, DdApaNumber a, DdApaNumber b, DdApaNumber sum );
extern DdApaDigit Cudd_ApaSubtract( int digits, DdApaNumber a, DdApaNumber b, DdApaNumber diff );
extern DdApaDigit Cudd_ApaShortDivision( int digits, DdApaNumber dividend, DdApaDigit divisor, DdApaNumber quotient );
extern unsigned int Cudd_ApaIntDivision( int digits, DdApaNumber dividend, unsigned int divisor, DdApaNumber quotient );
extern void Cudd_ApaShiftRight( int digits, DdApaDigit in, DdApaNumber a, DdApaNumber b );
extern void Cudd_ApaSetToLiteral( int digits, DdApaNumber number, DdApaDigit literal );
extern void Cudd_ApaPowerOfTwo( int digits, DdApaNumber number, int power );
extern int Cudd_ApaCompare( int digitsFirst, DdApaNumber first, int digitsSecond, DdApaNumber second );
extern int Cudd_ApaCompareRatios( int digitsFirst, DdApaNumber firstNum, unsigned int firstDen, int digitsSecond, DdApaNumber secondNum, unsigned int secondDen );
extern int Cudd_ApaPrintHex( FILE * fp, int digits, DdApaNumber number );
extern int Cudd_ApaPrintDecimal( FILE * fp, int digits, DdApaNumber number );
extern int Cudd_ApaPrintExponential( FILE * fp, int digits, DdApaNumber number, int precision );
extern DdApaNumber Cudd_ApaCountMinterm( DdManager * manager, DdNode * node, int nvars, int * digits );
extern int Cudd_ApaPrintMinterm( FILE * fp, DdManager * dd, DdNode * node, int nvars );
extern int Cudd_ApaPrintMintermExp( FILE * fp, DdManager * dd, DdNode * node, int nvars, int precision );
extern int Cudd_ApaPrintDensity( FILE * fp, DdManager * dd, DdNode * node, int nvars );
extern DdNode * Cudd_UnderApprox( DdManager * dd, DdNode * f, int numVars, int threshold, int safe, double quality );
extern DdNode * Cudd_OverApprox( DdManager * dd, DdNode * f, int numVars, int threshold, int safe, double quality );
extern DdNode * Cudd_RemapUnderApprox( DdManager * dd, DdNode * f, int numVars, int threshold, double quality );
extern DdNode * Cudd_RemapOverApprox( DdManager * dd, DdNode * f, int numVars, int threshold, double quality );
extern DdNode * Cudd_BiasedUnderApprox( DdManager * dd, DdNode * f, DdNode * b, int numVars, int threshold, double quality1, double quality0 );
extern DdNode * Cudd_BiasedOverApprox( DdManager * dd, DdNode * f, DdNode * b, int numVars, int threshold, double quality1, double quality0 );
extern DdNode * Cudd_bddExistAbstract( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * Cudd_bddXorExistAbstract( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube );
extern DdNode * Cudd_bddUnivAbstract( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * Cudd_bddBooleanDiff( DdManager * manager, DdNode * f, int x );
extern int Cudd_bddVarIsDependent( DdManager * dd, DdNode * f, DdNode * var );
extern double Cudd_bddCorrelation( DdManager * manager, DdNode * f, DdNode * g );
extern double Cudd_bddCorrelationWeights( DdManager * manager, DdNode * f, DdNode * g, double * prob );
extern DdNode * Cudd_bddIte( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * Cudd_bddIteConstant( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * Cudd_bddIntersect( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddAnd( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddAndLimit( DdManager * dd, DdNode * f, DdNode * g, unsigned int limit );
extern DdNode * Cudd_bddOr( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddNand( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddNor( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddXor( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddXnor( DdManager * dd, DdNode * f, DdNode * g );
extern int Cudd_bddLeq( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_addBddThreshold( DdManager * dd, DdNode * f, double value );
extern DdNode * Cudd_addBddStrictThreshold( DdManager * dd, DdNode * f, double value );
extern DdNode * Cudd_addBddInterval( DdManager * dd, DdNode * f, double lower, double upper );
extern DdNode * Cudd_addBddIthBit( DdManager * dd, DdNode * f, int bit );
extern DdNode * Cudd_BddToAdd( DdManager * dd, DdNode * B );
extern DdNode * Cudd_addBddPattern( DdManager * dd, DdNode * f );
extern DdNode * Cudd_bddTransfer( DdManager * ddSource, DdManager * ddDestination, DdNode * f );
extern int Cudd_DebugCheck( DdManager * table );
extern int Cudd_CheckKeys( DdManager * table );
extern DdNode * Cudd_bddClippingAnd( DdManager * dd, DdNode * f, DdNode * g, int maxDepth, int direction );
extern DdNode * Cudd_bddClippingAndAbstract( DdManager * dd, DdNode * f, DdNode * g, DdNode * cube, int maxDepth, int direction );
extern DdNode * Cudd_Cofactor( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_bddCompose( DdManager * dd, DdNode * f, DdNode * g, int v );
extern DdNode * Cudd_addCompose( DdManager * dd, DdNode * f, DdNode * g, int v );
extern DdNode * Cudd_addPermute( DdManager * manager, DdNode * node, int * permut );
extern DdNode * Cudd_addSwapVariables( DdManager * dd, DdNode * f, DdNode ** x, DdNode ** y, int n );
extern DdNode * Cudd_bddPermute( DdManager * manager, DdNode * node, int * permut );
extern DdNode * Cudd_bddVarMap( DdManager * manager, DdNode * f );
extern int Cudd_SetVarMap( DdManager * manager, DdNode ** x, DdNode ** y, int n );
extern DdNode * Cudd_bddSwapVariables( DdManager * dd, DdNode * f, DdNode ** x, DdNode ** y, int n );
extern DdNode * Cudd_bddAdjPermuteX( DdManager * dd, DdNode * B, DdNode ** x, int n );
extern DdNode * Cudd_addVectorCompose( DdManager * dd, DdNode * f, DdNode ** vector );
extern DdNode * Cudd_addGeneralVectorCompose( DdManager * dd, DdNode * f, DdNode ** vectorOn, DdNode ** vectorOff );
extern DdNode * Cudd_addNonSimCompose( DdManager * dd, DdNode * f, DdNode ** vector );
extern DdNode * Cudd_bddVectorCompose( DdManager * dd, DdNode * f, DdNode ** vector );
extern int Cudd_bddApproxConjDecomp( DdManager * dd, DdNode * f, DdNode ** * conjuncts );
extern int Cudd_bddApproxDisjDecomp( DdManager * dd, DdNode * f, DdNode ** * disjuncts );
extern int Cudd_bddIterConjDecomp( DdManager * dd, DdNode * f, DdNode ** * conjuncts );
extern int Cudd_bddIterDisjDecomp( DdManager * dd, DdNode * f, DdNode ** * disjuncts );
extern int Cudd_bddGenConjDecomp( DdManager * dd, DdNode * f, DdNode ** * conjuncts );
extern int Cudd_bddGenDisjDecomp( DdManager * dd, DdNode * f, DdNode ** * disjuncts );
extern int Cudd_bddVarConjDecomp( DdManager * dd, DdNode * f, DdNode ** * conjuncts );
extern int Cudd_bddVarDisjDecomp( DdManager * dd, DdNode * f, DdNode ** * disjuncts );
extern DdNode * Cudd_FindEssential( DdManager * dd, DdNode * f );
extern int Cudd_bddIsVarEssential( DdManager * manager, DdNode * f, int id, int phase );
extern DdTlcInfo * Cudd_FindTwoLiteralClauses( DdManager * dd, DdNode * f );
extern int Cudd_PrintTwoLiteralClauses( DdManager * dd, DdNode * f, char ** names, FILE * fp );
extern int Cudd_ReadIthClause( DdTlcInfo * tlc, int i, DdHalfWord * var1, DdHalfWord * var2, int * phase1, int * phase2 );
extern void Cudd_tlcInfoFree( DdTlcInfo * t );
extern int Cudd_DumpBlif( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, char * mname, FILE * fp, int mv );
extern int Cudd_DumpBlifBody( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp, int mv );
extern int Cudd_DumpDot( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp );
extern int Cudd_DumpDaVinci( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp );
extern int Cudd_DumpDDcal( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp );
extern int Cudd_DumpFactoredForm( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp );
extern DdNode * Cudd_bddConstrain( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * Cudd_bddRestrict( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * Cudd_bddNPAnd( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * Cudd_addConstrain( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode ** Cudd_bddConstrainDecomp( DdManager * dd, DdNode * f );
extern DdNode * Cudd_addRestrict( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode ** Cudd_bddCharToVect( DdManager * dd, DdNode * f );
extern DdNode * Cudd_bddLICompaction( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * Cudd_bddSqueeze( DdManager * dd, DdNode * l, DdNode * u );
extern DdNode * Cudd_bddMinimize( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * Cudd_SubsetCompress( DdManager * dd, DdNode * f, int nvars, int threshold );
extern DdNode * Cudd_SupersetCompress( DdManager * dd, DdNode * f, int nvars, int threshold );
extern MtrNode * Cudd_MakeTreeNode( DdManager * dd, unsigned int low, unsigned int size, unsigned int type );
extern int Cudd_addHarwell( FILE * fp, DdManager * dd, DdNode ** E, DdNode ** * x, DdNode ** * y, DdNode ** * xn, DdNode ** * yn_, int * nx, int * ny, int * m, int * n, int bx, int sx, int by, int sy, int pr );
extern DdManager * Cudd_Init( unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int cacheSize, unsigned long maxMemory );
extern void Cudd_Quit( DdManager * unique );
extern int Cudd_PrintLinear( DdManager * table );
extern int Cudd_ReadLinear( DdManager * table, int x, int y );
extern DdNode * Cudd_bddLiteralSetIntersection( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_addMatrixMultiply( DdManager * dd, DdNode * A, DdNode * B, DdNode ** z, int nz );
extern DdNode * Cudd_addTimesPlus( DdManager * dd, DdNode * A, DdNode * B, DdNode ** z, int nz );
extern DdNode * Cudd_addTriangle( DdManager * dd, DdNode * f, DdNode * g, DdNode ** z, int nz );
extern DdNode * Cudd_addOuterSum( DdManager * dd, DdNode * M, DdNode * r, DdNode * c );
extern DdNode * Cudd_PrioritySelect( DdManager * dd, DdNode * R, DdNode ** x, DdNode ** y, DdNode ** z, DdNode * Pi, int n, DdNode * ( * )(DdManager * , int, DdNode ** , DdNode ** , DdNode ** ) );
extern DdNode * Cudd_Xgty( DdManager * dd, int N, DdNode ** z, DdNode ** x, DdNode ** y );
extern DdNode * Cudd_Xeqy( DdManager * dd, int N, DdNode ** x, DdNode ** y );
extern DdNode * Cudd_addXeqy( DdManager * dd, int N, DdNode ** x, DdNode ** y );
extern DdNode * Cudd_Dxygtdxz( DdManager * dd, int N, DdNode ** x, DdNode ** y, DdNode ** z );
extern DdNode * Cudd_Dxygtdyz( DdManager * dd, int N, DdNode ** x, DdNode ** y, DdNode ** z );
extern DdNode * Cudd_Inequality( DdManager * dd, int N, int c, DdNode ** x, DdNode ** y );
extern DdNode * Cudd_Disequality( DdManager * dd, int N, int c, DdNode ** x, DdNode ** y );
extern DdNode * Cudd_bddInterval( DdManager * dd, int N, DdNode ** x, unsigned int lowerB, unsigned int upperB );
extern DdNode * Cudd_CProjection( DdManager * dd, DdNode * R, DdNode * Y );
extern DdNode * Cudd_addHamming( DdManager * dd, DdNode ** xVars, DdNode ** yVars, int nVars );
extern int Cudd_MinHammingDist( DdManager * dd, DdNode * f, int * minterm, int upperBound );
extern DdNode * Cudd_bddClosestCube( DdManager * dd, DdNode * f, DdNode * g, int * distance );
extern int Cudd_addRead( FILE * fp, DdManager * dd, DdNode ** E, DdNode ** * x, DdNode ** * y, DdNode ** * xn, DdNode ** * yn_, int * nx, int * ny, int * m, int * n, int bx, int sx, int by, int sy );
extern int Cudd_bddRead( FILE * fp, DdManager * dd, DdNode ** E, DdNode ** * x, DdNode ** * y, int * nx, int * ny, int * m, int * n, int bx, int sx, int by, int sy );
extern void Cudd_Ref( DdNode * n );
extern void Cudd_RecursiveDeref( DdManager * table, DdNode * n );
extern void Cudd_IterDerefBdd( DdManager * table, DdNode * n );
extern void Cudd_DelayedDerefBdd( DdManager * table, DdNode * n );
extern void Cudd_RecursiveDerefZdd( DdManager * table, DdNode * n );
extern void Cudd_Deref( DdNode * node );
extern int Cudd_CheckZeroRef( DdManager * manager );
extern int Cudd_ReduceHeap( DdManager * table, Cudd_ReorderingType heuristic, int minsize );
extern int Cudd_ShuffleHeap( DdManager * table, int * permutation );
extern DdNode * Cudd_Eval( DdManager * dd, DdNode * f, int * inputs );
extern DdNode * Cudd_ShortestPath( DdManager * manager, DdNode * f, int * weight, int * support, int * length );
extern DdNode * Cudd_LargestCube( DdManager * manager, DdNode * f, int * length );
extern int Cudd_ShortestLength( DdManager * manager, DdNode * f, int * weight );
extern DdNode * Cudd_Decreasing( DdManager * dd, DdNode * f, int i );
extern DdNode * Cudd_Increasing( DdManager * dd, DdNode * f, int i );
extern int Cudd_EquivDC( DdManager * dd, DdNode * F, DdNode * G, DdNode * D );
extern int Cudd_bddLeqUnless( DdManager * dd, DdNode * f, DdNode * g, DdNode * D );
extern int Cudd_EqualSupNorm( DdManager * dd, DdNode * f, DdNode * g, double tolerance, int pr );
extern DdNode * Cudd_bddMakePrime( DdManager * dd, DdNode * cube, DdNode * f );
extern double * Cudd_CofMinterm( DdManager * dd, DdNode * node );
extern DdNode * Cudd_SolveEqn( DdManager * bdd, DdNode * F, DdNode * Y, DdNode ** G, int ** yIndex, int n );
extern DdNode * Cudd_VerifySol( DdManager * bdd, DdNode * F, DdNode ** G, int * yIndex, int n );
extern DdNode * Cudd_SplitSet( DdManager * manager, DdNode * S, DdNode ** xVars, int n, double m );
extern DdNode * Cudd_SubsetHeavyBranch( DdManager * dd, DdNode * f, int numVars, int threshold );
extern DdNode * Cudd_SupersetHeavyBranch( DdManager * dd, DdNode * f, int numVars, int threshold );
extern DdNode * Cudd_SubsetShortPaths( DdManager * dd, DdNode * f, int numVars, int threshold, int hardlimit );
extern DdNode * Cudd_SupersetShortPaths( DdManager * dd, DdNode * f, int numVars, int threshold, int hardlimit );
extern void Cudd_SymmProfile( DdManager * table, int lower, int upper );
extern unsigned int Cudd_Prime( unsigned int p );
extern int Cudd_PrintMinterm( DdManager * manager, DdNode * node );
extern int Cudd_bddPrintCover( DdManager * dd, DdNode * l, DdNode * u );
extern int Cudd_PrintDebug( DdManager * dd, DdNode * f, int n, int pr );
extern int Cudd_DagSize( DdNode * node );
extern int Cudd_EstimateCofactor( DdManager * dd, DdNode * node, int i, int phase );
extern int Cudd_EstimateCofactorSimple( DdNode * node, int i );
extern int Cudd_SharingSize( DdNode ** nodeArray, int n );
extern double Cudd_CountMinterm( DdManager * manager, DdNode * node, int nvars );
extern int Cudd_EpdCountMinterm( DdManager * manager, DdNode * node, int nvars, EpDouble * epd );
extern double Cudd_CountPath( DdNode * node );
extern double Cudd_CountPathsToNonZero( DdNode * node );
extern DdNode * Cudd_Support( DdManager * dd, DdNode * f );
extern int * Cudd_SupportIndex( DdManager * dd, DdNode * f );
extern int Cudd_SupportSize( DdManager * dd, DdNode * f );
extern DdNode * Cudd_VectorSupport( DdManager * dd, DdNode ** F, int n );
extern int * Cudd_VectorSupportIndex( DdManager * dd, DdNode ** F, int n );
extern int Cudd_VectorSupportSize( DdManager * dd, DdNode ** F, int n );
extern int Cudd_ClassifySupport( DdManager * dd, DdNode * f, DdNode * g, DdNode ** common, DdNode ** onlyF, DdNode ** onlyG );
extern int Cudd_CountLeaves( DdNode * node );
extern int Cudd_bddPickOneCube( DdManager * ddm, DdNode * node, char * string );
extern DdNode * Cudd_bddPickOneMinterm( DdManager * dd, DdNode * f, DdNode ** vars, int n );
extern DdNode ** Cudd_bddPickArbitraryMinterms( DdManager * dd, DdNode * f, DdNode ** vars, int n, int k );
extern DdNode * Cudd_SubsetWithMaskVars( DdManager * dd, DdNode * f, DdNode ** vars, int nvars, DdNode ** maskVars, int mvars );
extern DdGen * Cudd_FirstCube( DdManager * dd, DdNode * f, int ** cube, double * value );
extern int Cudd_NextCube( DdGen * gen, int ** cube, double * value );
extern DdGen * Cudd_FirstPrime(DdManager * dd, DdNode * l, DdNode * u, int ** cube );
extern int Cudd_NextPrime(DdGen * gen, int ** cube );
extern DdNode * Cudd_bddComputeCube( DdManager * dd, DdNode ** vars, int * phase, int n );
extern DdNode * Cudd_addComputeCube( DdManager * dd, DdNode ** vars, int * phase, int n );
extern DdNode * Cudd_CubeArrayToBdd( DdManager * dd, int * array );
extern int Cudd_BddToCubeArray( DdManager * dd, DdNode * cube, int * array );
extern DdGen * Cudd_FirstNode( DdManager * dd, DdNode * f, DdNode ** node );
extern int Cudd_NextNode( DdGen * gen, DdNode ** node );
extern int Cudd_GenFree( DdGen * gen );
extern int Cudd_IsGenEmpty( DdGen * gen );
extern DdNode * Cudd_IndicesToCube( DdManager * dd, int * array, int n );
extern void Cudd_PrintVersion( FILE * fp );
extern double Cudd_AverageDistance( DdManager * dd );
extern long Cudd_Random( void );
extern void Cudd_Srandom( long seed );
extern double Cudd_Density( DdManager * dd, DdNode * f, int nvars );
extern void Cudd_OutOfMem( long size );
extern int Cudd_zddCount( DdManager * zdd, DdNode * P );
extern double Cudd_zddCountDouble( DdManager * zdd, DdNode * P );
extern DdNode * Cudd_zddProduct( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddUnateProduct( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddWeakDiv( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddDivide( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddWeakDivF( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddDivideF( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * Cudd_zddComplement( DdManager * dd, DdNode * node );
extern MtrNode * Cudd_MakeZddTreeNode( DdManager * dd, unsigned int low, unsigned int size, unsigned int type );
extern DdNode * Cudd_zddIsop( DdManager * dd, DdNode * L, DdNode * U, DdNode ** zdd_I );
extern DdNode * Cudd_bddIsop( DdManager * dd, DdNode * L, DdNode * U );
extern DdNode * Cudd_MakeBddFromZddCover( DdManager * dd, DdNode * node );
extern int Cudd_zddDagSize( DdNode * p_node );
extern double Cudd_zddCountMinterm( DdManager * zdd, DdNode * node, int path );
extern void Cudd_zddPrintSubtable( DdManager * table );
extern DdNode * Cudd_zddPortFromBdd( DdManager * dd, DdNode * B );
extern DdNode * Cudd_zddPortToBdd( DdManager * dd, DdNode * f );
extern int Cudd_zddReduceHeap( DdManager * table, Cudd_ReorderingType heuristic, int minsize );
extern int Cudd_zddShuffleHeap( DdManager * table, int * permutation );
extern DdNode * Cudd_zddIte( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * Cudd_zddUnion( DdManager * dd, DdNode * P, DdNode * Q );
extern DdNode * Cudd_zddIntersect( DdManager * dd, DdNode * P, DdNode * Q );
extern DdNode * Cudd_zddDiff( DdManager * dd, DdNode * P, DdNode * Q );
extern DdNode * Cudd_zddDiffConst( DdManager * zdd, DdNode * P, DdNode * Q );
extern DdNode * Cudd_zddSubset1( DdManager * dd, DdNode * P, int var );
extern DdNode * Cudd_zddSubset0( DdManager * dd, DdNode * P, int var );
extern DdNode * Cudd_zddChange( DdManager * dd, DdNode * P, int var );
extern void Cudd_zddSymmProfile( DdManager * table, int lower, int upper );
extern int Cudd_zddPrintMinterm( DdManager * zdd, DdNode * node );
extern int Cudd_zddPrintCover( DdManager * zdd, DdNode * node );
extern int Cudd_zddPrintDebug( DdManager * zdd, DdNode * f, int n, int pr );
extern DdGen * Cudd_zddFirstPath( DdManager * zdd, DdNode * f, int ** path );
extern int Cudd_zddNextPath( DdGen * gen, int ** path );
extern char * Cudd_zddCoverPathToString( DdManager * zdd, int * path, char * str );
extern int Cudd_zddDumpDot( DdManager * dd, int n, DdNode ** f, char ** inames, char ** onames, FILE * fp );
extern int Cudd_bddSetPiVar( DdManager * dd, int index );
extern int Cudd_bddSetPsVar( DdManager * dd, int index );
extern int Cudd_bddSetNsVar( DdManager * dd, int index );
extern int Cudd_bddIsPiVar( DdManager * dd, int index );
extern int Cudd_bddIsPsVar( DdManager * dd, int index );
extern int Cudd_bddIsNsVar( DdManager * dd, int index );
extern int Cudd_bddSetPairIndex( DdManager * dd, int index, int pairIndex );
extern int Cudd_bddReadPairIndex( DdManager * dd, int index );
extern int Cudd_bddSetVarToBeGrouped( DdManager * dd, int index );
extern int Cudd_bddSetVarHardGroup( DdManager * dd, int index );
extern int Cudd_bddResetVarToBeGrouped( DdManager * dd, int index );
extern int Cudd_bddIsVarToBeGrouped( DdManager * dd, int index );
extern int Cudd_bddSetVarToBeUngrouped( DdManager * dd, int index );
extern int Cudd_bddIsVarToBeUngrouped( DdManager * dd, int index );
extern int Cudd_bddIsVarHardGroup( DdManager * dd, int index );






# 74 "/app/abc/src/bdd/cudd/cuddInt.h" 2



# 204 "/app/abc/src/bdd/cudd/cuddInt.h"
struct DdGen {
    DdManager *manager;
    int type;
    int status;
    union {
        struct {
            int *cube;
            double value;
        } cubes;
        struct {
            int *cube;
            DdNode *ub;
        } primes;
        struct {
            int size;
        } nodes;
    } gen;
    struct {
        int sp;




        DdNode **stack;



    } stack;
    DdNode *node;
};
# 245 "/app/abc/src/bdd/cudd/cuddInt.h"
typedef struct DdHook {
    DD_HFP f;
    struct DdHook *next;
} DdHook;
# 260 "/app/abc/src/bdd/cudd/cuddInt.h"
typedef ABC_PTRINT_T ptrint;
typedef ABC_PTRUINT_T ptruint;






typedef DdNode *DdNodePtr;


typedef struct DdLocalCacheItem {
    DdNode *value;



    DdNode *key[1];
} DdLocalCacheItem;


typedef struct DdLocalCache {
    DdLocalCacheItem *item;
    unsigned int itemsize;
    unsigned int keysize;
    unsigned int slots;
    int shift;
    double lookUps;
    double minHit;
    double hits;
    unsigned int maxslots;
    DdManager *manager;
    struct DdLocalCache *next;
} DdLocalCache;


typedef struct DdHashItem {
    struct DdHashItem *next;
    ptrint count;
    DdNode *value;
    DdNode *key[1];
} DdHashItem;


typedef struct DdHashTable {
    unsigned int keysize;
    unsigned int itemsize;
    DdHashItem **bucket;
    DdHashItem *nextFree;
    DdHashItem **memoryList;
    unsigned int numBuckets;
    int shift;
    unsigned int size;
    unsigned int maxsize;
    DdManager *manager;
} DdHashTable;

typedef struct DdCache {
    DdNode *f,*g;
    ptruint h;
    DdNode *data;



    unsigned hash;
} DdCache;

typedef struct DdSubtable {
    DdNode **nodelist;
    int shift;
    unsigned int slots;
    unsigned int keys;
    unsigned int maxKeys;
    unsigned int dead;
    unsigned int next;
    int bindVar;

    Cudd_VariableType varType;
    int pairIndex;
    int varHandled;
    Cudd_LazyGroupType varToBeGrouped;
} DdSubtable;

struct DdManager {

    DdNode sentinel;
    DdNode *one;
    DdNode *zero;
    DdNode *plusinfinity;
    DdNode *minusinfinity;
    DdNode *background;

    DdCache *acache;
    DdCache *cache;
    unsigned int cacheSlots;
    int cacheShift;
    double cacheMisses;
    double cacheHits;
    double minHit;
    int cacheSlack;
    unsigned int maxCacheHard;

    int size;
    int sizeZ;
    int maxSize;
    int maxSizeZ;
    DdSubtable *subtables;
    DdSubtable *subtableZ;
    DdSubtable constants;
    unsigned int slots;
    unsigned int keys;
    unsigned int keysZ;
    unsigned int dead;
    unsigned int deadZ;
    unsigned int maxLive;
    unsigned int minDead;
    double gcFrac;
    int gcEnabled;
    unsigned int looseUpTo;

    unsigned int initSlots;
    DdNode **stack;

    ABC_INT64_T allocated;

    double reclaimed;
    int isolated;
    int *perm;
    int *permZ;
    int *invperm;
    int *invpermZ;
    DdNode **vars;
    int *map;
    DdNode **univ;
    int linearSize;
    long *interact;
    long *linear;

    DdNode **memoryList;
    DdNode *nextFree;
    char *stash;

    DdNode **deathRow;
    int deathRowDepth;
    int nextDead;
    unsigned deadMask;


    double epsilon;

    int reordered;
    int reorderings;
    int siftMaxVar;
    int siftMaxSwap;
    double maxGrowth;
    double maxGrowthAlt;
    int reordCycle;
    int autoDyn;
    int autoDynZ;
    Cudd_ReorderingType autoMethod;
    Cudd_ReorderingType autoMethodZ;
    int realign;
    int realignZ;
    unsigned int nextDyn;
    unsigned int countDead;
    MtrNode *tree;
    MtrNode *treeZ;
    Cudd_AggregationType groupcheck;
    int recomb;
    int symmviolation;
    int arcviolation;
    int populationSize;
    int numberXovers;
    DdLocalCache *localCaches;



    char *hooks;
    DdHook *preGCHook;
    DdHook *postGCHook;
    DdHook *preReorderingHook;
    DdHook *postReorderingHook;
    FILE *out;
    FILE *err;




    Cudd_ErrorType errorCode;

    unsigned long memused;
    unsigned long maxmem;
    unsigned long maxmemhard;
    int garbageCollections;
    long GCTime;
    long reordTime;
    double totCachehits;
    double totCacheMisses;
    double cachecollisions;
    double cacheinserts;
    double cacheLastInserts;
    double cachedeletions;




    unsigned int peakLiveNodes;
# 487 "/app/abc/src/bdd/cudd/cuddInt.h"
    DdNode * bFunc;
    DdNode * bFunc2;
    abctime TimeStop;
};

typedef struct Move {
    DdHalfWord x;
    DdHalfWord y;
    unsigned int flags;
    int size;
    struct Move *next;
} Move;


typedef struct DdQueueItem {
    struct DdQueueItem *next;
    struct DdQueueItem *cnext;
    void *key;
} DdQueueItem;


typedef struct DdLevelQueue {
    void *first;
    DdQueueItem **last;
    DdQueueItem *freelist;
    DdQueueItem **buckets;
    int levels;
    int itemsize;
    int size;
    int maxsize;
    int numBuckets;
    int shift;
} DdLevelQueue;
# 1047 "/app/abc/src/bdd/cudd/cuddInt.h"
extern DdNode * cuddAddExistAbstractRecur( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * cuddAddUnivAbstractRecur( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * cuddAddOrAbstractRecur( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * cuddAddApplyRecur( DdManager * dd, DdNode * (*)(DdManager * , DdNode ** , DdNode **), DdNode * f, DdNode * g );
extern DdNode * cuddAddMonadicApplyRecur( DdManager * dd, DdNode * (*)(DdManager * , DdNode *), DdNode * f );
extern DdNode * cuddAddScalarInverseRecur( DdManager * dd, DdNode * f, DdNode * epsilon );
extern DdNode * cuddAddIteRecur( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * cuddAddCmplRecur( DdManager * dd, DdNode * f );
extern DdNode * cuddAddNegateRecur( DdManager * dd, DdNode * f );
extern DdNode * cuddAddRoundOffRecur( DdManager * dd, DdNode * f, double trunc );
extern DdNode * cuddUnderApprox( DdManager * dd, DdNode * f, int numVars, int threshold, int safe, double quality );
extern DdNode * cuddRemapUnderApprox( DdManager * dd, DdNode * f, int numVars, int threshold, double quality );
extern DdNode * cuddBiasedUnderApprox( DdManager * dd, DdNode * f, DdNode * b, int numVars, int threshold, double quality1, double quality0 );
extern DdNode * cuddBddAndAbstractRecur( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube );
extern int cuddAnnealing( DdManager * table, int lower, int upper );
extern DdNode * cuddBddExistAbstractRecur( DdManager * manager, DdNode * f, DdNode * cube );
extern DdNode * cuddBddXorExistAbstractRecur( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube );
extern DdNode * cuddBddBooleanDiffRecur( DdManager * manager, DdNode * f, DdNode * var );
extern DdNode * cuddBddIteRecur( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * cuddBddIntersectRecur( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddBddAndRecur( DdManager * manager, DdNode * f, DdNode * g );
extern DdNode * cuddBddXorRecur( DdManager * manager, DdNode * f, DdNode * g );
extern DdNode * cuddBddTransfer( DdManager * ddS, DdManager * ddD, DdNode * f );
extern DdNode * cuddAddBddDoPattern( DdManager * dd, DdNode * f );
extern int cuddInitCache( DdManager * unique, unsigned int cacheSize, unsigned int maxCacheSize );
extern void cuddCacheInsert( DdManager * table, ptruint op, DdNode * f, DdNode * g, DdNode * h, DdNode * data );
extern void cuddCacheInsert2( DdManager * table, DdNode * (*)(DdManager * , DdNode * , DdNode *), DdNode * f, DdNode * g, DdNode * data );
extern void cuddCacheInsert1( DdManager * table, DdNode * (*)(DdManager * , DdNode *), DdNode * f, DdNode * data );
extern DdNode * cuddCacheLookup( DdManager * table, ptruint op, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * cuddCacheLookupZdd( DdManager * table, ptruint op, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * cuddCacheLookup2( DdManager * table, DdNode * (*)(DdManager * , DdNode * , DdNode *), DdNode * f, DdNode * g );
extern DdNode * cuddCacheLookup1( DdManager * table, DdNode * (*)(DdManager * , DdNode *), DdNode * f );
extern DdNode * cuddCacheLookup2Zdd( DdManager * table, DdNode * (*)(DdManager * , DdNode * , DdNode *), DdNode * f, DdNode * g );
extern DdNode * cuddCacheLookup1Zdd( DdManager * table, DdNode * (*)(DdManager * , DdNode *), DdNode * f );
extern DdNode * cuddConstantLookup( DdManager * table, ptruint op, DdNode * f, DdNode * g, DdNode * h );
extern int cuddCacheProfile( DdManager * table, FILE * fp );
extern void cuddCacheResize( DdManager * table );
extern void cuddCacheFlush( DdManager * table );
extern int cuddComputeFloorLog2( unsigned int value );
extern int cuddHeapProfile( DdManager * dd );
extern void cuddPrintNode( DdNode * f, FILE * fp );
extern void cuddPrintVarGroups( DdManager * dd, MtrNode * root, int zdd, int silent );
extern DdNode * cuddBddClippingAnd( DdManager * dd, DdNode * f, DdNode * g, int maxDepth, int direction );
extern DdNode * cuddBddClippingAndAbstract( DdManager * dd, DdNode * f, DdNode * g, DdNode * cube, int maxDepth, int direction );
extern void cuddGetBranches( DdNode * g, DdNode ** g1, DdNode ** g0 );
extern int cuddCheckCube( DdManager * dd, DdNode * g );
extern DdNode * cuddCofactorRecur( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddBddComposeRecur( DdManager * dd, DdNode * f, DdNode * g, DdNode * proj );
extern DdNode * cuddAddComposeRecur( DdManager * dd, DdNode * f, DdNode * g, DdNode * proj );
extern int cuddExact( DdManager * table, int lower, int upper );
extern DdNode * cuddBddConstrainRecur( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * cuddBddRestrictRecur( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * cuddBddNPAndRecur( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * cuddAddConstrainRecur( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * cuddAddRestrictRecur( DdManager * dd, DdNode * f, DdNode * c );
extern DdNode * cuddBddLICompaction( DdManager * dd, DdNode * f, DdNode * c );
extern int cuddGa( DdManager * table, int lower, int upper );
extern int cuddTreeSifting( DdManager * table, Cudd_ReorderingType method );
extern int cuddZddInitUniv( DdManager * zdd );
extern void cuddZddFreeUniv( DdManager * zdd );
extern void cuddSetInteract( DdManager * table, int x, int y );
extern int cuddTestInteract( DdManager * table, int x, int y );
extern int cuddInitInteract( DdManager * table );
extern DdLocalCache * cuddLocalCacheInit( DdManager * manager, unsigned int keySize, unsigned int cacheSize, unsigned int maxCacheSize );
extern void cuddLocalCacheQuit( DdLocalCache * cache );
extern void cuddLocalCacheInsert( DdLocalCache * cache, DdNodePtr * key, DdNode * value );
extern DdNode * cuddLocalCacheLookup( DdLocalCache * cache, DdNodePtr * key );
extern void cuddLocalCacheClearDead( DdManager * manager );
extern int cuddIsInDeathRow( DdManager * dd, DdNode * f );
extern int cuddTimesInDeathRow( DdManager * dd, DdNode * f );
extern void cuddLocalCacheClearAll( DdManager * manager );



extern DdHashTable * cuddHashTableInit( DdManager * manager, unsigned int keySize, unsigned int initSize );
extern void cuddHashTableQuit( DdHashTable * hash );
extern int cuddHashTableInsert( DdHashTable * hash, DdNodePtr * key, DdNode * value, ptrint count );
extern DdNode * cuddHashTableLookup( DdHashTable * hash, DdNodePtr * key );
extern int cuddHashTableInsert1( DdHashTable * hash, DdNode * f, DdNode * value, ptrint count );
extern DdNode * cuddHashTableLookup1( DdHashTable * hash, DdNode * f );
extern int cuddHashTableInsert2( DdHashTable * hash, DdNode * f, DdNode * g, DdNode * value, ptrint count );
extern DdNode * cuddHashTableLookup2( DdHashTable * hash, DdNode * f, DdNode * g );
extern int cuddHashTableInsert3( DdHashTable * hash, DdNode * f, DdNode * g, DdNode * h, DdNode * value, ptrint count );
extern DdNode * cuddHashTableLookup3( DdHashTable * hash, DdNode * f, DdNode * g, DdNode * h );
extern DdLevelQueue * cuddLevelQueueInit( int levels, int itemSize, int numBuckets );
extern void cuddLevelQueueQuit( DdLevelQueue * queue );
extern void * cuddLevelQueueEnqueue( DdLevelQueue * queue, void * key, int level );
extern void cuddLevelQueueDequeue( DdLevelQueue * queue, int level );
extern int cuddLinearAndSifting( DdManager * table, int lower, int upper );
extern int cuddLinearInPlace( DdManager * table, int x, int y );
extern void cuddUpdateInteractionMatrix( DdManager * table, int xindex, int yindex );
extern int cuddInitLinear( DdManager * table );
extern int cuddResizeLinear( DdManager * table );
extern DdNode * cuddBddLiteralSetIntersectionRecur( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddCProjectionRecur( DdManager * dd, DdNode * R, DdNode * Y, DdNode * Ysupp );
extern DdNode * cuddBddClosestCube( DdManager * dd, DdNode * f, DdNode * g, double bound );
extern void cuddReclaim( DdManager * table, DdNode * n );
extern void cuddReclaimZdd( DdManager * table, DdNode * n );
extern void cuddClearDeathRow( DdManager * table );
extern void cuddShrinkDeathRow( DdManager * table );
extern DdNode * cuddDynamicAllocNode( DdManager * table );
extern int cuddSifting( DdManager * table, int lower, int upper );
extern int cuddSwapping( DdManager * table, int lower, int upper, Cudd_ReorderingType heuristic );
extern int cuddNextHigh( DdManager * table, int x );
extern int cuddNextLow( DdManager * table, int x );
extern int cuddSwapInPlace( DdManager * table, int x, int y );
extern int cuddBddAlignToZdd( DdManager * table );
extern DdNode * cuddBddMakePrime( DdManager * dd, DdNode * cube, DdNode * f );
extern DdNode * cuddSolveEqnRecur( DdManager * bdd, DdNode * F, DdNode * Y, DdNode ** G, int n, int * yIndex, int i );
extern DdNode * cuddVerifySol( DdManager * bdd, DdNode * F, DdNode ** G, int * yIndex, int n );

extern DdNode * cuddSplitSetRecur( DdManager * manager, st__table * mtable, int * varSeen, DdNode * p, double n, double max, int index );

extern DdNode * cuddSubsetHeavyBranch( DdManager * dd, DdNode * f, int numVars, int threshold );
extern DdNode * cuddSubsetShortPaths( DdManager * dd, DdNode * f, int numVars, int threshold, int hardlimit );
extern int cuddSymmCheck( DdManager * table, int x, int y );
extern int cuddSymmSifting( DdManager * table, int lower, int upper );
extern int cuddSymmSiftingConv( DdManager * table, int lower, int upper );
extern DdNode * cuddAllocNode( DdManager * unique );
extern DdManager * cuddInitTable( unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int looseUpTo );
extern void cuddFreeTable( DdManager * unique );
extern int cuddGarbageCollect( DdManager * unique, int clearCache );
extern DdNode * cuddZddGetNode( DdManager * zdd, int id, DdNode * T, DdNode * E );
extern DdNode * cuddZddGetNodeIVO( DdManager * dd, int index, DdNode * g, DdNode * h );
extern DdNode * cuddUniqueInter( DdManager * unique, int index, DdNode * T, DdNode * E );
extern DdNode * cuddUniqueInterIVO( DdManager * unique, int index, DdNode * T, DdNode * E );
extern DdNode * cuddUniqueInterZdd( DdManager * unique, int index, DdNode * T, DdNode * E );
extern DdNode * cuddUniqueConst( DdManager * unique, double value );
extern void cuddRehash( DdManager * unique, int i );
extern void cuddShrinkSubtable( DdManager * unique, int i );
extern int cuddInsertSubtables( DdManager * unique, int n, int level );
extern int cuddDestroySubtables( DdManager * unique, int n );
extern int cuddResizeTableZdd( DdManager * unique, int index );
extern void cuddSlowTableGrowth( DdManager * unique );
extern int cuddP( DdManager * dd, DdNode * f );

extern enum st__retval cuddStCountfree( char * key, char * value, char * arg );
extern int cuddCollectNodes( DdNode * f, st__table * visited );

extern DdNodePtr * cuddNodeArray( DdNode * f, int * n );
extern int cuddWindowReorder( DdManager * table, int low, int high, Cudd_ReorderingType submethod );
extern DdNode * cuddZddProduct( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddZddUnateProduct( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddZddWeakDiv( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddZddWeakDivF( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddZddDivide( DdManager * dd, DdNode * f, DdNode * g );
extern DdNode * cuddZddDivideF( DdManager * dd, DdNode * f, DdNode * g );
extern int cuddZddGetCofactors3( DdManager * dd, DdNode * f, int v, DdNode ** f1, DdNode ** f0, DdNode ** fd );
extern int cuddZddGetCofactors2( DdManager * dd, DdNode * f, int v, DdNode ** f1, DdNode ** f0 );
extern DdNode * cuddZddComplement( DdManager * dd, DdNode * node );
extern int cuddZddGetPosVarIndex(DdManager * dd, int index );
extern int cuddZddGetNegVarIndex(DdManager * dd, int index );
extern int cuddZddGetPosVarLevel(DdManager * dd, int index );
extern int cuddZddGetNegVarLevel(DdManager * dd, int index );
extern int cuddZddTreeSifting( DdManager * table, Cudd_ReorderingType method );
extern DdNode * cuddZddIsop( DdManager * dd, DdNode * L, DdNode * U, DdNode ** zdd_I );
extern DdNode * cuddBddIsop( DdManager * dd, DdNode * L, DdNode * U );
extern DdNode * cuddMakeBddFromZddCover( DdManager * dd, DdNode * node );
extern int cuddZddLinearSifting( DdManager * table, int lower, int upper );
extern int cuddZddAlignToBdd( DdManager * table );
extern int cuddZddNextHigh( DdManager * table, int x );
extern int cuddZddNextLow( DdManager * table, int x );
extern int cuddZddUniqueCompare( int * ptr_x, int * ptr_y );
extern int cuddZddSwapInPlace( DdManager * table, int x, int y );
extern int cuddZddSwapping( DdManager * table, int lower, int upper, Cudd_ReorderingType heuristic );
extern int cuddZddSifting( DdManager * table, int lower, int upper );
extern DdNode * cuddZddIte( DdManager * dd, DdNode * f, DdNode * g, DdNode * h );
extern DdNode * cuddZddUnion( DdManager * zdd, DdNode * P, DdNode * Q );
extern DdNode * cuddZddIntersect( DdManager * zdd, DdNode * P, DdNode * Q );
extern DdNode * cuddZddDiff( DdManager * zdd, DdNode * P, DdNode * Q );
extern DdNode * cuddZddChangeAux( DdManager * zdd, DdNode * P, DdNode * zvar );
extern DdNode * cuddZddSubset1( DdManager * dd, DdNode * P, int var );
extern DdNode * cuddZddSubset0( DdManager * dd, DdNode * P, int var );
extern DdNode * cuddZddChange( DdManager * dd, DdNode * P, int var );
extern int cuddZddSymmCheck( DdManager * table, int x, int y );
extern int cuddZddSymmSifting( DdManager * table, int lower, int upper );
extern int cuddZddSymmSiftingConv( DdManager * table, int lower, int upper );
extern int cuddZddP( DdManager * zdd, DdNode * f );






# 48 "/app/abc/src/bdd/extrab/extraBdd.h" 2




# 106 "/app/abc/src/bdd/extrab/extraBdd.h"
extern DdNode * Extra_bddSpaceFromFunctionFast( DdManager * dd, DdNode * bFunc );
extern DdNode * Extra_bddSpaceFromFunction( DdManager * dd, DdNode * bF, DdNode * bG );
extern DdNode * extraBddSpaceFromFunction( DdManager * dd, DdNode * bF, DdNode * bG );
extern DdNode * Extra_bddSpaceFromFunctionPos( DdManager * dd, DdNode * bFunc );
extern DdNode * extraBddSpaceFromFunctionPos( DdManager * dd, DdNode * bFunc );
extern DdNode * Extra_bddSpaceFromFunctionNeg( DdManager * dd, DdNode * bFunc );
extern DdNode * extraBddSpaceFromFunctionNeg( DdManager * dd, DdNode * bFunc );

extern DdNode * Extra_bddSpaceCanonVars( DdManager * dd, DdNode * bSpace );
extern DdNode * extraBddSpaceCanonVars( DdManager * dd, DdNode * bSpace );

extern DdNode * Extra_bddSpaceEquations( DdManager * dd, DdNode * bSpace );
extern DdNode * Extra_bddSpaceEquationsNeg( DdManager * dd, DdNode * bSpace );
extern DdNode * extraBddSpaceEquationsNeg( DdManager * dd, DdNode * bSpace );
extern DdNode * Extra_bddSpaceEquationsPos( DdManager * dd, DdNode * bSpace );
extern DdNode * extraBddSpaceEquationsPos( DdManager * dd, DdNode * bSpace );

extern DdNode * Extra_bddSpaceFromMatrixPos( DdManager * dd, DdNode * zA );
extern DdNode * extraBddSpaceFromMatrixPos( DdManager * dd, DdNode * zA );
extern DdNode * Extra_bddSpaceFromMatrixNeg( DdManager * dd, DdNode * zA );
extern DdNode * extraBddSpaceFromMatrixNeg( DdManager * dd, DdNode * zA );

extern DdNode * Extra_bddSpaceReduce( DdManager * dd, DdNode * bFunc, DdNode * bCanonVars );
extern DdNode ** Extra_bddSpaceExorGates( DdManager * dd, DdNode * bFuncRed, DdNode * zEquations );




extern DdNode * Extra_bddEncodingBinary( DdManager * dd, DdNode ** pbFuncs, int nFuncs, DdNode ** pbVars, int nVars );

extern DdNode * Extra_bddEncodingNonStrict( DdManager * dd, DdNode ** pbColumns, int nColumns, DdNode * bVarsCol, DdNode ** pCVars, int nMulti, int * pSimple );

extern st__table * Extra_bddNodePathsUnderCut( DdManager * dd, DdNode * bFunc, int CutLevel );

extern int Extra_bddNodePathsUnderCutArray( DdManager * dd, DdNode ** paNodes, DdNode ** pbCubes, int nNodes, DdNode ** paNodesRes, DdNode ** pbCubesRes, int CutLevel );

extern int Extra_ProfileWidth( DdManager * dd, DdNode * F, int * Profile, int CutLevel );



typedef struct Extra_ImageTree_t_ Extra_ImageTree_t;
extern Extra_ImageTree_t * Extra_bddImageStart(
    DdManager * dd, DdNode * bCare,
    int nParts, DdNode ** pbParts,
    int nVars, DdNode ** pbVars, int fVerbose );
extern DdNode * Extra_bddImageCompute( Extra_ImageTree_t * pTree, DdNode * bCare );
extern void Extra_bddImageTreeDelete( Extra_ImageTree_t * pTree );
extern DdNode * Extra_bddImageRead( Extra_ImageTree_t * pTree );

typedef struct Extra_ImageTree2_t_ Extra_ImageTree2_t;
extern Extra_ImageTree2_t * Extra_bddImageStart2(
    DdManager * dd, DdNode * bCare,
    int nParts, DdNode ** pbParts,
    int nVars, DdNode ** pbVars, int fVerbose );
extern DdNode * Extra_bddImageCompute2( Extra_ImageTree2_t * pTree, DdNode * bCare );
extern void Extra_bddImageTreeDelete2( Extra_ImageTree2_t * pTree );
extern DdNode * Extra_bddImageRead2( Extra_ImageTree2_t * pTree );



extern DdNode * Extra_TransferPermute( DdManager * ddSource, DdManager * ddDestination, DdNode * f, int * Permute );
extern DdNode * Extra_TransferLevelByLevel( DdManager * ddSource, DdManager * ddDestination, DdNode * f );
extern DdNode * Extra_bddRemapUp( DdManager * dd, DdNode * bF );
extern DdNode * Extra_bddMove( DdManager * dd, DdNode * bF, int nVars );
extern DdNode * extraBddMove( DdManager * dd, DdNode * bF, DdNode * bFlag );
extern void Extra_StopManager( DdManager * dd );
extern void Extra_bddPrint( DdManager * dd, DdNode * F );
extern void Extra_bddPrintSupport( DdManager * dd, DdNode * F );
extern void extraDecomposeCover( DdManager* dd, DdNode* zC, DdNode** zC0, DdNode** zC1, DdNode** zC2 );
extern int Extra_bddSuppSize( DdManager * dd, DdNode * bSupp );
extern int Extra_bddSuppContainVar( DdManager * dd, DdNode * bS, DdNode * bVar );
extern int Extra_bddSuppOverlapping( DdManager * dd, DdNode * S1, DdNode * S2 );
extern int Extra_bddSuppDifferentVars( DdManager * dd, DdNode * S1, DdNode * S2, int DiffMax );
extern int Extra_bddSuppCheckContainment( DdManager * dd, DdNode * bL, DdNode * bH, DdNode ** bLarge, DdNode ** bSmall );
extern int * Extra_SupportArray( DdManager * dd, DdNode * F, int * support );
extern int * Extra_VectorSupportArray( DdManager * dd, DdNode ** F, int n, int * support );
extern DdNode * Extra_bddFindOneCube( DdManager * dd, DdNode * bF );
extern DdNode * Extra_bddGetOneCube( DdManager * dd, DdNode * bFunc );
extern DdNode * Extra_bddComputeRangeCube( DdManager * dd, int iStart, int iStop );
extern DdNode * Extra_bddBitsToCube( DdManager * dd, int Code, int CodeWidth, DdNode ** pbVars, int fMsbFirst );
extern DdNode * Extra_bddSupportNegativeCube( DdManager * dd, DdNode * f );
extern int Extra_bddIsVar( DdNode * bFunc );
extern DdNode * Extra_bddCreateAnd( DdManager * dd, int nVars );
extern DdNode * Extra_bddCreateOr( DdManager * dd, int nVars );
extern DdNode * Extra_bddCreateExor( DdManager * dd, int nVars );
extern DdNode * Extra_zddPrimes( DdManager * dd, DdNode * F );
extern void Extra_bddPermuteArray( DdManager * dd, DdNode ** bNodesIn, DdNode ** bNodesOut, int nNodes, int *permut );
extern DdNode * Extra_bddComputeCube( DdManager * dd, DdNode ** bXVars, int nVars );
extern DdNode * Extra_bddChangePolarity( DdManager * dd, DdNode * bFunc, DdNode * bVars );
extern DdNode * extraBddChangePolarity( DdManager * dd, DdNode * bFunc, DdNode * bVars );
extern int Extra_bddVarIsInCube( DdNode * bCube, int iVar );
extern DdNode * Extra_bddAndPermute( DdManager * ddF, DdNode * bF, DdManager * ddG, DdNode * bG, int * pPermute );
extern int Extra_bddCountCubes( DdManager * dd, DdNode ** pFuncs, int nFuncs, int fMode, int nLimit, int * pGuide );
extern void Extra_zddDumpPla( DdManager * dd, DdNode * zCover, int nVars, char * pFileName );


extern DdNode * Extra_bddTuples( DdManager * dd, int K, DdNode * bVarsN );
extern DdNode * extraBddTuples( DdManager * dd, DdNode * bVarsK, DdNode * bVarsN );
# 212 "/app/abc/src/bdd/extrab/extraBdd.h"
extern DdNode * Extra_zddMaximal (DdManager *dd, DdNode *S);
extern DdNode * extraZddMaximal (DdManager *dd, DdNode *S);
extern DdNode * Extra_zddMinimal (DdManager *dd, DdNode *S);
extern DdNode * extraZddMinimal (DdManager *dd, DdNode *S);

extern DdNode * Extra_zddMaxUnion (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * extraZddMaxUnion (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * Extra_zddMinUnion (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * extraZddMinUnion (DdManager *dd, DdNode *S, DdNode *T);

extern DdNode * Extra_zddDotProduct (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * extraZddDotProduct (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * Extra_zddCrossProduct (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * extraZddCrossProduct (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * Extra_zddMaxDotProduct (DdManager *dd, DdNode *S, DdNode *T);
extern DdNode * extraZddMaxDotProduct (DdManager *dd, DdNode *S, DdNode *T);




extern DdNode * Extra_zddSubSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * extraZddSubSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * Extra_zddSupSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * extraZddSupSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * Extra_zddNotSubSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * extraZddNotSubSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * Extra_zddNotSupSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * extraZddNotSupSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * Extra_zddMaxNotSupSet (DdManager *dd, DdNode *X, DdNode *Y);
extern DdNode * extraZddMaxNotSupSet (DdManager *dd, DdNode *X, DdNode *Y);

extern int Extra_zddEmptyBelongs (DdManager *dd, DdNode* zS);

extern int Extra_zddIsOneSubset (DdManager *dd, DdNode* zS);




extern void Extra_PrintKMap( FILE * pFile, DdManager * dd, DdNode * OnSet, DdNode * OffSet, int nVars, DdNode ** XVars, int fSuppType, char ** pVarNames );

extern void Extra_PrintKMapRelation( FILE * pFile, DdManager * dd, DdNode * OnSet, DdNode * OffSet, int nXVars, int nYVars, DdNode ** XVars, DdNode ** YVars );



typedef struct Extra_SymmInfo_t_ Extra_SymmInfo_t;
struct Extra_SymmInfo_t_ {
    int nVars;
    int nVarsMax;
    int nSymms;
    int nNodes;
    int * pVars;
    char ** pSymms;
};


extern Extra_SymmInfo_t * Extra_SymmPairsCompute( DdManager * dd, DdNode * bFunc );

extern Extra_SymmInfo_t * Extra_SymmPairsComputeNaive( DdManager * dd, DdNode * bFunc );
extern int Extra_bddCheckVarsSymmetricNaive( DdManager * dd, DdNode * bF, int iVar1, int iVar2 );


extern Extra_SymmInfo_t * Extra_SymmPairsAllocate( int nVars );

extern void Extra_SymmPairsDissolve( Extra_SymmInfo_t * );

extern void Extra_SymmPairsPrint( Extra_SymmInfo_t * );

extern Extra_SymmInfo_t * Extra_SymmPairsCreateFromZdd( DdManager * dd, DdNode * zPairs, DdNode * bVars );


extern DdNode * Extra_zddSymmPairsCompute( DdManager * dd, DdNode * bF, DdNode * bVars );
extern DdNode * extraZddSymmPairsCompute( DdManager * dd, DdNode * bF, DdNode * bVars );

extern DdNode * Extra_zddGetSymmetricVars( DdManager * dd, DdNode * bF, DdNode * bG, DdNode * bVars );
extern DdNode * extraZddGetSymmetricVars( DdManager * dd, DdNode * bF, DdNode * bG, DdNode * bVars );

extern DdNode * Extra_zddGetSingletons( DdManager * dd, DdNode * bVars );
extern DdNode * extraZddGetSingletons( DdManager * dd, DdNode * bVars );

extern DdNode * Extra_bddReduceVarSet( DdManager * dd, DdNode * bVars, DdNode * bF );
extern DdNode * extraBddReduceVarSet( DdManager * dd, DdNode * bVars, DdNode * bF );


extern int Extra_bddCheckVarsSymmetric( DdManager * dd, DdNode * bF, int iVar1, int iVar2 );
extern DdNode * extraBddCheckVarsSymmetric( DdManager * dd, DdNode * bF, DdNode * bVars );


extern DdNode * Extra_zddTuplesFromBdd( DdManager * dd, int K, DdNode * bVarsN );
extern DdNode * extraZddTuplesFromBdd( DdManager * dd, DdNode * bVarsK, DdNode * bVarsN );

extern DdNode * Extra_zddSelectOneSubset( DdManager * dd, DdNode * zS );
extern DdNode * extraZddSelectOneSubset( DdManager * dd, DdNode * zS );



extern DdNode * Extra_bddAndTime( DdManager * dd, DdNode * f, DdNode * g, int TimeOut );
extern DdNode * Extra_bddAndAbstractTime( DdManager * manager, DdNode * f, DdNode * g, DdNode * cube, int TimeOut );
extern DdNode * Extra_TransferPermuteTime( DdManager * ddSource, DdManager * ddDestination, DdNode * f, int * Permute, int TimeOut );



typedef struct Extra_UnateVar_t_ Extra_UnateVar_t;
struct Extra_UnateVar_t_ {
    unsigned iVar : 30;
    unsigned Pos : 1;
    unsigned Neg : 1;
};

typedef struct Extra_UnateInfo_t_ Extra_UnateInfo_t;
struct Extra_UnateInfo_t_ {
    int nVars;
    int nVarsMax;
    int nUnate;
    Extra_UnateVar_t * pVars;
};


extern Extra_UnateInfo_t * Extra_UnateInfoAllocate( int nVars );

extern void Extra_UnateInfoDissolve( Extra_UnateInfo_t * );

extern void Extra_UnateInfoPrint( Extra_UnateInfo_t * );

extern Extra_UnateInfo_t * Extra_UnateInfoCreateFromZdd( DdManager * dd, DdNode * zUnate, DdNode * bVars );

extern int Extra_bddCheckUnateNaive( DdManager * dd, DdNode * bF, int iVar );


extern Extra_UnateInfo_t * Extra_UnateComputeFast( DdManager * dd, DdNode * bFunc );
extern Extra_UnateInfo_t * Extra_UnateComputeSlow( DdManager * dd, DdNode * bFunc );


extern DdNode * Extra_zddUnateInfoCompute( DdManager * dd, DdNode * bF, DdNode * bVars );
extern DdNode * extraZddUnateInfoCompute( DdManager * dd, DdNode * bF, DdNode * bVars );


extern DdNode * Extra_zddGetSingletonsBoth( DdManager * dd, DdNode * bVars );
extern DdNode * extraZddGetSingletonsBoth( DdManager * dd, DdNode * bVars );






# 39 "/app/abc/src/base/main/mainInt.h" 2



# 57 "/app/abc/src/base/main/mainInt.h"
typedef void (*Abc_Frame_Callback_BmcFrameDone_Func)(int frame, int po, int status);

struct Abc_Frame_t_
{

    char * sVersion;
    char * sBinary;

    st__table * tCommands;
    st__table * tAliases;
    st__table * tFlags;
    Vec_Ptr_t * aHistory;

    Abc_Ntk_t * pNtkCur;
    Abc_Ntk_t * pNtkBestDelay;
    Abc_Ntk_t * pNtkBestArea;
    Abc_Ntk_t * pNtkBackup;
    int nSteps;
    int fSource;
    int fAutoexac;
    int fBatchMode;
    int fBridgeMode;

    Abc_Ntk_t * pNtkBest;
    float nBestNtkArea;
    float nBestNtkDelay;
    int nBestNtkNodes;
    int nBestNtkLevels;


    FILE * Out;
    FILE * Err;
    FILE * Hst;

    double TimeCommand;
    double TimeTotal;

    Vec_Ptr_t * vStore;

    void * pManDec;
    void * pManDsd;
    void * pManDsd2;

    void * pLibLut;
    void * pLibBox;
    void * pLibGen;
    void * pLibGen2;
    void * pLibSuper;
    void * pLibScl;
    void * pAbcCon;

    char * pDrivingCell;
    float MaxLoad;

    Vec_Int_t * vIndFlops;
    int nIndFrames;


    Gia_Man_t * pGia;
    Gia_Man_t * pGia2;
    Gia_Man_t * pGiaBest;
    Gia_Man_t * pGiaBest2;
    Gia_Man_t * pGiaSaved;
    int nBestLuts;
    int nBestEdges;
    int nBestLevels;
    int nBestLuts2;
    int nBestEdges2;
    int nBestLevels2;
    Abc_Cex_t * pCex;
    Abc_Cex_t * pCex2;
    Vec_Ptr_t * vCexVec;
    Vec_Ptr_t * vPoEquivs;
    Vec_Int_t * vStatuses;
    Vec_Int_t * vAbcObjIds;
    int Status;
    int nFrames;
    Vec_Ptr_t * vPlugInComBinPairs;
    Vec_Ptr_t * vLTLProperties_global;
    Vec_Ptr_t * vSignalNames;
    char * pSpecName;
    void * pSave1;
    void * pSave2;
    void * pSave3;
    void * pSave4;
    void * pAbc85Ntl;
    void * pAbc85Ntl2;
    void * pAbc85Best;
    void * pAbc85Delay;
    void * pAbcWlc;
    Vec_Int_t * pAbcWlcInv;
    void * pAbcRtl;
    void * pAbcBac;
    void * pAbcCba;
    void * pAbcPla;
    Abc_Nam_t * pJsonStrs;
    Vec_Wec_t * vJsonObjs;

    DdManager * dd;

    Gia_Man_t * pGiaMiniAig;
    Gia_Man_t * pGiaMiniLut;
    Vec_Int_t * vCopyMiniAig;
    Vec_Int_t * vCopyMiniLut;
    int * pArray;
    int * pBoxes;
    void * pNdr;
    int * pNdrArray;

    Abc_Frame_Callback_BmcFrameDone_Func pFuncOnFrameDone;
};

typedef void (*Abc_Frame_Initialization_Func)( Abc_Frame_t * pAbc );

struct Abc_FrameInitializer_t_;
typedef struct Abc_FrameInitializer_t_ Abc_FrameInitializer_t;

struct Abc_FrameInitializer_t_
{
    Abc_Frame_Initialization_Func init;
    Abc_Frame_Initialization_Func destroy;

    Abc_FrameInitializer_t* next;
    Abc_FrameInitializer_t* prev;
};
# 197 "/app/abc/src/base/main/mainInt.h"
extern int main( int argc, char * argv[] );

extern void Abc_FrameInit( Abc_Frame_t * pAbc );
extern void Abc_FrameEnd( Abc_Frame_t * pAbc );
extern void Abc_FrameAddInitializer( Abc_FrameInitializer_t* p );

extern Abc_Frame_t * Abc_FrameAllocate();
extern void Abc_FrameDeallocate( Abc_Frame_t * p );

extern char * Abc_UtilsGetVersion( Abc_Frame_t * pAbc );
extern char * Abc_UtilsGetUsersInput( Abc_Frame_t * pAbc );
extern void Abc_UtilsPrintHello( Abc_Frame_t * pAbc );
extern void Abc_UtilsPrintUsage( Abc_Frame_t * pAbc, char * ProgName );
extern void Abc_UtilsSource( Abc_Frame_t * pAbc );

extern void print_frame( Abc_Frame_t * pAbc );


# 2 "/app/abc/src/base/main/print_Frame.c" 2





void print_frame( Abc_Frame_t * pAbc )
{


    printf("only printing the Ntk in frame\n");
    printf("Frame pNtkCur: %p\n", pAbc->pNtkCur->vObjs);
}







